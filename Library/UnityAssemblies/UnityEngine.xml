<?xml version="1.0" encoding="utf-8"?>
<doc>
  <!-- Generated by uIntelliSense 1.4.3.0 -->
  <assembly>
    <name>UnityEngine</name>
  </assembly>
  <members>
    <member name="T:UnityEngine.AndroidJavaRunnable">
      <summary>AndroidJavaRunnable is the Unity representation of a java.lang.Runnable object.</summary>
    </member>
    <member name="T:UnityEngine.WSA.AppCallbackItem">
      <summary>Delegate that can be invoked on specific thread.</summary>
    </member>
    <member name="T:UnityEngine.GUI.WindowFunction">
      <summary>
        <para>Callback to draw GUI within a window (used with <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />).</para>
        <para>This function takes the ID number of the window to be drawn. Its body should contains GUI calls to display the window, much like a standard OnGUI function. This function can then be passed as a parameter to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" /> to draw the appropriate contents.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Application.LogCallback">
      <summary>Use this delegate type with <see href="Application-logMessageReceived" cref="Application.logMessageReceived" /> or <see href="Application-logMessageReceivedThreaded" cref="Application.logMessageReceivedThreaded" /> to monitor what gets logged.</summary>
    </member>
    <member name="T:UnityEngine.AudioClip.PCMReaderCallback">
      <summary>Delegate called each time <see cref="T:UnityEngine.AudioClip" /> reads data.</summary>
    </member>
    <member name="T:UnityEngine.AudioClip.PCMSetPositionCallback">
      <summary>Delegate called each time <see cref="T:UnityEngine.AudioClip" /> changes read position.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction">
      <summary>Zero argument delegate used by UnityEvents.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction``1">
      <summary>One argument delegate used by UnityEvents.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction``2">
      <summary>Two argument delegate used by UnityEvents.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction``3">
      <summary>Three argument delegate used by UnityEvents.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction``4">
      <summary>Four argument delegate used by UnityEvents.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SpawnDelegate">
      <summary>Signature of spawn functions that are passed to NetworkClient.RegisterSpawnFunction(). This is optional, as in most cases RegisterPrefab will be used instead.</summary>
    </member>
    <member name="T:UnityEngine.Networking.UnSpawnDelegate">
      <summary>Delegate for a function which will handle destruction of objects created with NetworkServer.Spawn.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkMessageDelegate">
      <summary>The callback delegate used in message handler functions.</summary>
    </member>
    <member name="T:UnityEngine.Advertisements.Advertisement">
      <summary>Unity Ads.</summary>
    </member>
    <member name="T:UnityEngine.Advertisements.ShowOptions">
      <summary>Collection of options that can be passed to Advertisements.Show to modify advertisement behaviour.</summary>
    </member>
    <member name="T:UnityEngine.Advertisements.Advertisement.DebugLevel">
      <summary>Player debug message level.</summary>
    </member>
    <member name="T:UnityEngine.Advertisements.ShowResult">
      <summary>ShowResult is passed to <see href="Advertisements.ShowOptions-resultCallback" cref="ShowOptions.resultCallback" /> after the advertisement has completed.</summary>
    </member>
    <member name="T:UnityEngine.Analytics.Analytics">
      <summary>
        <para>Unity Analytics provides insight into your game users e.g. DAU, MAU.</para>
        <para>Note: The documentation that follows is for usage of Unity Analytics with Unity 5.1 and above. To integrate Unity Analytics with earlier versions of Unity, refer to the documentation at https://analytics.cloud.unity3d.com/docsSpecifically, out-of-the-box features include access to user engagement and retention data through Metric Monitor and Data Explorer. Segmentation of players across various user dimensions and characteristics is automatically applied, with more than 20 standard segments available without any additional instrumentation.For more detail around features, refer to the Unity Analytics homepage at http://unity3d.com/unity/analytics.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Analytics.AnalyticsResult">
      <summary>Analytics API result.</summary>
    </member>
    <member name="T:UnityEngine.Analytics.Gender">
      <summary>User Demographics: Gender of a user.</summary>
    </member>
    <member name="T:UnityEngine.Assertions.Must.MustExtensions">
      <summary>
        <para>An extension class that serves as a wrapper for the Assert class.</para>
        <para>The MustExtension class wraps the Assertion.Assert into a more readable and shorter syntax.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Assertions.Assert">
      <summary>
        <para>The Assert class contains assertion methods for setting invariants in the code.</para>
        <para>All method calls will be conditionally included only in the development builds, unless explicitly specified (see <see cref="F:UnityEditor.BuildOptions.ForceEnableAssertions" />). The inclusion of the assertions is controlled by UNITY_ASSERTIONS define. A failure of an assertion method does not break the control flow of the execution. On a failure, an assertion message is logged (<see cref="F:UnityEngine.LogType.Assert" />) and the execution continues. If <see cref="F:UnityEngine.Assertions.Assert.raiseExceptions" /> is set to true, an <see cref="T:UnityEngine.Assertions.AssertionException" /> is thrown instead of logging a message. If a debugger is attached to the project (System.Diagnostics.Debugger.IsAttached is true), <see cref="T:UnityEngine.Assertions.AssertionException" /> will be thrown in order to pause the excecution and invoke the debugger. For shorter and more readable syntaxt see <see cref="T:UnityEngine.Assertions.Must.MustExtensions" />.</para>
        <para>For different assertions syntax see <see cref="T:UnityEngine.Assertions.Must.MustExtensions" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Assertions.AssertionException">
      <summary>An exception that is thrown on a failure. <see cref="F:UnityEngine.Assertions.Assert.raiseExceptions" /> needs to be set to true.</summary>
    </member>
    <member name="T:UnityEngine.Audio.AudioMixer">
      <summary>
        <para>AudioMixer asset.</para>
        <para>This is a singleton representing a specific audio mixer asset in the project.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Audio.AudioMixerGroup">
      <summary>Object representing a group in the mixer.</summary>
    </member>
    <member name="T:UnityEngine.Audio.AudioMixerSnapshot">
      <summary>Object representing a snapshot in the mixer.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent">
      <summary>A zero argument persistent callback that can be saved with the scene.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent``1">
      <summary>
        <para>One argument version of <see cref="T:UnityEngine.Events.UnityEvent" />.</para>
        <para>If you wish to use a generic UnityEvent type you must override the class type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent``2">
      <summary>
        <para>Two argument version of <see cref="T:UnityEngine.Events.UnityEvent" />.</para>
        <para>If you wish to use a generic UnityEvent type you must override the class type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent``3">
      <summary>
        <para>Three argument version of <see cref="T:UnityEngine.Events.UnityEvent" />.</para>
        <para>If you wish to use a generic UnityEvent type you must override the class type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent``4">
      <summary>
        <para>Four argument version of <see cref="T:UnityEngine.Events.UnityEvent" />.</para>
        <para>If you wish to use a generic UnityEvent type you must override the class type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEventBase">
      <summary>
        <para>Abstract base class for UnityEvents.</para>
        <para>This class provides the base functionality for the UnityEvents.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.PersistentListenerMode">
      <summary>THe mode that a listener is operating in.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEventCallState">
      <summary>Controls the scope of UnityEvent callbacks.</summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView">
      <summary>
        <para>ADBannerView is a wrapper around the ADBannerView class found in the Apple iAd framework and is only available on iOS.</para>
        <para>It provides a view that displays banner advertisements to the user.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ADInterstitialAd">
      <summary>
        <para>ADInterstitialAd is a wrapper around the ADInterstitialAd class found in the Apple iAd framework and is only available on iPad.</para>
        <para>It provides full-screen advertisements that your iPad application can display to the user.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.Device">
      <summary>Interface into iOS specific functionality.</summary>
    </member>
    <member name="T:UnityEngine.iOS.LocalNotification">
      <summary>
        <para>iOS.LocalNotification is a wrapper around the UILocalNotification class found in the Apple UIKit framework and is only available on iPhone/iPad/iPod Touch.</para>
        <para>It represents notifications that an application can schedule for presentation to its user at specific dates and times. The operating system is responsible for delivering the notification at the specified time. Local notifications are similar to remote notifications but are scheduled and delivered locally and do not require connection with remote servers.Local notifications are scheduled and handled using NotificationServices class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.NotificationServices">
      <summary>
        <para>NotificationServices is only available on iPhone/iPad/iPod Touch.</para>
        <para>It is used for scheduling, registering and handling notifications.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.OnDemandResources">
      <summary>On Demand Resources API.</summary>
    </member>
    <member name="T:UnityEngine.iOS.OnDemandResourcesRequest">
      <summary>
        <para>Represents a request for On Demand Resources (ODR). It's an <see cref="T:UnityEngine.AsyncOperation" /> and can be yielded in a coroutine.</para>
        <para>NOTE: only available on iOS.Creating an <see cref="T:UnityEngine.iOS.OnDemandResourcesRequest" /> is equivalent of calling <c>beginAccessingResourcesWithCompletionHandler</c> on <c>NSBundleResourceRequest</c> class. The request will keep ODR resource alive until either <see cref="M:UnityEngine.iOS.OnDemandResourcesRequest.Dispose" />() is called or request object is collected by a garbage collector, which is equivalent of calling <c>endAccessingResources</c> on <c>NSBundleResourceRequest</c> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.RemoteNotification">
      <summary>
        <para>RemoteNotification is only available on iPhone/iPad/iPod Touch.</para>
        <para>Remote notifications are sent by an application's remote server (its provider) to Apple Push Notification service which pushes the notification to devices on which the application is installed.Remote notifications are registered for and handled using NotificationServices class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ActivityIndicatorStyle">
      <summary>ActivityIndicator Style (iOS Specific).</summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView.Layout">
      <summary>
        <para>Specifies how banner should be layed out on screen.</para>
        <para>Please note that Traditional Banner and Rect Banner (introduced in ios6) use different enum values. If you use "wrong" enum value for current ad type: for Traditional Banner Top* and Center* will be considered Top, and Bottom* will be considered Bottom* for Rect Banner Top will be considered TopLeft and Bottom - BottomLeft.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView.Type">
      <summary>
        <para>The type of the banner view.</para>
        <para>Please check availability of banner type with <see cref="M:UnityEngine.iOS.ADBannerView.IsAvailable(System.Type)" />. Traditional banner is always available, though.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.CalendarIdentifier">
      <summary>Specify calendar types.</summary>
    </member>
    <member name="T:UnityEngine.iOS.CalendarUnit">
      <summary>Specify calendrical units.</summary>
    </member>
    <member name="T:UnityEngine.iOS.DeviceGeneration">
      <summary>iOS device generation.</summary>
    </member>
    <member name="T:UnityEngine.iOS.NotificationType">
      <summary>Specifies local and remote notification types.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.BasicResponse">
      <summary>JSON response for types that only require a basic indication of success.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.CreateMatchRequest">
      <summary>JSON object to request a UNET match creation.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.CreateMatchResponse">
      <summary>JSON response for a CreateMatchRequest. It contains all information necessdary to continue joining a match.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.CreateOrJoinMatchRequest">
      <summary>JSON object to join an ongoing match or to create a new one if it doesn't exist.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.DestroyMatchRequest">
      <summary>JSON object to request a UNET match destruction.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.DropConnectionRequest">
      <summary>JSON object to request a UNET match drop a client.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.JoinMatchRequest">
      <summary>JSON object to request joining an existing UNET match.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.JoinMatchResponse">
      <summary>JSON response for a JoinMatchRequest. It contains all information necessdary to continue joining a match.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.ListMatchRequest">
      <summary>JSON object to request a list of UNET matches. This list is page based with a 1 index.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.ListMatchResponse">
      <summary>JSON response for a ListMatchRequest. It contains a list of matches that can be parsed through to describe a page of matches.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.MatchDesc">
      <summary>A member contained in a ListMatchResponse.matches list. Each element describes an individual match.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.MatchDirectConnectInfo">
      <summary>Class describing a client in a network match.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.MatchInfo">
      <summary>
        <para>Details about a UNET Matchmaker match.</para>
        <para>This is returned from UMatch.CreateMatch() and UMatch.JoinMatch().</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.NetworkMatch">
      <summary>A component for communicating with the UNET Matchmaking service.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.Request">
      <summary>Abstract base for requests, which includes common info in all requests.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.Response">
      <summary>Abstract class that contains shared accessors for any response.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Match.ResponseBase">
      <summary>A response object base.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.AddPlayerMessage">
      <summary>This is passed to handler funtions registered for the SYSTEM_ADD_PLAYER built-in message.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.EmptyMessage">
      <summary>A utility class to send a network message with no contents.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.ErrorMessage">
      <summary>This is passed to handler functions registered for the SYSTEM_ERROR built-in message.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.IntegerMessage">
      <summary>A utility class to send simple network messages that only contain an integer.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.NotReadyMessage">
      <summary>This is passed to handler funtions registered for the SYSTEM_NOT_READY built-in message.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.PeerInfoMessage">
      <summary>Information about another participant in the same network game.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.PeerListMessage">
      <summary>Internal UNET message for sending information about network peers to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.ReadyMessage">
      <summary>This is passed to handler funtions registered for the SYSTEM_READY built-in message.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.RemovePlayerMessage">
      <summary>This is passed to handler funtions registered for the SYSTEM_REMOVE_PLAYER built-in message.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSystem.StringMessage">
      <summary>
        <para>This is a utility class for simple network messages that contain only a string.</para>
        <para>This example sends a message with the name of the scene.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.NetworkAccessToken">
      <summary>Access token used to authenticate a client session for the purposes of allowing or disallowing match operations requested by that client.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.AppID">
      <summary>The AppID identifies the application on the Unity Cloud or UNET servers.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.NetworkAccessLevel">
      <summary>Describes the access levels granted to this client.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.NetworkID">
      <summary>Network ID, used for match making.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.NodeID">
      <summary>The NodeID is the ID used in relay matches to track nodes in a network.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Types.SourceID">
      <summary>Identifies a specific game instance.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ChannelQOS">
      <summary>Defines parameters of channels.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Channels">
      <summary>Class containing constants for default network channels.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ClientScene">
      <summary>
        <para>A client manager which contains non-instance centrict client information and functions.</para>
        <para>This contains static state like tracked local objects and prefab/spawner registrations. It also has the default message handlers used by clients when they registered none themselves. The manager handles adding/removing player objects to the game afer a client connection has been set as ready.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.ConnectionConfig">
      <summary>This class defines parameters of connection between two peers, this definition includes various timeouts and sizes as well as channel configuration.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ConnectionSimulatorConfig">
      <summary>Create configuration for network simulator; You can use this class in editor and developer build only.</summary>
    </member>
    <member name="T:UnityEngine.Networking.GlobalConfig">
      <summary>Defines global paramters for network library.</summary>
    </member>
    <member name="T:UnityEngine.Networking.HostTopology">
      <summary>
        <para>Class defines network topology for host (socket opened by <see cref="M:UnityEngine.Networking.NetworkTransport.AddHost(UnityEngine.Networking.HostTopology,System.Int32,System.String)" /> function). This topology defines: (1) how many connection with default config will be supported and (2) what will be special connections (connections with config different from default).</para>
        <para>Example: p2p game with 10 people in the room and connection to chat server, in this case it will be 10 default connection and one special.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.LogFilter">
      <summary>FilterLog is a utility class that controls the level of logging generated by UNET clients and servers.</summary>
    </member>
    <member name="T:UnityEngine.Networking.MessageBase">
      <summary>
        <para>Network message classes should be derived from this class. These message classes can then be sent using the various Send functions of NetworkConnection, NetworkClient and NetworkServer.</para>
        <para>Public data fields of classes derived from MessageBase will be automatically serialized with the class. The virtual methods Serialize and Deserialize may be implemented by developers for precise control, but if they are not implemented, then implementations will be generated for them.In the example below, the methods have implementations, but if those methods were not implemented, the message would still be usable.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.MsgType">
      <summary>Container class for networking system built-in message types.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkAnimator">
      <summary>A component to synchronize Mecanim animation states for networked objects.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkBehaviour">
      <summary>
        <para>Base class which should be inherited by scripts which contain networking functionality.</para>
        <para>This is a MonoBehaviour class so scripts which need to use the networking feature should inherit this class instead of MonoBehaviour. It allows you to invoke RPC/Commands and receive various callbacks.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkBroadcastResult">
      <summary>A structure that contains data from a NetworkDiscovery server broadcast.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkClient">
      <summary>
        <para>High level UNET client.</para>
        <para>It can be used to connect to a high level UNET server instance (NetworkServer).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkConnection">
      <summary>High level network connection.</summary>
    </member>
    <member name="T:UnityEngine.Networking.PacketStat">
      <summary>Structure used to track the number and size of packets of each packets type.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkCRC">
      <summary>
        <para>This class holds information about which networked scripts use which QoS channels for updates.</para>
        <para>This channel information is used to ensure that clients and servers are using compatible HLAPI script configurations.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkDiscovery">
      <summary>
        <para>The NetworkDiscovery component allows Unity games to find each other on a local network. It can broadcast presence and listen for broadcasts, and optionally join matching games using the NetworkManager.</para>
        <para>This component can run in server mode (by calling StartAsServer) where it broadcasts to other computers on the local network, or in client mode (by calling StartAsClient) where it listens for broadcasts from a server.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkHash128">
      <summary>A 128 bit number used to represent assets in a networking context.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkIdentity">
      <summary>
        <para>A component used to add an object to the UNET networking system.</para>
        <para>The NetworkIdentity is used to synchronize information in the object with the network. Only the server should create instances of objects which have NetworkIdentity as otherwise they will not be properly connected to the system.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkInstanceId">
      <summary>This is used to identify networked objects across all participants of a network. It is assigned at runtime by the server when an object is spawned.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkLobbyManager">
      <summary>
        <para>This is a specialized NetworkManager that includes a networked lobby.</para>
        <para>The lobby has slots that track the joined players, and a maximum player count that is enforced. It requires that the NetworkLobbyPlayer component be on the lobby player objects.NetworkLobbyManager is derived from NetworkManager, and so it implements many of the virtual functions provided by the NetworkManager class. To avoid accidentally replacing functionality of the NetworkLobbyManager, there are new virtual functions on the NetworkLobbyManager that begin with "OnLobby". These should be used on classes derived from NetworkLobbyManager instead of the virtual functions on NetworkManager.The OnLobby*() functions have empty implementations on the NetworkLobbyManager base class, so the base class functions do not have to be called.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkLobbyPlayer">
      <summary>
        <para>This component works in conjunction with the NetworkLobbyManager to make up the multiplayer lobby system.</para>
        <para>The LobbyPrefab object of the NetworkLobbyManager must have this component on it. This component holds basic lobby player data required for the lobby to function. Game specific data for lobby players can be put in other components on the LobbyPrefab or in scripts derived from NetworkLobbyPlayer.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkManager">
      <summary>
        <para>The NetworkManager is a convenience class for the HLAPI for managing networking systems.</para>
        <para>For simple network applications the NetworkManager can be used to control the HLAPI. It provides simple ways to start and stop client and servers, to manage scenes, and has virtual functions that user code can use to implement handlers for network events. The NetworkManager deals with one client at a time. The example below shows a minimal network setup.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkManagerHUD">
      <summary>
        <para>An extension for the NetworkManager that displays a default HUD for controlling the network state of the game.</para>
        <para>This component also shows useful internal state for the networking system in the inspector window of the editor. It allows users to view connections, networked objects, message handlers, and packet statistics. This information can be helpful when debugging networked games.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkMessage">
      <summary>The details of a network message received by a client or server on a network connection.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkProximityChecker">
      <summary>
        <para>Component that controls visibility of networked objects for players.</para>
        <para>Any object with this component on it will not be visible to players more than a (configurable) distance away.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkReader">
      <summary>
        <para>General purpose serializer for UNET (for reading byte arrays).</para>
        <para>This class works with NetworkWriter and is used for serializing data for UNet commands, RPC calls, events and low level messages.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSceneId">
      <summary>This is used to identify networked objects in a scene. These values are allocated in the editor and are persistent for the lifetime of the object in the scene.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkServer">
      <summary>
        <para>High level network server.</para>
        <para>This class handles listening on a port and managing connections for clients that connect. It also handles game related features such as player management, observers, spawning and message handling.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkStartPosition">
      <summary>
        <para>This component is used to make a gameObject a starting position for spawning player objects in multiplayer games.</para>
        <para>This object's transform will be automatically registered and unregistered with the NetworkManager as a starting position.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransform">
      <summary>A component to synchronize the position of networked objects.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransformChild">
      <summary>
        <para>A component to synchronize the position of child transforms of networked objects.</para>
        <para>There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransformVisualizer">
      <summary>This is a helper component to help understand and debug networked movement synchronization with the NetworkTransform component.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransport">
      <summary>Low level (transport layer) API.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkWriter">
      <summary>General purpose serializer for UNET (for serializing data to byte arrays).</summary>
    </member>
    <member name="T:UnityEngine.Networking.PlayerController">
      <summary>This represents a networked player.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncList``1">
      <summary>This is the base class for type-specific SyncList classes.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListBool">
      <summary>A list of booleans that will be synchronized from server to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListFloat">
      <summary>A list of floats that will be synchronized from server to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListInt">
      <summary>A list of integers that will be synchronized from server to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListString">
      <summary>This is a list of strings that will be synchronized from the server to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListStruct``1">
      <summary>
        <para>This class is used for lists of structs that are synchronized from the server to clients.</para>
        <para>To use SyncListStruct, derive a new class with your struct as the generic parameter.</para>
        <para>Serialization methods will be auto-generated for this new class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncListUInt">
      <summary>A list of unsigned integers that will be synchronized from server to clients.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ChannelOption">
      <summary>An enumeration of the options that can be set on a network channel.</summary>
    </member>
    <member name="T:UnityEngine.Networking.LogFilter.FilterLevel">
      <summary>Control how verbose the network log messages are.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkError">
      <summary>Possible transport layer erors.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkEventType">
      <summary>Type of events returned from Receive() function.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkProximityChecker.CheckMethod">
      <summary>Enumeration of methods to use to check proximity.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransform.AxisSyncMode">
      <summary>An axis or set of axis.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransform.CompressionSyncMode">
      <summary>How much to compress sync data.</summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkTransform.TransformSyncMode">
      <summary>How to synchronize an object's position.</summary>
    </member>
    <member name="T:UnityEngine.Networking.PlayerSpawnMethod">
      <summary>Enumeration of methods of where to spawn player objects in multiplayer games.</summary>
    </member>
    <member name="T:UnityEngine.Networking.QosType">
      <summary>Descibed allowed types of quality of service for channels.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ReactorModel">
      <summary>Define how unet will handle network io operation.</summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncList_1.Operation">
      <summary>The types of operations that can occur for SyncLists.</summary>
    </member>
    <member name="T:UnityEngine.Networking.Version">
      <summary>Enumeration of Networking versions.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ClientAttribute">
      <summary>
        <para>A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on clients.</para>
        <para>A [Client] method returns immediately if NetworkClient.active is not true, and generates a warning on the console. This attribute can be put on member functions that are meant to be only called on clients. This would redundant for [ClientRPC] functions, as being client-only is already enforced for them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.ClientCallbackAttribute">
      <summary>
        <para>A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on clients, but not generate warnings.</para>
        <para>This custom attribute is the same as the [Client] custom attribute, except that it does not generate a warning in the console if called on a server. This is useful to avoid spamming the console for functions that will be invoked by the engine, such as Update() or physics callbacks.</para>
        <para>This will make the explosion code only run when the trigger is hit on the client.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.ClientRpcAttribute">
      <summary>
        <para>This is an attribute that can be put on methods of NetworkBehaviour classes to allow them to be invoked on clients from a server.</para>
        <para>[ClientRPC] functions are called by user code on UNET servers, and then invoked on corresponding client objects on clients connected to the server. The arguments to the RPC call are seriialized across the network, so that the client function is invoked with the same values as the function on the server. These functios must begin with the prefix "Rpc".</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.CommandAttribute">
      <summary>
        <para>This is an attribute that can be put on methods of NetworkBehaviour classes to allow them to be invoked on the server by sending a command from a client.</para>
        <para>[Command] functions are invoked on the player object associated with a connection. This is setup in response to the "ready" message, by passing the player objec to the NetworkServer.PlayerIsReady() function. The arguments to the command call are seriialized across the network, so that the server function is invoked with the same values as the function on the client. These functions must begin with the prefix "Cmd".</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.NetworkSettingsAttribute">
      <summary>This attribute is used to configure the network settings of scripts that are derived from the NetworkBehaviour base class.</summary>
    </member>
    <member name="T:UnityEngine.Networking.ServerAttribute">
      <summary>
        <para>A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on servers.</para>
        <para>A [Server] method returns immediately if NetworkServer.active is not true, and generates a warning on the console. This attribute can be put on member functions that are meant to be only called on server. This would redundant for [Command] functions, as being server-only is already enforced for them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.ServerCallbackAttribute">
      <summary>
        <para>A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on servers, but not generate warnings.</para>
        <para>This custom attribute is the same as the [Server] custom attribute, except that it does not generate a warning in the console if called on a client. This is useful to avoid spamming the console for functions that will be invoked by the engine, such as Update() or physics callbacks.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncEventAttribute">
      <summary>
        <para>This is an attribute that can be put on events in NetworkBehaviour classes to allow them to be invoked on client when the event is called on the sserver.</para>
        <para>[SyncEvent] events are called by user code on UNET servers, and then invoked on corresponding client objects on clients connected to the server. The arguments to the Event call are seriialized across the network, so that the client event is invoked with the same values as the function on the server. These events must begin with the prefix "Event".</para>
        <para>SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Networking.SyncVarAttribute">
      <summary>
        <para>[SyncVar] is an attribute that can be put on member variables of UNeBehaviour classes. These variables will have their values sychronized from the server to clients in the game that are in the ready state.</para>
        <para>Setting thje value of a [SyncVar] marks it as dirty, so it will be sent to clients at the end of the current frame. Only simple values can be marked as [SyncVars].</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.CommandBuffer">
      <summary>
        <para>List of graphics commands to execute.</para>
        <para>Command buffers hold list of rendering commands ("set render target, draw mesh, ..."). They can be set to execute at various points during camera rendering (see <see cref="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />), light rendering (see <see cref="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />) or be executed immediately (see <see cref="M:UnityEngine.Graphics.ExecuteCommandBuffer(UnityEngine.Rendering.CommandBuffer)" />).Typically they would be used to extend Unity's rendering pipeline in some custom ways. For example, you could render some additional objects into deferred rendering g-buffer after all regular objects are done, or do custom processing of light shadow maps.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeBlendInfo">
      <summary>ReflectionProbeBlendInfo contains information required for blending probes.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderTargetIdentifier">
      <summary>
        <para>Identifies a <see cref="T:UnityEngine.RenderTexture" /> for a <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
        <para>Render textures can be identified in a number of ways, for example a <see cref="T:UnityEngine.RenderTexture" /> object, or one of built-in render textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />), or a temporary render texture with a name (that was created using <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />).This struct serves as a way to identify them, and has implcit conversion operators so that in most cases you can save some typing.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.SphericalHarmonicsL2">
      <summary>
        <para>Spherical harmonics up to the second order (3 bands, 9 coefficients).</para>
        <para>Spherical harmonics (SH) represent a function or signal over directions, and are commonly used in computer graphics to efficiently evaluate smooth lighting. Unity uses them for <see cref="T:UnityEngine.LightProbes" /> and environment lighting.L2 spherical harmonics is composed of 9 coefficients for each color channel.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, <see cref="P:UnityEngine.RenderSettings.ambientProbe" />, <see cref="T:UnityEngine.LightProbes" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.AmbientMode">
      <summary>
        <para>Ambient lighting mode.</para>
        <para>Unity can provide ambient lighting in several modes, for example directional ambient with separate sky, equator and ground colors, or flat ambient with a single color.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BlendMode">
      <summary>
        <para>Blend mode for controlling the blending.</para>
        <para>The blend mode is set separately for source and destination, and it controls the blend factor of each component going into the blend equation. It is also possible to set the blend mode for color and alpha components separately. Note: the blend modes are ignored if logical blend operations or advanced OpenGL blend operations are in use.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BlendOp">
      <summary>
        <para>Blend operation.</para>
        <para>The blend operation that is used to combine the pixel shader output with the render target. This can be passed through Material.SetInt() to change the blend operation during runtime.Note that the logical operations are only supported in Gamma (non-sRGB) colorspace, on DX11.1 hardware running on DirectX 11.1 runtime.Advanced OpenGL blend operations are supported only on hardware supporting either GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced and may require use of <see cref="M:UnityEngine.GL.RenderTargetBarrier" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BuiltinRenderTextureType">
      <summary>
        <para>Built-in temporary render textures produced during camera's rendering.</para>
        <para>When camera is rendering the scene, in some cases it can produce temporary render textures in the process (e.g. depth textures, deferred G-buffer etc.). This enum indicates these temporary render textures.BuiltinRenderTextureType can be used as a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> in some functions of <see cref="T:UnityEngine.Rendering.CommandBuffer" />.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.CameraEvent">
      <summary>
        <para>Defines a place in camera's rendering to attach <see cref="T:UnityEngine.Rendering.CommandBuffer" /> objects to.</para>
        <para>Unity's rendering loop can be extended by adding so called "command buffers" at various points in camera rendering. For example, you could add some custom geometry to be drawn right after the skybox is drawn.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="T:UnityEngine.Rendering.LightEvent" />, command buffers overview.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ColorWriteMask">
      <summary>Specifies which color components will get written into the target framebuffer.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.CompareFunction">
      <summary>Depth or stencil comparison function.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.CullMode">
      <summary>Backface culling mode.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.DefaultReflectionMode">
      <summary>
        <para>Default reflection mode.</para>
        <para>Unity can use a custom texture or generate a specular reflection texture from the skybox.See Also: <see cref="P:UnityEngine.RenderSettings.defaultReflectionMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.GraphicsDeviceType">
      <summary>
        <para>Graphics device API type.</para>
        <para>Many different low-level graphics APIs can be used by Unity. If for some reason you need to know whether Direct3D 9 or 11 is being used, or OpenGL ES 2 or 3, you can use <see cref="P:UnityEngine.SystemInfo.graphicsDeviceType" /> to check for that.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceType" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.LightEvent">
      <summary>
        <para>Defines a place in light's rendering to attach <see cref="T:UnityEngine.Rendering.CommandBuffer" /> objects to.</para>
        <para>Unity's rendering loop can be extended by adding so called "command buffers" at various points in light rendering; mostly related to shadows. For example, you could do custom processing of the shadow map after it is rendered.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="T:UnityEngine.Rendering.CameraEvent" />, command buffers overview.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.OpaqueSortMode">
      <summary>
        <para>Opaque object sorting mode of a <see cref="T:UnityEngine.Camera" />.</para>
        <para>Opaque objects are sorted by various criteria (sorting layers, shader queues, materials, distance, lightmaps etc.) to maximize both the CPU efficiency (reduce number of state changes and improve draw call batching), and to maximize GPU efficiency (many GPUs prefer rough front-to-back rendering order for faster rejection of invisible surfaces).By default, opaque objects are grouped in rough front-to-back buckets, on the GPUs where doing that is beneficial. There are GPUs where doing this distance based sorting is not really helpful (most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default.The <see cref="P:UnityEngine.Camera.opaqueSortMode" /> property lets you override this default behavior. For example, you might want to never do distance-based sorting for opaque objects, if you know you need much more CPU performance than GPU performance.See Also: <see cref="P:UnityEngine.Camera.opaqueSortMode" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.PassType">
      <summary>
        <para>Shader pass type for Unity's lighting pipeline.</para>
        <para>This corresponds to "LightMode" tag in the shader pass, see Pass tags.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionCubemapCompression">
      <summary>Determines how Unity will compress baked reflection cubemap.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeClearFlags">
      <summary>Values for ReflectionProbe.clearFlags, determining what to clear when rendering a <see cref="T:UnityEngine.ReflectionProbe" />.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeMode">
      <summary>Reflection probe's update mode.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeRefreshMode">
      <summary>An enum describing the way a realtime reflection probe refreshes in the Player.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode">
      <summary>When a probe's <see cref="P:UnityEngine.ReflectionProbe.refreshMode" /> is set to <see cref="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.EveryFrame" />, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame. Updating a probe's cubemap is a costly operation. Unity needs to render the entire scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeType">
      <summary>Reflection probe type: cube or card.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeUsage">
      <summary>Reflection Probe usage.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderBufferLoadAction">
      <summary>
        <para>Handling of loading RenderBuffer contents on setting as active RenderTarget.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderBufferStoreAction">
      <summary>
        <para>Handling of storing RenderBuffer contents after it was an active RenderTarget and another RenderTarget was set.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ShadowCastingMode">
      <summary>How shadows are cast from this object.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.StencilOp">
      <summary>Specifies the operation that's performed on the stencil buffer when rendering.</summary>
    </member>
    <member name="T:UnityEngine.Scripting.PreserveAttribute">
      <summary>
        <para>PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.</para>
        <para>When you create a build, Unity will try to strip unused code from your project. This is great to get small builds. However, sometimes you want some code to not be stripped, even if it looks like it is not used. This can happen for instance if you use reflection to call a method, or instantiate an object of a certain class. You can apply the [Preserve] attribute to classes, methods, fields and properties. In addition to using PreserveAttribute, you can also use the traditional method of a link.xml file to tell the linker to not remove things. PreserveAttribute only works on IL2CPP platforms. The link.xml file works for Mono and IL2CPP platforms.</para>
        <para>For 3rd party libraries that do not want to take on a dependency on UnityEngine.dll, it is also possible to define their own PreserveAttribute. The code stripper will respect that too, and it will consider any attribute with the exact name "PreserveAtribute" as a reason not to strip the thing it is applied on, regardless of the namespace or assembly of the attribute.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Serialization.FormerlySerializedAsAttribute">
      <summary>
        <para>Use this attribute to rename a field without losing its serialized value.</para>
        <para>Suppose you have a class like this:</para>
        <para>And you would like to create a property to encapsulate myValue without losing any data already assigned to instances of MyClass. You can achieve that by using this attribute:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SocialPlatforms.GameCenter.GameCenterPlatform">
      <summary>
        <para>iOS GameCenter implementation for network services.</para>
        <para>An application bundle ID must be registered on iTunes Connect before it can access GameCenter. This ID must be properly set in the iOS player properties in Unity. When debugging you can use the GameCenter sandbox (a text displaying this is shown when logging on). You must log on in the application to get into sandbox mode, logging on in the GameCenter application will always use the production version.When using the GameCenterPlatform class in C# you need to include the UnityEngine.SocialPlatforms.GameCenter namespace.Some things to be aware of when using the generic API:Authenticate() If the user is not logged in, a standard GameKit UI is shown where he can log on or create a new user. It is recommended this is done as early as possible.Achievement descriptions and Leaderboards The achivements descriptions and leaderboard configurations can be configured in the iTunes Connect portal. Achievements get unique identifiers and the leaderboards use category names as identifiers.GameCenter Sandbox Development applications use the GameCenter Sandbox. This is a seperate GameCenter than the live one, nothing is shared between them. It is recommended that you create a seperate user for testing with the GameCenter Sandbox, you should not use your real Apple ID for this. You can only log on to the sandbox through a development application, make sure you are not logged into GameCenter using the GameCenter app before testing begins. You should see <c>*** Sandbox ***</c> in the login dialog, if you don't see this then you are logging on to the real one. Sometime it happens that the OS forgets that the application is using the sandbox and you will be logged on to the real one. If the application has not be submitted to Apple already then this will probably result in an error. To fix this all that needs to be done is to delete the app and redeploy with Xcode. To make another apple ID a friend of a sandbox user it needs to be a sandbox user as well.If you start getting errors when accessing GameCenter stating that the application is not recognized you'll need to delete the application complately and re-deploy. Make sure you are not logged on when starting the newly installed application again.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SocialPlatforms.Range">
      <summary>The score range a leaderboard query should include.</summary>
    </member>
    <member name="T:UnityEngine.SocialPlatforms.TimeScope">
      <summary>The scope of time searched through when querying the leaderboard.</summary>
    </member>
    <member name="T:UnityEngine.SocialPlatforms.UserScope">
      <summary>The scope of the users searched through when querying the leaderboard.</summary>
    </member>
    <member name="T:UnityEngine.SocialPlatforms.UserState">
      <summary>User presence state.</summary>
    </member>
    <member name="T:UnityEngine.Sprites.DataUtility">
      <summary>Helper utilities for accessing <see cref="T:UnityEngine.Sprite" /> data.</summary>
    </member>
    <member name="T:UnityEngine.Tizen.Window">
      <summary>Interface for Tizen specific functionality.</summary>
    </member>
    <member name="T:UnityEngine.VR.InputTracking">
      <summary>VR Input tracking data.</summary>
    </member>
    <member name="T:UnityEngine.VR.VRDevice">
      <summary>Contains all functionality related to a VR device.</summary>
    </member>
    <member name="T:UnityEngine.VR.VRSettings">
      <summary>Global VR related settings.</summary>
    </member>
    <member name="T:UnityEngine.VR.VRDeviceType">
      <summary>Supported VR devices.</summary>
    </member>
    <member name="T:UnityEngine.VR.VRNode">
      <summary>Enumeration of nodes which can be updated by VR input.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Crypto">
      <summary>Class representing crypotgraphy algorithms.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Directory">
      <summary>
        <para>Exposes static methods for directory operations.</para>
        <para>This is an alternative to System.IO.Directory class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.File">
      <summary>
        <para>Provides static methods for file operations.</para>
        <para>This is an alternative for System.IO.File class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WindowsPhone.Media">
      <summary>Media class represents Windows Phone background media player.</summary>
    </member>
    <member name="T:UnityEngine.WindowsPhone.Media.MediaState">
      <summary>MediaState enumeration specifies all three possible values of media playback state: stopped, playing and paused.</summary>
    </member>
    <member name="T:UnityEngine.WSA.Application">
      <summary>Provides essential methods related to Window Store application.</summary>
    </member>
    <member name="T:UnityEngine.WSA.Cursor">
      <summary>Cursor API for Windows Store Apps.</summary>
    </member>
    <member name="T:UnityEngine.WSA.Launcher">
      <summary>Class which is capable of launching user's default app for file type or a protocol.</summary>
    </member>
    <member name="T:UnityEngine.WSA.SecondaryTileData">
      <summary>
        <para>Defines the default look of secondary tile.</para>
        <para>Some values are also used when a notification is sent to the same tile.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Tile">
      <summary>
        <para>Represents tile on Windows start screen</para>
        <para>This class can be used to create or update secondary tiles on start screen and get instances of tiles to send notifications to them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Toast">
      <summary>
        <para>Represents a toast notification in Windows Store Apps.</para>
        <para>Application must be declared "Toast capable" in manifest for toast notifications to work.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Folder">
      <summary>List of accessible folders on Windows Store Apps.</summary>
    </member>
    <member name="T:UnityEngine.WSA.TileForegroundText">
      <summary>Style for foreground text on a secondary tile.</summary>
    </member>
    <member name="T:UnityEngine.WSA.TileTemplate">
      <summary>
        <para>Templates for various tile styles.</para>
        <para>Each template represents an XML document for updating tile. Note that availability of templates depends on version of Microsoft Windows. For more detailed information, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh761491.aspx</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.ToastTemplate">
      <summary>
        <para>Templates for various toast styles.</para>
        <para>Each template represents an XML document for presenting toast notification. For more detailed information, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh761494.aspx</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.WindowActivationState">
      <summary>Specifies the set of reasons that a windowActivated event was raised.</summary>
    </member>
    <member name="T:UnityEngine.AccelerationEvent">
      <summary>Structure describing acceleration status of the device.</summary>
    </member>
    <member name="T:UnityEngine.AnchoredJoint2D">
      <summary>Parent class for all joints that have anchor points.</summary>
    </member>
    <member name="T:UnityEngine.AndroidInput">
      <summary>AndroidInput provides support for off-screen touch input, such as a touchpad.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaClass">
      <summary>AndroidJavaClass is the Unity representation of a generic instance of java.lang.Class.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaObject">
      <summary>
        <para>AndroidJavaObject is the Unity representation of a generic instance of java.lang.Object.</para>
        <para>It can be used as type-less interface to an instance of any Java class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaProxy">
      <summary>This class can be used to implement any java interface. Any java vm method invocation matching the interface on the proxy object will automatically be passed to the c# implementation.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJNI">
      <summary>'Raw' JNI interface to Android Dalvik (Java) VM from Mono (CS/JS).</summary>
    </member>
    <member name="T:UnityEngine.AndroidJNIHelper">
      <summary>Helper interface for JNI interaction; signature creation and method lookups.</summary>
    </member>
    <member name="T:UnityEngine.Animation">
      <summary>
        <para>The animation component is used to play back animations.</para>
        <para>You can assign animation clips to the animation component and control playback from your script. The animation system in Unity is weight-based and supports Animation Blending, Additive animations, Animation Mixing, Layers and full control over all aspects of playback.For an overview of animation scripting in Unity please read this introduction.<see cref="T:UnityEngine.AnimationState" /> can be used to change the layer of an animation, modify playback speed, and for direct control over blending and mixing.Animation also supports enumerators so you can loop through all AnimationStates like this:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationClip">
      <summary>
        <para>Stores keyframe based animations.</para>
        <para>AnimationClip is used by <see cref="T:UnityEngine.Animation" /> to play back animations.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationClipPair">
      <summary>
        <para>This class defines a pair of clips used by <see cref="T:UnityEngine.AnimatorOverrideController" />.</para>
        <para>Each original clip from the controller can be overriden with another clip.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationCurve">
      <summary>A collection of curves form an <see cref="T:UnityEngine.AnimationClip" />.</summary>
    </member>
    <member name="T:UnityEngine.AnimationEvent">
      <summary>
        <para>AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.</para>
        <para>Animation events support functions that take zero or one parameter. The parameter can be a float, an int, a string, an object reference, or an AnimationEvent.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationInfo">
      <summary>Information about what animation clips is played and its weight.</summary>
    </member>
    <member name="T:UnityEngine.AnimationState">
      <summary>
        <para>The AnimationState gives full control over animation blending.</para>
        <para>In most cases the <see cref="T:UnityEngine.Animation" /> interface is sufficient and easier to use. Use the AnimationState if you need full control over the animation blending any playback process.The AnimationState interface allows you to modify speed, weight, time and layers while any animation is playing. You can also setup animation mixing and wrapMode.The Animation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animator">
      <summary>Interface to control the Mecanim animation system.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorClipInfo">
      <summary>Information about clip been played and blended by the Animator.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorControllerParameter">
      <summary>Used to communicate between scripting and the controller. Some parameters can be set in scripting and used by the controller, while other parameters are based on Custom Curves in Animation Clips and can be sampled using the scripting API.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorOverrideController">
      <summary>
        <para>Interface to control AnimatorOverrideController.</para>
        <para>AnimatorOverrideController is used to override clips from a controller to specialize some animations for a given avatar. Swapping <see cref="P:UnityEngine.Animator.runtimeAnimatorController" /> with an <see cref="T:UnityEngine.AnimatorOverrideController" /> based on the same <see cref="T:UnityEditor.Animations.AnimatorController" /> at runtime doesn't reset state machine's current state.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorStateInfo">
      <summary>Information about the current or next state.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorTransitionInfo">
      <summary>Information about the current transition.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorUtility">
      <summary>Various utilities for animator manipulation.</summary>
    </member>
    <member name="T:UnityEngine.Application">
      <summary>
        <para>Access to application run-time data.</para>
        <para>This class contains static methods for looking up information about and controlling the run-time data.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AreaEffector2D">
      <summary>
        <para>Applies forces within an area.</para>
        <para>When the source <see cref="T:UnityEngine.Collider2D" /> is a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> overlaps the source. When the source <see cref="T:UnityEngine.Collider" /> isn't a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> is in contact with the source only.This effector is designed primarily to work with source <see cref="T:UnityEngine.Collider2D" /> that are set as triggers so that target <see cref="T:UnityEngine.Collider2D" /> can overlap the defined area.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssetBundle">
      <summary>
        <para>AssetBundles let you stream additional assets via the WWW class and instantiate them at runtime. AssetBundles are created via BuildPipeline.BuildAssetBundle.</para>
        <para>Note that bundles are not fully compatible between platforms. A bundle built for any of the standalone platforms (including webplayer) can be loaded on any of those platforms but not on iOS or Android. Furthermore, a bundle built for iOS is not compatible with Android and vice versa.See Also: <see cref="P:UnityEngine.WWW.assetBundle" />, Loading Resources at Runtime, BuildPipeline.BuildAssetBundle.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssetBundleCreateRequest">
      <summary>Asynchronous create request for an <see cref="T:UnityEngine.AssetBundle" />.</summary>
    </member>
    <member name="T:UnityEngine.AssetBundleManifest">
      <summary>Manifest for all the assetBundle in the build.</summary>
    </member>
    <member name="T:UnityEngine.AssetBundleRequest">
      <summary>Asynchronous load request from an <see cref="T:UnityEngine.AssetBundle" />.</summary>
    </member>
    <member name="T:UnityEngine.AsyncOperation">
      <summary>Asynchronous operation coroutine.</summary>
    </member>
    <member name="T:UnityEngine.AudioChorusFilter">
      <summary>
        <para>The Audio Chorus Filter takes an Audio Clip and processes it creating a chorus effect.</para>
        <para>The chorus effect modulates the original sound by a sinusoid low frequency oscillator (LFO). The output sounds like there are multiple sources emitting the same sound with slight variations - resembling a choir.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioClip">
      <summary>
        <para>A container for audio data.</para>
        <para>An AudioClip stores the audio file either compressed as ogg vorbis or uncompressed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioConfiguration">
      <summary>
        <para>Specifies the current properties or desired properties to be set for the audio system.</para>
        <para>See <see cref="M:UnityEngine.AudioSettings.Reset(UnityEngine.AudioConfiguration)" /> for an example.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioDistortionFilter">
      <summary>
        <para>The Audio Distortion Filter distorts the sound from an AudioSource or.</para>
        <para>Sounds reaching the AudioListener.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioEchoFilter">
      <summary>
        <para>The Audio Echo Filter repeats a sound after a given Delay, attenuating.</para>
        <para>The repetitions based on the Decay Ratio.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioHighPassFilter">
      <summary>
        <para>The Audio High Pass Filter passes high frequencies of an AudioSource and.</para>
        <para>Attenuates signals with frequencies lower than the Cutoff Frequency.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioListener">
      <summary>
        <para>Representation of a listener in 3D space.</para>
        <para>This class implements a microphone-like device. It records the sounds around it and plays that through the player's speakers.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioLowPassFilter">
      <summary>
        <para>The Audio Low Pass Filter filter passes low frequencies of an.</para>
        <para>AudioSource, or all sound reaching an AudioListener, and attenuates frequencies higher than the Cutoff Frequency.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioReverbFilter">
      <summary>
        <para>The Audio Reverb Filter takes an Audio Clip and distortionates it in a.</para>
        <para>Way to create a personalized reverb effect.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioReverbZone">
      <summary>
        <para>Reverb Zones are used when you want to create location based ambient effects in the scene.</para>
        <para>As the Audio Listener moves into a Reverb Zone, the ambient effect associated with the zone is gradually applied. At the max distance there is no effect and at the min distance the effect is fully applied. For example you can gradually change your character's footsteps sounds and create the feeling like you where entering into a cavern, going trough a room, swimming underwater, etc.You can always mix reverb zones to have combined effects. For more info check Reverb Zones in the manual.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioSettings">
      <summary>
        <para>Controls the global audio settings from script.</para>
        <para>Setup speaker output and format.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioSource">
      <summary>
        <para>A representation of audio sources in 3D.</para>
        <para>An AudioSource is attached to a <see cref="T:UnityEngine.GameObject" /> for playing back sounds in a 3D environment. In order to play 3D sounds you also need to have a <see cref="T:UnityEngine.AudioListener" />. The audio listener is normally attached to the camera you want to use. Whether sounds are played in 3D or 2D is determined by <see cref="T:UnityEditor.AudioImporter" /> settings.You can play a single audio clip using <see cref="M:UnityEngine.AudioSource.Play(System.UInt64)" />, <see cref="M:UnityEngine.AudioSource.Pause" /> and <see cref="M:UnityEngine.AudioSource.Stop" />. You can also adjust its volume while playing using the <see cref="P:UnityEngine.AudioSource.volume" /> property, or seek using <see cref="P:UnityEngine.AudioSource.time" />. Multiple sounds can be played on one AudioSource using <see cref="M:UnityEngine.AudioSource.PlayOneShot(UnityEngine.AudioClip,System.Single)" />. You can play a clip at a static position in 3D space using <see cref="M:UnityEngine.AudioSource.PlayClipAtPoint(UnityEngine.AudioClip,UnityEngine.Vector3,System.Single)" />.See Also: <see cref="T:UnityEngine.AudioListener" />, <see cref="T:UnityEngine.AudioClip" />, AudioSource component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Avatar">
      <summary>Avatar definition.</summary>
    </member>
    <member name="T:UnityEngine.AvatarBuilder">
      <summary>
        <para>Class to build avatars from user scripts.</para>
        <para>The Unity editor has tools for setting up and editing avatars but this class can be useful for creating custom editors and inspectors for your characters.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Behaviour">
      <summary>Behaviours are Components that can be enabled or disabled.</summary>
    </member>
    <member name="T:UnityEngine.BillboardAsset">
      <summary>BillboardAsset describes how a billboard is rendered.</summary>
    </member>
    <member name="T:UnityEngine.BillboardRenderer">
      <summary>Renders a billboard.</summary>
    </member>
    <member name="T:UnityEngine.BitStream">
      <summary>
        <para>The BitStream class represents seralized variables, packed into a stream.</para>
        <para>Data can be serialized, transmitted, and then received by remote clients by using this class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoneWeight">
      <summary>
        <para>Skinning bone weights of a vertex in the mesh.</para>
        <para>Each vertex is skinned with up to four bones. All weights should sum up to one. Weights and bone indices should be defined in the order of decreasing weight. If a vertex is affected by less than four bones, the remaining weights should be zeroes.See Also: Mesh.boneWeights variable.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoundingSphere">
      <summary>Describes a single bounding sphere for use by a <see cref="T:UnityEngine.CullingGroup" />.</summary>
    </member>
    <member name="T:UnityEngine.Bounds">
      <summary>
        <para>Represents an axis aligned bounding box.</para>
        <para>An axis-aligned bounding box, or AABB for short, is a box aligned with coordinate axes and fully enclosing some object. Because the box is never rotated with respect to the axes, it can be defined by just its <see cref="P:UnityEngine.Bounds.center" /> and <see cref="P:UnityEngine.Bounds.extents" />, or alternatively by <see cref="P:UnityEngine.Bounds.min" /> and <see cref="P:UnityEngine.Bounds.max" /> points.<c>Bounds</c> is used by <see cref="P:UnityEngine.Collider.bounds" />, <see cref="P:UnityEngine.Mesh.bounds" /> and <see cref="P:UnityEngine.Renderer.bounds" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoxCollider">
      <summary>A box-shaped primitive collider.</summary>
    </member>
    <member name="T:UnityEngine.BoxCollider2D">
      <summary>Collider for 2D physics representing an axis-aligned rectangle.</summary>
    </member>
    <member name="T:UnityEngine.Caching">
      <summary>The Caching class lets you manage cached AssetBundles, downloaded using <see cref="M:UnityEngine.WWW.LoadFromCacheOrDownload(System.String,System.Int32,System.UInt32)" />.</summary>
    </member>
    <member name="T:UnityEngine.Camera">
      <summary>
        <para>A Camera is a device through which the player views the world.</para>
        <para>A screen space point is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />). The z position is in world units from the camera.A viewport space point is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.A world space point is defined in global coordinates (eg. Transform.position).See Also: camera component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Canvas">
      <summary>
        <para>Element that can be used for screen rendering.</para>
        <para>Elements on a canvas are rendered AFTER scene rendering, either from an attached camera or using overlay mode.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CanvasGroup">
      <summary>
        <para>A <see cref="T:UnityEngine.Canvas" /> placable element that can be used to modify children Alpha, Raycasting, Enabled state.</para>
        <para>A canvas group can be used to modify the state of children elements. An example of this would be a window which fades in over time, by modifying the alpha value of the group the children elements well be affected. The result alpha will be the multiplied result of any nested groups, multiplied with the canvas elements alpha.Canvas Groups can also be configured to not block raycasts (anything on the group will not be considerered for graphic raycasting), and whether elements are interactable.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CanvasRenderer">
      <summary>A component that will render to the screen after all normal rendering has completed when attached to a <see cref="T:UnityEngine.Canvas" />. Designed for GUI application.</summary>
    </member>
    <member name="T:UnityEngine.CapsuleCollider">
      <summary>
        <para>A capsule-shaped primitive collider.</para>
        <para>Capsules are cylinders with a half-sphere at each end.See Also: <see cref="T:UnityEngine.BoxCollider" />, <see cref="T:UnityEngine.SphereCollider" />, <see cref="T:UnityEngine.PhysicMaterial" />, <see cref="T:UnityEngine.Rigidbody" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CharacterController">
      <summary>
        <para>A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.</para>
        <para>A CharacterController is not affected by forces and will only move when you call the Move funtion. It will then carry out the movement but be constrained by collisions.See Also: Character Controller component and <see href="animation" cref="Character animation examples" /></para>
      </summary>
    </member>
    <member name="T:UnityEngine.CharacterInfo">
      <summary>Specification for how to render a character from the font texture. See <see cref="P:UnityEngine.Font.characterInfo" />.</summary>
    </member>
    <member name="T:UnityEngine.CharacterJoint">
      <summary>
        <para>Character Joints are mainly used for Ragdoll effects.</para>
        <para>They are an extended ball-socket joint which allows you to limit the joint on each axis.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CircleCollider2D">
      <summary>Collider for 2D physics representing an circle.</summary>
    </member>
    <member name="T:UnityEngine.Cloth">
      <summary>The Cloth class provides an interface to cloth simulation physics.</summary>
    </member>
    <member name="T:UnityEngine.ClothSkinningCoefficient">
      <summary>
        <para>The ClothSkinningCoefficient struct is used to set up how a <see cref="T:UnityEngine.Cloth" /> component is allowed to move with respect to the <see cref="T:UnityEngine.SkinnedMeshRenderer" /> it is attached to.</para>
        <para>This is set using the <see cref="P:UnityEngine.Cloth.coefficients" /> property on the Cloth component, which is a per-vertex array of ClothSkinningCoefficient structs. Typically, you will not set these values from code, but instead, set them up in the editor which shows up when you look at the Cloth component in the inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ClothSphereColliderPair">
      <summary>
        <para>A pair of SphereColliders used to define shapes for Cloth objects to collide against.</para>
        <para>A ClothSphereColliderPair can contain either a single valid SphereCollider instance (with the second one being null), or a pair of two SphereColliders. In the former cases the ClothSphereColliderPair just represents a single SphereCollider for the cloth to collide against. In the latter case, it represents a conic capsule shape defined by the two spheres, and the cone connecting the two. Conic capsule shapes are useful for modelling limbs of a character.Select the cloth object to see a visualization of Cloth colliders shapes in the scene view.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Collider">
      <summary>
        <para>A base class of all colliders.</para>
        <para>The Rigidbody can be set to be kinematic if you don't want the object to have physical interaction with other objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Collider2D">
      <summary>Parent class for collider types used with 2D gameplay.</summary>
    </member>
    <member name="T:UnityEngine.Collision">
      <summary>
        <para>Describes a collision.</para>
        <para>Collision information is passed to Collider.OnCollisionEnter, Collider.OnCollisionStay and Collider.OnCollisionExit events.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Collision2D">
      <summary>Information returned by a collision in 2D physics.</summary>
    </member>
    <member name="T:UnityEngine.Color">
      <summary>
        <para>Representation of RGBA colors.</para>
        <para>This structure is used throughout Unity to pass colors around. Each color component is a floating point value with a range from 0 to 1.Components (<see cref="F:UnityEngine.Color.r" />,<see cref="F:UnityEngine.Color.g" />,<see cref="F:UnityEngine.Color.b" />) define a color in RGB color space. Alpha component (<see cref="F:UnityEngine.Color.a" />) defines transparency - alpha of one is completely opaque, alpha of zero is completely transparent.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Color32">
      <summary>
        <para>Representation of RGBA colors in 32 bit format.</para>
        <para>Each color component is a byte value with a range from 0 to 255.Components (<see cref="F:UnityEngine.Color32.r" />,<see cref="F:UnityEngine.Color32.g" />,<see cref="F:UnityEngine.Color32.b" />) define a color in RGB color space. Alpha component (<see cref="F:UnityEngine.Color32.a" />) defines transparency - alpha of 255 is completely opaque, alpha of zero is completely transparent.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ColorUtility">
      <summary>A collection of common color functions.</summary>
    </member>
    <member name="T:UnityEngine.CombineInstance">
      <summary>Struct used to describe meshes to be combined using Mesh.CombineMeshes.</summary>
    </member>
    <member name="T:UnityEngine.Compass">
      <summary>Interface into compass functionality.</summary>
    </member>
    <member name="T:UnityEngine.Component">
      <summary>
        <para>Base class for everything attached to <see cref="T:UnityEngine.GameObject" />s.</para>
        <para>Note that your code will never directly create a Component. Instead, you write script code, and attach the script to a <see cref="T:UnityEngine.GameObject" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ComputeBuffer">
      <summary>
        <para>Data buffer to hold data for compute shaders.</para>
        <para>
          <see cref="T:UnityEngine.ComputeShader" /> programs often need arbitrary data to be read &amp; written into memory buffers. ComputeBuffer class is exactly for that - you can create &amp; fill them from script code, and use them in compute shaders or regular shaders.Compute shaders need a fairly modern GPU (with shader model 5.0 support) and are at the moment available on DirectX 11, PS4, XboxOne and OpenGL ES 3.1. On shader side, ComputeBuffers map to StructuredBuffer&lt;T&gt; and RWStructuredBuffer&lt;T&gt; in HLSL.See Also: <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />, <see cref="T:UnityEngine.ComputeShader" /> class, <see cref="M:UnityEngine.Shader.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)" />, <see cref="M:UnityEngine.Material.SetBuffer(System.String,UnityEngine.ComputeBuffer)" />, Compute Shaders.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ComputeShader">
      <summary>
        <para>Compute Shader asset.</para>
        <para>Compute shaders are programs that run on the GPU outside of the normal rendering pipeline. They correspond to compute shader assets in the project (.compute files).Compute shaders need a fairly modern GPU (with shader model 5.0 support) and are at the moment available on DirectX 11, PS4, XboxOne and OpenGL ES 3.1.See Also: <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />, <see cref="T:UnityEngine.ComputeBuffer" /> class, Compute Shaders.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConfigurableJoint">
      <summary>
        <para>The configurable joint is an extremely flexible joint giving you complete control over rotation and linear motion.</para>
        <para>You can build all other joints with it and much more but it is also more complicated to setup. It gives you control over motors, drives and joint limits for each rotation axis and and linear degree of freedom.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConstantForce">
      <summary>
        <para>A force applied constantly.</para>
        <para>This is a small physics utility class used to apply a continous force to an object.<see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" /> applies a force to the <see cref="T:UnityEngine.Rigidbody" /> only for one frame, thus you have to keep calling the function. ConstantForce on the other hand will apply the force every frame until you change the force or torque to a new value.See Also: <see cref="T:UnityEngine.Rigidbody" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConstantForce2D">
      <summary>
        <para>Applies both linear and angular (torque) forces continuously to the rigidbody each physics update.</para>
        <para>This is equivalent of calling <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddRelativeForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" /> and <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" /> each physics update.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContactPoint">
      <summary>
        <para>Describes a contact point where the collision occurs.</para>
        <para>Contact points are stored in <see cref="T:UnityEngine.Collision" /> structure.See Also: <see cref="T:UnityEngine.Collision" />, <c>Collider.OnCollisionEnter</c>, <c>Collider.OnCollisionStay</c>, <c>Collider.OnCollisionExit</c>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContactPoint2D">
      <summary>Details about a specific point of contact involved in a 2D physics collision.</summary>
    </member>
    <member name="T:UnityEngine.ControllerColliderHit">
      <summary>ControllerColliderHit is used by CharacterController.OnControllerColliderHit to give detailed information about the collision and how to deal with it.</summary>
    </member>
    <member name="T:UnityEngine.Coroutine">
      <summary>
        <para>MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines and do not hold any exposed properties or functions.</para>
        <para>A coroutine is a function that can suspend its execution (yield) until the given given <see cref="T:UnityEngine.YieldInstruction" /> finishes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CrashReport">
      <summary>
        <para>Holds data for a single application crash event and provides access to all gathered crash reports.</para>
        <para>If compiled with appropriate settings, Unity will try to gather useful information, like location and thread stack traces, when your application crashes. Upon the next application start, if the data gathering was successful, all crash information will be accessible using this API.To enable crash report generation, in iOS player settings set "Script Call Optimization" option to "Fast but no Exceptions". After you build your Xcode project in Unity, open it and edit trampoline file: Classes/CrashReporter.h. Change ENABLE_CUSTOM_CRASH_REPORTER define from 0 to 1.Note: this API currently is available only for iOS targets.See Also: <see cref="P:UnityEngine.CrashReport.reports" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Cubemap">
      <summary>Class for handling cube maps, Use this to create or modify existing cube map assets.</summary>
    </member>
    <member name="T:UnityEngine.CullingGroup">
      <summary>Describes a set of bounding spheres that should have their visibility and distances maintained.</summary>
    </member>
    <member name="T:UnityEngine.CullingGroupEvent">
      <summary>Provides information about the current and previous states of one sphere in a CullingGroup.</summary>
    </member>
    <member name="T:UnityEngine.Cursor">
      <summary>
        <para>Cursor API for setting the cursor that is used for rendering.</para>
        <para>Supports Hardware Cursors on OSX, Windows and Linux falls back to software cursors on unsupported platforms.Textures used as cursors should be marked as such in their import settings. OSX Webplayer note: Due to sandboxing, Hardware Cursors can only be updated intermittently (when the cursor is moving) the best way to ensure correct behavior if to use OnMouseEnter and OnMouseExit to set the hardware cursors. This is not an issue for software cursors.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Debug">
      <summary>Class containing methods to ease debugging while developing a game.</summary>
    </member>
    <member name="T:UnityEngine.DetailPrototype">
      <summary>
        <para>Detail prototype used by the Terrain GameObject.</para>
        <para>This can be grass, or a flower..</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Display">
      <summary>
        <para>Provides access to a display / screen for rendering operations.</para>
        <para>This feature is available for iPhone.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DistanceJoint2D">
      <summary>
        <para>Joint that keeps two Rigidbody2D objects a fixed distance apart.</para>
        <para>Note that unlike the SpringJoint2D component, the distance separating the objects is truly fixed and does not allow for any stretching.See Also: <see cref="T:UnityEngine.HingeJoint2D" /> class, <see cref="T:UnityEngine.SliderJoint2D" /> class, <see cref="T:UnityEngine.SpringJoint2D" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DrivenRectTransformTracker">
      <summary>
        <para>A component can be designed drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.</para>
        <para>Driving a RectTransform means that the values of the driven RectTransform are controlled by that component. These driven values cannot be edited in the Inspector (they are shown as disabled). They also won't be saved when saving a scene, which prevents undesired scene file changes.Whenever the component is changing values of driven RectTransforms, it should first call the Clear method and then use the Add method to add all RectTransforms it is driving. The Clear method should also be called in the OnDisable callback of the component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DynamicGI">
      <summary>Allows to control the dynamic Global Illumination.</summary>
    </member>
    <member name="T:UnityEngine.EdgeCollider2D">
      <summary>Collider for 2D physics representing an arbitrary set of connected edges (lines) defined by its vertices.</summary>
    </member>
    <member name="T:UnityEngine.Effector2D">
      <summary>A base class for all 2D effectors.</summary>
    </member>
    <member name="T:UnityEngine.EllipsoidParticleEmitter">
      <summary>Class used to allow <see cref="M:UnityEngine.GameObject.AddComponent(System.String)" /> / <see cref="M:UnityEngine.GameObject.GetComponent(System.Type)" /> to be used.</summary>
    </member>
    <member name="T:UnityEngine.Event">
      <summary>
        <para>A UnityGUI event.</para>
        <para>Events correspond to user input (key presses, mouse actions), or are UnityGUI layout or rendering events.For each event <c>OnGUI</c> is called in the scripts; so OnGUI is potentially called multiple times per frame. Event.current corresponds to "current" event inside OnGUI call.See Also: GUI Scripting Guide, <see cref="T:UnityEngine.EventType" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FixedJoint">
      <summary>The Fixed joint groups together 2 rigidbodies, making them stick together in their bound position.</summary>
    </member>
    <member name="T:UnityEngine.Flare">
      <summary>
        <para>A flare asset. Read more about flares in the components reference.</para>
        <para>The flare class has no properties. It needs to be setup up in the inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FlareLayer">
      <summary>
        <para>FlareLayer component.</para>
        <para>The FlareLayer is a lensflare component to be used on cameras. It has no properties.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Font">
      <summary>
        <para>Script interface for font assets.</para>
        <para>You can use this class to dynamically switch fonts on GUI texts or Text Meshes.See Also: <see cref="T:UnityEngine.GUIText" /> and <see cref="T:UnityEngine.TextMesh" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GameObject">
      <summary>Base class for all entities in Unity scenes.</summary>
    </member>
    <member name="T:UnityEngine.GeometryUtility">
      <summary>Utility class for common geometric functions.</summary>
    </member>
    <member name="T:UnityEngine.Gizmos">
      <summary>
        <para>Gizmos are used to give visual debugging or setup aids in the scene view.</para>
        <para>All gizmo drawing has to be done in either <see href="MonoBehaviour.OnDrawGizmos" cref="OnDrawGizmos" /> or <see href="MonoBehaviour.OnDrawGizmosSelected" cref="OnDrawGizmosSelected" /> functions of the script.<see href="MonoBehaviour.OnDrawGizmos" cref="OnDrawGizmos" /> is called every frame. All gizmos rendered within <see href="MonoBehaviour.OnDrawGizmos" cref="OnDrawGizmos" /> are pickable. <see href="MonoBehaviour.OnDrawGizmosSelected" cref="OnDrawGizmosSelected" /> is called only if the object the script is attached to is selected.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GL">
      <summary>
        <para>Low-level graphics library.</para>
        <para>Use this class to manipulate active transformation matrices, issue rendering commands similar to OpenGL's immediate mode and do other low-level graphics tasks. Note that in almost all cases using <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> or <see cref="T:UnityEngine.Rendering.CommandBuffer" /> is more efficient than using immediate mode drawing.GL immediate drawing functions use whatever is the "current material" set up right now (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" />). The material controls how the rendering is done (blending, textures, etc.), so unless you explicitly set it to something before using GL draw functions, the material can happen to be anything. Also, if you call any other drawing commands from inside GL drawing code, they can set material to something else, so make sure it's under control as well.GL drawing commands execute immediately. That means if you call them in Update(), they will be executed before the camera is rendered (and the camera will most likely clear the screen, making the GL drawing not visible).The usual place to call GL drawing is most often in <c>OnPostRender</c>() from a script attached to a camera, or inside an image effect function (<c>OnRenderImage</c>).</para>
        <para>Note: This class is almost always used when you need to draw a couple of lines or triangles, and don't want to deal with meshes. If you want to avoid surprises the usage pattern is this:</para>
        <para>Where at the "// Draw your stuff" you should do SetPass() on some material previously declared, which will be used for drawing. If you dont call SetPass, then you'll get basically a random material (whatever was used before) which is not good. So do it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Gradient">
      <summary>
        <para>Gradient used for animating colors.</para>
        <para>Note that the alpha and colors keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys and 2 alpha keys.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GradientAlphaKey">
      <summary>Alpha key used by Gradient.</summary>
    </member>
    <member name="T:UnityEngine.GradientColorKey">
      <summary>Color key used by Gradient.</summary>
    </member>
    <member name="T:UnityEngine.Graphics">
      <summary>
        <para>Raw interface to Unity's drawing functions.</para>
        <para>This is the high-level shortcut into the optimized mesh drawing functionality of Unity.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUI">
      <summary>The GUI class is the interface for Unity's GUI with manual positioning.</summary>
    </member>
    <member name="T:UnityEngine.GUI.GroupScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect)" /> / <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>
          <see cref="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect)" /> is called at construction, and <see cref="M:UnityEngine.GUI.EndGroup" /> is called when the instance is disposed. When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUI.ScrollViewScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" /> / <see cref="M:UnityEngine.GUI.EndScrollView" />.</para>
        <para>
          <see cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" /> is called at construction, and <see cref="M:UnityEngine.GUI.EndScrollView" /> is called when the instance is disposed. ScrollViews let you make a smaller area on-screen look 'into' a much larger area, using scrollbars placed on the sides of the ScrollView.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUIContent">
      <summary>
        <para>The contents of a GUI element.</para>
        <para>This works closely in relation with <see cref="T:UnityEngine.GUIStyle" />. GUIContent defines <c>what</c> to render and <see cref="T:UnityEngine.GUIStyle" /> defines <c>how</c> to render it.See Also: <see cref="T:UnityEngine.GUIStyle" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUIElement">
      <summary>
        <para>Base class for images &amp; text strings displayed in a GUI.</para>
        <para>This class holds the base functionality for any GUI elements.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUILayer">
      <summary>
        <see cref="T:UnityEngine.Component" /> added to a camera to make it render 2D GUI elements.</summary>
    </member>
    <member name="T:UnityEngine.GUILayout">
      <summary>The GUILayout class is the interface for Unity gui with automatic layout.</summary>
    </member>
    <member name="T:UnityEngine.GUILayout.AreaScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" /> / <see cref="M:UnityEngine.GUILayout.EndArea" />.</para>
        <para>
          <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" /> is called at construction, and <see cref="M:UnityEngine.GUILayout.EndArea" /> is called when the instance is disposed. By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUILayout.HorizontalScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" /> / <see cref="M:UnityEngine.GUILayout.EndHorizontal" />.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUILayout.ScrollViewScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])" /> / <see cref="M:UnityEngine.GUILayout.EndScrollView" />.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUILayout.VerticalScope">
      <summary>
        <para>Disposable helper class for managing <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" /> / <see cref="M:UnityEngine.GUILayout.EndVertical" />.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUILayoutOption">
      <summary>Class internally used to pass layout options into <see cref="T:UnityEngine.GUILayout" /> functions. You don't use these directly, but construct them with the layouting functions in the <see cref="T:UnityEngine.GUILayout" /> class.</summary>
    </member>
    <member name="T:UnityEngine.GUILayoutUtility">
      <summary>
        <para>Utility functions for implementing and extending the GUILayout class.</para>
        <para>Use this class to make your own GUI layouting code.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUISettings">
      <summary>
        <para>General settings for how the GUI behaves.</para>
        <para>These are shared by all elements in a <see cref="T:UnityEngine.GUISkin" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUISkin">
      <summary>
        <para>Defines how GUI looks and behaves.</para>
        <para>GUISkin contains GUI settings and a collection of <see cref="T:UnityEngine.GUIStyle" /> objects that together specify GUI skin.Active GUI skin is get and set through <see cref="P:UnityEngine.GUI.skin" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUIStyle">
      <summary>
        <para>Styling information for GUI elements.</para>
        <para>Most GUI functions accept an optional GUIStyle parameter to override the default style. This allows coloring, fonts and other details to be changed and switched for different states (eg, when the mouse is hovering over the control). Where a consistent look-and-feel is required over a whole GUI design, the GUISkin class is a useful way to collect a set of GUIStyle settings and apply them all at once.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUIStyleState">
      <summary>
        <para>Specialized values for the given states used by <see cref="T:UnityEngine.GUIStyle" /> objects.</para>
        <para>The GUIStyle contains all values for displaying GUI elements.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUIText">
      <summary>A text string displayed in a GUI.</summary>
    </member>
    <member name="T:UnityEngine.GUITexture">
      <summary>A texture image used in a 2D GUI.</summary>
    </member>
    <member name="T:UnityEngine.GUIUtility">
      <summary>
        <para>Utility class for making new GUI controls.</para>
        <para>Unless you are creating your own GUI controls from scratch, you should not use these functions.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Gyroscope">
      <summary>
        <para>Interface into the Gyroscope.</para>
        <para>Use this class to access gyroscope.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Handheld">
      <summary>Interface into functionality unique to handheld devices.</summary>
    </member>
    <member name="T:UnityEngine.Hash128">
      <summary>Represent the hash value.</summary>
    </member>
    <member name="T:UnityEngine.HingeJoint">
      <summary>
        <para>The HingeJoint groups together 2 rigid bodies, constraining them to move like connected by a hinge.</para>
        <para>This joint is great for, well, doors, but can also be used to model chains, etc...The HingeJoint has a motor which can be used to make the hinge spin around the joints axis. A spring which attempts to reach for a target angle by spinning around the joints axis. And a limit which constrains the joint angle.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HingeJoint2D">
      <summary>Joint that allows a Rigidbody2D object to rotate around a point in space or a point on another object.</summary>
    </member>
    <member name="T:UnityEngine.HostData">
      <summary>
        <para>This is the data structure for holding individual host information.</para>
        <para>The host list retreived from a master server uses this class to represent individual hosts.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanBone">
      <summary>
        <para>The mapping between a bone in the model and the conceptual bone in the Mecanim human anatomy.</para>
        <para>The names of the Mecanim human bone and the bone in the model are stored along with the limiting muscle values that constrain the bone's rotation during animation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanDescription">
      <summary>Class that holds humanoid avatar parameters to pass to the <see cref="M:UnityEngine.AvatarBuilder.BuildHumanAvatar(UnityEngine.GameObject,UnityEngine.HumanDescription)" /> function.</summary>
    </member>
    <member name="T:UnityEngine.HumanLimit">
      <summary>This class stores the rotation limits that define the <c>muscle</c> for a single human bone.</summary>
    </member>
    <member name="T:UnityEngine.HumanTrait">
      <summary>Details of all the human bone and muscle types defined by Mecanim.</summary>
    </member>
    <member name="T:UnityEngine.Input">
      <summary>
        <para>Interface into the Input system.</para>
        <para>Use this class to read the axes set up in the Input Manager, and to access multi-touch/accelerometer data on mobile devices.To read an axis use Input.GetAxis with one of the following default axes: "Horizontal" and "Vertical" are mapped to joystick, <c>A</c>, <c>W</c>, <c>S</c>, <c>D</c> and the arrow keys. "Mouse X" and "Mouse Y" are mapped to the mouse delta. "Fire1", "Fire2" "Fire3" are mapped to <c>Ctrl</c>, <c>Alt</c>, <c>Cmd</c> keys and three mouse or joystick buttons. New input axes can be added in the Input Manager.If you are using input for any kind of movement behaviour use Input.GetAxis. It gives you smoothed and configurable input that can be mapped to keyboard, joystick or mouse. Use Input.GetButton for action like events only. Don't use it for movement, Input.GetAxis will make the script code smaller and simpler.Note also that the Input flags are not reset until "Update()", so its suggested you make all the Input Calls in the Update Loop.Mobile Devices:iOS and Android devices are capable of tracking multiple fingers touching the screen simultaneously. You can access data on the status of each finger touching screen during the last frame by accessing the Input.touches property array.As a device moves, its accelerometer hardware reports linear acceleration changes along the three primary axes in three-dimensional space. You can use this data to detect both the current orientation of the device (relative to the ground) and any immediate changes to that orientation.Acceleration along each axis is reported directly by the hardware as G-force values. A value of 1.0 represents a load of about +1g along a given axis while a value of -1.0 represents -1g. If you hold the device upright (with the home button at the bottom) in front of you, the X axis is positive along the right, the Y axis is positive directly up, and the Z axis is positive pointing toward you.You can read the Input.acceleration property to get the accelerometer reading. You can also use the Input.deviceOrientation property to get a discrete evaluation of the device's orientation in three-dimensional space. Detecting a change in orientation can be useful if you want to create game behaviors when the user rotates the device to hold it differently.Note that the accelerometer hardware can be polled more than once per frame. To access all accelerometer samples since the last frame, you can read the Input.accelerationEvents property array. This can be useful when reconstructing player motions, feeding acceleration data into a predictor, or implementing other precise motion analysis.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Joint">
      <summary>Joint is the base class for all joints.</summary>
    </member>
    <member name="T:UnityEngine.Joint2D">
      <summary>Parent class for joints to connect Rigidbody2D objects.</summary>
    </member>
    <member name="T:UnityEngine.JointAngleLimits2D">
      <summary>Angular limits on the rotation of a Rigidbody2D object around a HingeJoint2D.</summary>
    </member>
    <member name="T:UnityEngine.JointDrive">
      <summary>How the joint's movement will behave along its local X axis.</summary>
    </member>
    <member name="T:UnityEngine.JointLimits">
      <summary>JointLimits is used by the <see cref="T:UnityEngine.HingeJoint" /> to limit the joints angle.</summary>
    </member>
    <member name="T:UnityEngine.JointMotor">
      <summary>
        <para>The JointMotor is used to motorize a joint.</para>
        <para>For example the <see cref="T:UnityEngine.HingeJoint" /> can be told to rotate at a given speed and force. The joint will then attempt to reach the velocity with the given maximum force.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.JointMotor2D">
      <summary>Parameters for the optional motor force applied to a Joint2D.</summary>
    </member>
    <member name="T:UnityEngine.JointSpring">
      <summary>JointSpring is used add a spring force to <see cref="T:UnityEngine.HingeJoint" /> and <see cref="T:UnityEngine.PhysicMaterial" />.</summary>
    </member>
    <member name="T:UnityEngine.JointSuspension2D">
      <summary>Joint suspension is used to define how suspension works on a <see cref="T:UnityEngine.WheelJoint2D" />.</summary>
    </member>
    <member name="T:UnityEngine.JointTranslationLimits2D">
      <summary>Motion limits of a Rigidbody2D object along a SliderJoint2D.</summary>
    </member>
    <member name="T:UnityEngine.Keyframe">
      <summary>A single keyframe that can be injected into an animation curve.</summary>
    </member>
    <member name="T:UnityEngine.LayerMask">
      <summary>
        <para>LayerMask allow you to display the LayerMask popup menu in the inspector.</para>
        <para>Similar to those in the camera.cullingMask. Layer masks can be used selectively filter game objects for example when casting rays.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LensFlare">
      <summary>
        <para>Script interface for a Lens flare component.</para>
        <para>This allows you to change the brightness and color of lens flares at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Light">
      <summary>
        <para>Script interface for light components.</para>
        <para>Use this to control all aspects of Unity's lights. The properties are an exact match for the values shown in the Inspector.Usually lights are just created in the editor but sometimes you want to create a light from a script:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightmapData">
      <summary>
        <para>Data of a lightmap.</para>
        <para>A scene can have several lightmaps stored in it, and <see cref="T:UnityEngine.Renderer" /> components can use those lightmaps. This makes it possible to use the same material on multiple objects, while each object can refer to a different lightmap or different portion of the same lightmap.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.lightmapIndex" /></para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightmapSettings">
      <summary>
        <para>Stores lightmaps of the scene.</para>
        <para>A scene can have several lightmaps stored in it, and <see cref="T:UnityEngine.Renderer" /> components can use those lightmaps. This makes it possible to use the same material on multiple objects, while each object can refer to a different lightmap or different portion of the same lightmap.See Also: <see cref="T:UnityEngine.LightmapData" /> class, <see cref="P:UnityEngine.Renderer.lightmapIndex" /></para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightProbeGroup">
      <summary>Light Probe Group.</summary>
    </member>
    <member name="T:UnityEngine.LightProbes">
      <summary>
        <para>Stores light probes for the scene.</para>
        <para>The baked data includes: probe positions, Spherical Harmonics (SH) coefficients and the tetrahedral tessellation. You can modify the coefficients at runtime. You can also swap the entire LightProbes object to a different pre-baked one using <see cref="P:UnityEngine.LightmapSettings.lightProbes" />.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.useLightProbes" /> property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LineRenderer">
      <summary>
        <para>The line renderer is used to draw free-floating lines in 3D space.</para>
        <para>This class is a script interface for a line renderer component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LocationInfo">
      <summary>Structure describing device location.</summary>
    </member>
    <member name="T:UnityEngine.LocationService">
      <summary>Interface into location functionality.</summary>
    </member>
    <member name="T:UnityEngine.LOD">
      <summary>Structure for building a LOD for passing to the SetLODs function.</summary>
    </member>
    <member name="T:UnityEngine.LODGroup">
      <summary>
        <para>LODGroup lets you group multiple Renderers into LOD levels.</para>
        <para>This can be used to switch between different LOD levels at runtime based on size on screen.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MasterServer">
      <summary>
        <para>The Master Server is used to make matchmaking between servers and clients easy.</para>
        <para>You can advertise game hosts or fetch host lists for you game type. The functions here are used to communicate with the Master Server itself which resides on a separate server. If necessary the server itself can be customized.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MatchTargetWeightMask">
      <summary>To specify position and rotation weight mask for Animator::MatchTarget.</summary>
    </member>
    <member name="T:UnityEngine.Material">
      <summary>
        <para>The material class.</para>
        <para>This class exposes all properties from a material, allowing you to animate them. You can also use it to set custom shader properties that can't be accessed through the inspector (e.g. matrices).In order to get the material used by an object, use the <see cref="P:UnityEngine.Renderer.material" /> property.See Also: Materials, Shaders.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MaterialPropertyBlock">
      <summary>
        <para>A block of material values to apply.</para>
        <para>MaterialPropertyBlock is used by <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> and <see cref="M:UnityEngine.Renderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)" />. Use it in situations where you want to draw multiple objects with the same material, but slightly different properties. For example, if you want to slightly change the color of each mesh drawn.Unity's terrain engine uses MaterialPropertyBlock to draw trees; all of them use the same material, but each tree has different color, scale &amp; wind factor.The block passed to Graphics.DrawMesh or <see cref="M:UnityEngine.Renderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)" /> is copied, so the most efficient way of using it is to create one block and reuse it for all DrawMesh calls. Use <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" /> to add or replace values.See Also: <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />, <see cref="T:UnityEngine.Material" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Mathf">
      <summary>A collection of common math functions.</summary>
    </member>
    <member name="T:UnityEngine.Matrix4x4">
      <summary>
        <para>A standard 4x4 transformation matrix.</para>
        <para>A transformation matrix can perform arbitrary linear 3D transformations (i.e. translation, rotation, scale, shear etc.) and perspective transformations using homogenous coordinates. You rarely use matrices in scripts; most often using <see cref="T:UnityEngine.Vector3" />s, <see cref="T:UnityEngine.Quaternion" />s and functionality of <see cref="T:UnityEngine.Transform" /> class is more straightforward. Plain matrices are used in special cases like setting up nonstandard camera projection.Consult any graphics textbook for in depth explanation of transformation matrices.In Unity, Matrix4x4 is used by several <see cref="T:UnityEngine.Transform" />, <see cref="T:UnityEngine.Camera" />, <see cref="T:UnityEngine.Material" /> and <see cref="T:UnityEngine.GL" /> functions.Matrices in unity are column major. Data is accessed as: row + (column*4). Matrices can be indexed like 2D arrays but in an expression like mat[a, b], <c>a</c> refers to the row index, while <c>b</c> refers to the column index (note that this is the opposite way round to Cartesian coordinates).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Mesh">
      <summary>
        <para>A class that allows creating or modifying meshes from scripts.</para>
        <para>Meshes contain vertices and multiple triangle arrays. See the <c>Procedural example project</c> for examples of using the mesh interface.The triangle arrays are simply indices into the vertex arrays; three indices for each triangle.For every vertex there can be a normal, two texture coordinates, color and tangent. These are optional though and can be removed at will. All vertex information is stored in separate arrays of the same size, so if your mesh has 10 vertices, you would also have 10-size arrays for normals and other attributes.There are probably 3 things you might want to use the modifyable mesh interface for:1. Building a mesh from scratch: should always be done in the following order: 1) assign <see cref="P:UnityEngine.Mesh.vertices" /> 2) assign <see cref="P:UnityEngine.Mesh.triangles" />.</para>
        <para>2. Modifying vertex attributes every frame: 1) get vertices, 2) modify them, 3) assign them back to the mesh.</para>
        <para>3. Continously changing the mesh triangles and vertices: 1) call <see cref="M:UnityEngine.Mesh.Clear(System.Boolean)" /> to start fresh, 2) assign vertices and other attributes, 3) assign triangle indices.It is important to call Clear before assigning new vertices or triangles. Unity always checks the supplied triangle indices whether they don't reference out of bounds vertices. Calling Clear then assigning vertices then triangles makes sure you never have out of bounds data.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MeshCollider">
      <summary>A mesh collider allows you to do collision detection between meshes and primitives.</summary>
    </member>
    <member name="T:UnityEngine.MeshFilter">
      <summary>
        <para>A class to access the <see cref="T:UnityEngine.Mesh" /> of the mesh filter.</para>
        <para>Use this with a procedural mesh interface.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MeshParticleEmitter">
      <summary>Class used to allow <see cref="M:UnityEngine.GameObject.AddComponent(System.String)" /> / <see cref="M:UnityEngine.GameObject.GetComponent(System.Type)" /> to be used.</summary>
    </member>
    <member name="T:UnityEngine.MeshRenderer">
      <summary>Renders meshes inserted by the <see cref="T:UnityEngine.MeshFilter" /> or <see cref="T:UnityEngine.TextMesh" />.</summary>
    </member>
    <member name="T:UnityEngine.Microphone">
      <summary>
        <para>Use this class to record to an <see cref="T:UnityEngine.AudioClip" /> using a connected microphone.</para>
        <para>You can get a list of connected microphone(s) from the <see cref="P:UnityEngine.Microphone.devices" /> property and then use the <see cref="M:UnityEngine.Microphone.Start(System.String,System.Boolean,System.Int32,System.Int32)" /> and <see cref="M:UnityEngine.Microphone.End(System.String)" /> functions to start or end a recording session using one of the available devices.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MonoBehaviour">
      <summary>
        <para>MonoBehaviour is the base class every script derives from.</para>
        <para>Using Javascript every script automatically derives from MonoBehaviour. When using C# or Boo you have to explicitly derive from MonoBehaviour.Note: The checkbox for disabling a MonoBehavior (on the editor) will only prevent Start(), Awake(), Update(), FixedUpdate(), and OnGUI() from executing.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Motion">
      <summary>
        <para>Base class for AnimationClips and BlendTrees.</para>
        <para>Motions are used by animation States in the Mecanim StateMachines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MovieTexture">
      <summary>
        <para>Movie Textures are textures onto which movies are played back.</para>
        <para>They can be used for cutscene movie sequences, or to render movies into the scene itself.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMesh">
      <summary>
        <para>Singleton class to access the baked NavMesh.</para>
        <para>• <see cref="T:UnityEngine.NavMeshAgent" /> – to learn how to control and move NavMesh Agents. • <see cref="T:UnityEngine.NavMeshObstacle" /> – to learn how to control NavMesh Obstacles using scripting. • <see cref="T:UnityEngine.OffMeshLink" /> – to learn how to control Off-Mesh Links using scripting.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMeshAgent">
      <summary>
        <para>Navigation mesh agent.</para>
        <para>This component is attached to a mobile character in the game to allow it to navigate the scene using the NavMesh.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMeshHit">
      <summary>Result information for NavMesh queries.</summary>
    </member>
    <member name="T:UnityEngine.NavMeshObstacle">
      <summary>
        <para>An obstacle for NavMeshAgents to avoid.</para>
        <para>A NavMeshObstacle is cylindrical in shape and can move around the surface of the NavMesh with a specified velocity. By default, the obstacle will only affect the agent's <c>avoidance</c> behaviour rather than the pathfinding. This means that the agent will ignore the obstacle when plotting a path but will sidestep around it while moving along the path. If <c>carving</c> is enabled, the obstacle will create a temporary "hole" in the NavMesh. The hole will be recognised by the pathfinding, so paths will be plotted to avoid the obstacle. This means that if, say, an obstacle blocks a narrow gap, the pathfinding will seek an alternative route to the target. Without carving, the agent will head for the gap but won't be able to pass until the obstacle is clear.See Also: <see cref="T:UnityEngine.NavMeshAgent" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMeshPath">
      <summary>
        <para>A path as calculated by the navigation system.</para>
        <para>The path is represented as a list of waypoints stored in the <see cref="P:UnityEngine.NavMeshPath.corners" /> array. These points are not set directly from user scripts but a NavMeshPath with points correctly assigned is returned by the <see cref="M:UnityEngine.NavMesh.CalculatePath(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32,UnityEngine.NavMeshPath)" /> function and the <see cref="P:UnityEngine.NavMeshAgent.path" /> property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMeshTriangulation">
      <summary>Contains data describing a triangulation of a navmesh.</summary>
    </member>
    <member name="T:UnityEngine.Network">
      <summary>
        <para>The network class is at the heart of the network implementation and provides the core functions.</para>
        <para>This class configures the network interface and all the network parameters. You use it to set up a server or connect to one and have a row of helper functions to help you with those tasks.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkMessageInfo">
      <summary>
        <para>This data structure contains information on a message just received from the network.</para>
        <para>It reveals where it came from, what time it was send and what network view sent it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkPlayer">
      <summary>
        <para>The NetworkPlayer is a data structure with which you can locate another player over the network.</para>
        <para>With this you can, for example, send a message directly to another player.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkView">
      <summary>
        <para>The network view is the binding material of multiplayer games.</para>
        <para>With this you can define exactly what is to be synchronized over the network and how it should be done. Game objects can have NetworkView components which can be configured to watch other components for the object.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkViewID">
      <summary>
        <para>The NetworkViewID is a unique identifier for a network view instance in a multiplayer game.</para>
        <para>It is imporatant that this is a unique number accross all clients and that they can generate these numbers themselves, or else network synchronization will break.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Object">
      <summary>
        <para>Base class for all objects Unity can reference.</para>
        <para>Any public variable you make that derives from Object gets shown in the inspector as a drop target, allowing you to set the value from the GUI.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.OcclusionArea">
      <summary>OcclusionArea is an area in which occlusion culling is performed.</summary>
    </member>
    <member name="T:UnityEngine.OcclusionPortal">
      <summary>The portal for dynamically changing occlusion at runtime.</summary>
    </member>
    <member name="T:UnityEngine.OffMeshLink">
      <summary>Link allowing movement outside the planar navigation mesh.</summary>
    </member>
    <member name="T:UnityEngine.OffMeshLinkData">
      <summary>State of OffMeshLink.</summary>
    </member>
    <member name="T:UnityEngine.Particle">
      <summary>(Legacy Particle system).</summary>
    </member>
    <member name="T:UnityEngine.ParticleAnimator">
      <summary>
        <para>(Legacy Particles) Particle animators move your particles over time, you use them to apply wind, drag &amp; color cycling to your particle emitters.</para>
        <para>This class is a script interface for a particle animator component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ParticleCollisionEvent">
      <summary>Information about a particle collision.</summary>
    </member>
    <member name="T:UnityEngine.ParticleEmitter">
      <summary>(Legacy Particles) Script interface for particle emitters.</summary>
    </member>
    <member name="T:UnityEngine.ParticlePhysicsExtensions">
      <summary>Method extension for Physics in Particle System.</summary>
    </member>
    <member name="T:UnityEngine.ParticleRenderer">
      <summary>
        <para>(Legacy Particles) Renders particles on to the screen.</para>
        <para>This class is a script interface for a particle renderer component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ParticleSystem">
      <summary>Script interface for particle systems (Shuriken).</summary>
    </member>
    <member name="T:UnityEngine.ParticleSystem.Particle">
      <summary>Script interface for a Particle.</summary>
    </member>
    <member name="T:UnityEngine.ParticleSystemRenderer">
      <summary>Renders particles on to the screen (Shuriken).</summary>
    </member>
    <member name="T:UnityEngine.PhysicMaterial">
      <summary>Physics material describes how to handle colliding objects (friction, bounciness).</summary>
    </member>
    <member name="T:UnityEngine.Physics">
      <summary>Global physics properties and helper methods.</summary>
    </member>
    <member name="T:UnityEngine.Physics2D">
      <summary>Global settings and helpers for 2D physics.</summary>
    </member>
    <member name="T:UnityEngine.PhysicsMaterial2D">
      <summary>
        <para>Asset type that defines the surface properties of a Collider2D.</para>
        <para>Note: the 3D equivalent of this class is spelt as "PhysicMaterial" with no S, but this class is spelt "PhysicsMaterial" with an S.See Also: <see cref="T:UnityEngine.PhysicMaterial" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PhysicsUpdateBehaviour2D">
      <summary>A base type for 2D physics components that required a callback during FixedUpdate.</summary>
    </member>
    <member name="T:UnityEngine.Ping">
      <summary>
        <para>Ping any given IP address (given in dot notation).</para>
        <para>The ping operation is asynchronous and a ping object can be polled for status using Ping.isDone. When a response is received it is in Ping.time.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Plane">
      <summary>
        <para>Representation of a plane in 3D space.</para>
        <para>A plane is an infinitely large, flat surface that exists in 3D space and divides the space into two halves known as <c>half-spaces</c>. It is easy to determine which of the two half-spaces a particular point is in and also how far the point is from the plane. Walls, floors and other flat surfaces are common in games, so a plane is sometimes useful for mathematical calculations with these objects. Also, there are cases where a real surface does not exist but it is useful to imagine that one is there. For example, in sports, a goal line or out-of-bounds line is often assumed to extend into the air, effectively defining a plane.When a plane passes through the &lt;0,0,0&gt; point in world space, it is defined simply by a normal vector that determines which way it faces. It is easy to visualise this if you imagine looking at the plane edge-on.Note that the side from which the normal vector points is important since it is used to identify which half-space a point is in (ie, on the positive or "normal" side of the plane or the other side). When the plane doesn't pass through &lt;0,0,0&gt; it can be defined by the normal vector along with a distance from &lt;0,0,0&gt;A plane can also be defined by the three corner points of a triangle that lies within the plane. In this case, the normal vector points toward you if the corner points go around clockwise as you look at the triangle face-on..</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlatformEffector2D">
      <summary>
        <para>Applies "platform" behaviour such as one-way collisions etc.</para>
        <para>When the source <see cref="T:UnityEngine.Collider2D" /> is a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> overlaps the source. When the source <see cref="T:UnityEngine.Collider" /> isn't a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> is in contact with the source only.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlayerPrefs">
      <summary>
        <para>Stores and accesses player preferences between game sessions.</para>
        <para>Editor/StandaloneOn Mac OS X PlayerPrefs are stored in ~/Library/Preferences folder, in a file named unity.[company name].[product name].plist, where company and product names are the names set up in Project Settings. If this limit is exceeded, SetInt, SetFloat and SetString will not store the value and throw a <see cref="T:UnityEngine.PlayerPrefsException" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlayerPrefsException">
      <summary>
        <para>An exception thrown by the <see cref="T:UnityEngine.PlayerPrefs" /> class in a web player build.</para>
        <para>The exception is thrown when writing to a preference file exceeds the allotted storage space. The storage space is 1MB for a web player. This exception is not thrown on other platforms.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PointEffector2D">
      <summary>
        <para>Applies forces to attract/repulse against a point.</para>
        <para>When the source <see cref="T:UnityEngine.Collider2D" /> is a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> overlaps the source. When the source <see cref="T:UnityEngine.Collider" /> isn't a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> is in contact with the source only.This effector is designed primarily to work with source <see cref="T:UnityEngine.Collider2D" /> that are set as triggers so that target <see cref="T:UnityEngine.Collider2D" /> can overlap the defined area.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PolygonCollider2D">
      <summary>Collider for 2D physics representing an arbitrary polygon defined by its vertices.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralMaterial">
      <summary>Class for ProceduralMaterial handling.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralPropertyDescription">
      <summary>Describes a ProceduralProperty.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralTexture">
      <summary>Class for ProceduralTexture handling.</summary>
    </member>
    <member name="T:UnityEngine.Profiler">
      <summary>
        <para>Controls the Profiler from script.</para>
        <para>You can add custom Profiler sections in your scripts with Profiler.BeginSample and Profiler.EndSample.In standalone games, Profiler can dump all profiling information using Profiler.logFile and Profiler.enabled.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Projector">
      <summary>
        <para>A script interface for a projector component.</para>
        <para>The Projector can be used to project any material onto the scene - just like a real world projector. The properties exposed by this class are an exact match for the values in the Projector's inspector.It can be used to implement blob or projected shadows. You could also project an animated texture or a render texture that films another part of the scene. The projector will render all objects in its view frustum with the provided material.There is no shortcut property in <see cref="T:UnityEngine.GameObject" /> or <see cref="T:UnityEngine.Component" /> to access the Projector, so you must use <see cref="M:UnityEngine.Component.GetComponent(System.Type)" /> to do it:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.QualitySettings">
      <summary>
        <para>Script interface for Quality Settings.</para>
        <para>There can be an arbitrary number of quality settings. The details of each are set up in the project's Quality Settings. At run time, the current quality level can be changed using this class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Quaternion">
      <summary>
        <para>Quaternions are used to represent rotations.</para>
        <para>They are compact, don't suffer from gimbal lock and can easily be interpolated. Unity internally uses Quaternions to represent all rotations.They are based on complex numbers and are not easy to understand intuitively. You almost never access or modify individual Quaternion components (x,y,z,w); most often you would just take existing rotations (e.g. from the <see cref="T:UnityEngine.Transform" />) and use them to construct new rotations (e.g. to smoothly interpolate between two rotations). The Quaternion functions that you use 99% of the time are: <see cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />, <see cref="M:UnityEngine.Quaternion.Angle(UnityEngine.Quaternion,UnityEngine.Quaternion)" />, <see cref="M:UnityEngine.Quaternion.Euler(System.Single,System.Single,System.Single)" />, <see cref="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />, <see cref="M:UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />, and <see cref="P:UnityEngine.Quaternion.identity" />. (The other functions are only for exotic uses.)You can use the Quaternion.operator * to rotate one rotation by another, or to rotate a vector by a rotation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Random">
      <summary>Class for generating random data.</summary>
    </member>
    <member name="T:UnityEngine.Ray">
      <summary>
        <para>Representation of rays.</para>
        <para>A ray is an infinite line starting at <see cref="P:UnityEngine.Ray.origin" /> and going in some <see cref="P:UnityEngine.Ray.direction" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Ray2D">
      <summary>
        <para>A ray in 2D space.</para>
        <para>A <c>ray</c> is a line segment that extends from a point in space in a specified direction. Rays have a number of uses in Unity but the most common is probably <c>raycasting</c>. This technique involves tracing along the path of a ray from its origin to determine if it intersects with any objects. This is useful for plotting the paths of projectiles, determining lines of sight and implementing many common game mechanics.See Also: <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="T:UnityEngine.Ray" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RaycastHit">
      <summary>Structure used to get information back from a raycast.</summary>
    </member>
    <member name="T:UnityEngine.RaycastHit2D">
      <summary>
        <para>Information returned about an object detected by a raycast in 2D physics.</para>
        <para>A <c>raycast</c> is used to detect objects that lie along the path of a <c>ray</c> and is conceptually like firing a laser beam into the scene and observing which objects are hit by it. The RaycastHit2D class is used by <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> and other functions to return information about the objects detected by raycasts.See Also: <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="T:UnityEngine.Ray2D" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rect">
      <summary>
        <para>A 2D Rectangle defined by x, y position and width, height.</para>
        <para>The <c>Rect</c> structure is mainly used for 2D operations. The UnityGUI system uses it extensively and it is also to set the onscreen position of a Camera's view.The rectangle can be specified in two different ways. The first way involves supplying the corner coordinate (usually that's imagined as top-left) along with the width and height. This is done using the <see cref="P:UnityEngine.Rect.x" />, <see cref="P:UnityEngine.Rect.y" />, <see cref="P:UnityEngine.Rect.width" /> and <see cref="P:UnityEngine.Rect.height" /> properties. The second way to specify the rectangle is to supply the X coordinates of its left and right sides and the Y coordinates of its top and bottom sides. These are denoted by the <see cref="P:UnityEngine.Rect.xMin" />, <see cref="P:UnityEngine.Rect.xMax" />, <see cref="P:UnityEngine.Rect.yMin" /> and <see cref="P:UnityEngine.Rect.yMax" /> properties.Although the <see cref="P:UnityEngine.Rect.x" /> and <see cref="P:UnityEngine.Rect.y" /> properties may seem to be the same as <see cref="P:UnityEngine.Rect.xMin" /> and <see cref="P:UnityEngine.Rect.xMax" />, their behaviour is actually slightly different. The <c>x</c> and <c>y</c> values are assumed to be used along with <c>width</c> and <c>height</c>. This means that if you change <c>x</c> or <c>y</c> without changing <c>width</c> or <c>height</c> then the rectangle will change position but stay the same size. On the other hand, if you change the values of <c>xMin</c> or <c>yMin</c> without changing <c>xMax</c> or <c>yMax</c> then the rectangle will change size and the top-left corner will also change.See Also: GUI Scripting Guide, <see cref="P:UnityEngine.Camera.rect" />, <see cref="P:UnityEngine.Camera.pixelRect" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectOffset">
      <summary>
        <para>Offsets for rectangles, borders, etc.</para>
        <para>Used all over the place by <see cref="T:UnityEngine.GUIStyle" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectTransform">
      <summary>
        <para>Position, size, anchor and pivot information for a rectangle.</para>
        <para>RectTransforms are used for GUI but can also be used for other things. It's used to store and manipulate the position, size, and anchoring of a rectangle and supports various forms of scaling based on a parent RectTransform.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectTransformUtility">
      <summary>Utility class containing helper methods for working with <see cref="T:UnityEngine.RectTransform" />.</summary>
    </member>
    <member name="T:UnityEngine.ReflectionProbe">
      <summary>
        <para>The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.</para>
        <para>The properties are an exact match for the values shown in the Inspector.This class is a script interface for a reflection probe component. Reflection probes are usually just created in the Editor, but sometimes you might want to create a reflection probe from a script:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderBuffer">
      <summary>
        <para>Color or depth buffer part of a <see cref="T:UnityEngine.RenderTexture" />.</para>
        <para>A single <see cref="T:UnityEngine.RenderTexture" /> object represents both color and depth buffers, but many complex rendering algorithms require using the same depth buffer with multiple color buffers or vice versa.This class represents either a color or a depth buffer part of a RenderTexture.See Also: <see cref="P:UnityEngine.RenderTexture.colorBuffer" />, <see cref="P:UnityEngine.RenderTexture.depthBuffer" />, <see cref="P:UnityEngine.Graphics.activeColorBuffer" />, <see cref="P:UnityEngine.Graphics.activeDepthBuffer" />, <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Renderer">
      <summary>
        <para>General functionality for all renderers.</para>
        <para>A renderer is what makes an object appear on the screen. Use this class to access the renderer of any object, mesh or particle system. Renderers can be disabled to make objects invisible (see <see cref="P:UnityEngine.Renderer.enabled" />), and the materials can be accessed and modified through them (see <see cref="P:UnityEngine.Renderer.material" />).See Also: Renderer components for meshes, particles, lines and trails.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderSettings">
      <summary>
        <para>The Render Settings contain values for a range of visual elements in your scene, like fog and ambient light.</para>
        <para>Note that render settings are per-scene.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderTargetSetup">
      <summary>Fully describes setup of RenderTarget.</summary>
    </member>
    <member name="T:UnityEngine.RenderTexture">
      <summary>
        <para>Render textures are textures that can be rendered to.</para>
        <para>They can be used to implement image based rendering effects, dynamic shadows, projectors, reflections or surveillance cameras.One typical usage of render textures is setting them as the "target texture" property of a Camera (<see cref="P:UnityEngine.Camera.targetTexture" />), this will make a camera render into a texture instead of rendering to the screen.Another use case is manually implementing various rendering effects, for example Image Effects. There you often get temporary short-lived render textures (<see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" /> and <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> functions), and manually render objects into them (see <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> and <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" />).Keep in mind that render texture contents can become "lost" on certain events, like loading a new level, system going to a screensaver mode, in and out of fullscreen and so on. When that happens, your existing render textures will become "not yet created" again, you can check for that with <see cref="M:UnityEngine.RenderTexture.IsCreated" /> function.See Also: <see cref="P:UnityEngine.Camera.targetTexture" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Resolution">
      <summary>
        <para>Represents a display resolution.</para>
        <para>Resolution structures are returned by Screen.resolutions property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ResourceRequest">
      <summary>Asynchronous load request from the Resources bundle.</summary>
    </member>
    <member name="T:UnityEngine.Resources">
      <summary>
        <para>The Resources class allows you to find and access Objects including assets.</para>
        <para>In the editor, <see cref="M:UnityEngine.Resources.FindObjectsOfTypeAll(System.Type)" /> can be used to locate assets and scene objects.All assets that are in a folder named "Resources" anywhere in the Assets folder can be accessed via the Resources.Load functions. Multiple "Resources" folders may exist and when loading objects each will be examined.In Unity you usually don't use path names to access assets, instead you expose a reference to an asset by declaring a member-variable, and then assign it in the inspector. When using this technique Unity can automatically calculate which assets are used when building a player. This radically minimizes the size of your players to the assets that you actually use in the built game. When you place assets in "Resources" folders this can not be done, thus all assets in the "Resources" folders will be included in a build.Another disadvantage of using path names is that it leads to less reusable code since scripts will have specific hard coded requirements on where the used assets are placed. On the other hand using references that are exposed in the inspector are self-documenting and immediately obvious to the user of your script.However there are situations where it is more convenient to fetch an asset by its name instead of linking to it in the inspector. Essentially whenever it is inconvenient to assign the reference to the object in the inspector. For example you might want to create a game object procedurally from a script and for example assign a texture to a procedurally generated mesh.Some loaded assets, most notably textures, can use up memory even when no instance exists in the scene. To reclaim this memory when the asset is no longer needed, you can use Resources.UnloadUnusedAssets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rigidbody">
      <summary>
        <para>Control of an object's position through physics simulation.</para>
        <para>Adding a Rigidbody component to an object will put its motion under the control of Unity's physics engine. Even without adding any code, a Rigidbody object will be pulled downward by gravity and will react to collisions with incoming objects if the right <see cref="T:UnityEngine.Collider" /> component is also present. The Rigidbody also has a scripting API that lets you apply forces to the object and control it in a physically realistic way. For example, a car's behaviour can be specified in terms of the forces applied by the wheels. Given this information, the physics engine can handle most other aspects of the car's motion, so it will accelerate realistically and respond correctly to collisions.In a script, the <c>FixedUpdate</c> function is recommended as the place to apply forces and change Rigidbody settings (as opposed to <c>Update</c>, which is used for most other frame update tasks). The reason for this is that physics updates are carried out in measured time steps that don't coincide with the frame update. FixedUpdate is called immediately before each physics update and so any changes made there will be processed directly.A common problem when starting out with Rigidbodies is that the game physics appears to run in "slow motion". This is actually due to the scale used for your models. The default gravity settings assume that one world unit corresponds to one metre of distance. With non-physical games, it doesn't make much difference if your models are all 100 units long but when using physics, they will be treated as very large objects. If a large scale is used for objects that are supposed to be small, they will appear to fall very slowly - the physics engine thinks they are very large objects falling over very large distances. With this in mind, be sure to keep your objects more or less at their scale in real life (so a car should be about 4 units = 4 metres, for example).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rigidbody2D">
      <summary>
        <para>Rigidbody physics component for 2D sprites.</para>
        <para>The Rigidbody2D class essentially provides the same functionality in 2D that the Rigidbody class provides in 3D. Adding a Rigidbody2D component to a sprite puts in under the control of the physics engine. By itself, this means that the sprite will be affected by gravity and can be controlled from scripts using forces. By adding the appropriate collider component, the sprite will also respond to collisions with other sprites. This behaviour comes entirely from Unity's physics system; very little code is required to get impressive and authentic physical behaviour and allows for "emergent" gameplay that was not explicitly coded into the game.See Also: <see cref="T:UnityEngine.Rigidbody" /> class, <see cref="T:UnityEngine.SpriteRenderer" /> class, <see cref="T:UnityEngine.Collider2D" /> class, <see cref="T:UnityEngine.Joint2D" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RuntimeAnimatorController">
      <summary>Runtime reprentation of the AnimatorController. It can be used to change the Animator's controller during runtime.</summary>
    </member>
    <member name="T:UnityEngine.SamsungTV">
      <summary>Interface into SamsungTV specific functionality.</summary>
    </member>
    <member name="T:UnityEngine.SamsungTV.OpenAPI">
      <summary>Access to TV specific information.</summary>
    </member>
    <member name="T:UnityEngine.Screen">
      <summary>
        <para>Access to display information.</para>
        <para>Screen class can be used to get the list of supported resolutions, switch the current resolution, hide or show the system mouse pointer.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ScriptableObject">
      <summary>
        <para>A class you can derive from if you want to create objects that don't need to be attached to game objects.</para>
        <para>This is most useful for assets which are only meant to store data.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Security">
      <summary>Webplayer security related class.</summary>
    </member>
    <member name="T:UnityEngine.Shader">
      <summary>
        <para>Shader scripts used for all rendering.</para>
        <para>Most of the advanced rendering is controlled via <see cref="T:UnityEngine.Material" /> class. Shader class is mostly used just to check whether a shader can run on the user's hardware (<see cref="P:UnityEngine.Shader.isSupported" /> property), setting up global shader properties and keywords, and finding shaders by name (<see cref="M:UnityEngine.Shader.Find(System.String)" /> method).See Also: <see cref="T:UnityEngine.Material" /> class, Materials, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShaderVariantCollection">
      <summary>
        <para>ShaderVariantCollection records which shader variants are actually used in each shader.</para>
        <para>This is used for shader preloading ("warmup"), so that a game can make sure "actually required" shader variants are loaded at startup (or level load time), to avoid shader compilation related hiccups later on in the game.In Unity, many shaders internally have multiple "variants", to account for different light modes, lightmaps, shadows and so on. These variants are indentified by a shader pass type, and a set of shader keywords. See <see cref="T:UnityEngine.ShaderVariantCollection.ShaderVariant" />.Typical use of ShaderVariantCollection is to record the shader variants used during a play session from the editor (under Graphics Settings), save them out as an asset, and add to the list of preloaded shaders (again in Graphics Settings). Additionally, you could call <see cref="M:UnityEngine.ShaderVariantCollection.WarmUp" /> on a ShaderVariantCollection object manually.ShaderVariantCollection generally replaces the old <see cref="M:UnityEngine.Shader.WarmupAllShaders" /> function.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShaderVariantCollection.ShaderVariant">
      <summary>
        <para>Identifies a specific variant of a shader.</para>
        <para>In Unity, many shaders internally have multiple "variants", to account for different light modes, lightmaps, shadows and so on. These variants are indentified by a shader pass type, and a set of shader keywords. See <see cref="T:UnityEngine.ShaderVariantCollection" />.Note that creating a ShaderVariant will throw an ArgumentException if shader is null, pass type does not exist or variant with the passed keywords is not found.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SkeletonBone">
      <summary>Details of the Transform name mapped to a model's skeleton bone and its default position and rotation in the T-pose.</summary>
    </member>
    <member name="T:UnityEngine.SkinnedMeshRenderer">
      <summary>The Skinned Mesh filter.</summary>
    </member>
    <member name="T:UnityEngine.Skybox">
      <summary>
        <para>A script interface for the skybox component.</para>
        <para>The skybox class has only the <see cref="P:UnityEngine.Skybox.material" /> property.See Also: skybox component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SleepTimeout">
      <summary>
        <para>Constants for special values of <see cref="P:UnityEngine.Screen.sleepTimeout" />.</para>
        <para>Use them to specify something other than a fixed amount of seconds before dimming the screen.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SliderJoint2D">
      <summary>Joint that restricts the motion of a <see cref="T:UnityEngine.Rigidbody2D" /> object to a single line.</summary>
    </member>
    <member name="T:UnityEngine.Social">
      <summary>
        <para>Generic access to the Social API.</para>
        <para>
          <see cref="P:UnityEngine.Social.Active" /> can be used to target a specific social platform implementation, but by default GameCenter is used on iOS. All other platforms default to the Local implementation which can be used for testing. See Social API Reference Manual for an overview.The <see cref="T:UnityEngine.Social" /> class should always be used as an entry point. It contains helper functions for accessing the current active implementation and always uses the interfaces of the other Social API classes. This way it is easier to use versions of the interfaces which have been extended beoynd the generic API by the implementation. There are varoius classes accociated with the Social API and all of these reside in the UnityEngine.SocialPlatforms namespace. You need to import/use this namespace in order to use these classes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SoftJointLimit">
      <summary>The limits defined by the <see cref="T:UnityEngine.CharacterJoint" />.</summary>
    </member>
    <member name="T:UnityEngine.SoftJointLimitSpring">
      <summary>The configuration of the spring attached to the joint's limits: linear and angular. Used by <see cref="T:UnityEngine.CharacterJoint" /> and <see cref="T:UnityEngine.ConfigurableJoint" />.</summary>
    </member>
    <member name="T:UnityEngine.SortingLayer">
      <summary>SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.</summary>
    </member>
    <member name="T:UnityEngine.SparseTexture">
      <summary>
        <para>Class for handling Sparse Textures.</para>
        <para>Sparse textures are textures where not the whole texture data can be present in memory at once. They are also commonly called "tiled textures" or "mega textures".Imagine a 16384x16384 texture at 32 bits per pixel - it would take 1GB of memory. The texture is broken down into rectangular "tiles", and each tile can either be present in memory or not. You can load &amp; unload these tiles as needed based on distance from the camera, sectors of the world that the player has to see, etc.Otherwise, the sparse textures behave just like any other texture in shaders - they can have mipmaps, can use all texture filtering modes, etc. If you happen to read from a tile that's not present, you can get undefined result (on many GPUs the result is a black color, but that's not guaranteed).Note that not all hardware and platforms support sparse textures, so you should check <see cref="P:UnityEngine.SystemInfo.supportsSparseTextures" /> before using them. For example, on DirectX systems they require DX11.2 (Windows 8.1) and a fairly recent GPU; and on OpenGL they require ARB_sparse_texture extension support.After creating the sparse texture, query the tile size with <see cref="P:UnityEngine.SparseTexture.tileWidth" /> &amp; <see cref="P:UnityEngine.SparseTexture.tileHeight" />. Tile sizes are platform and GPU dependent.Use <see cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])" /> or <see cref="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])" /> to make a tile resident in memory and update its color data. Use <see cref="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)" /> to unload a tile.See Also: Sparse Textures documentation page.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SphereCollider">
      <summary>A sphere-shaped primitive collider.</summary>
    </member>
    <member name="T:UnityEngine.SplatPrototype">
      <summary>
        <para>A Splat prototype is just a texture that is used by the TerrainData.</para>
        <para>Class on a Terrain GameObject.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpringJoint">
      <summary>
        <para>The spring joint ties together 2 rigid bodies, spring forces will be automatically applied to keep the object at the given distance.</para>
        <para>The Spring attempts to maintain the distance it has when it starts out. So if your joint's start at a rest position where the two rigidbodies are far apart, then the joint will attempt to maintain that distance. The minDistance and maxDistance properties add on top of this implicit distance.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpringJoint2D">
      <summary>
        <para>Joint that attempts to keep two <see cref="T:UnityEngine.Rigidbody2D" /> objects a set distance apart by applying a force between them.</para>
        <para>Note that unlike DistanceJoint2D, the length of the joint can stretch and oscillate.See Also: <see cref="T:UnityEngine.DistanceJoint2D" />, <see cref="T:UnityEngine.HingeJoint2D" />, <see cref="T:UnityEngine.SliderJoint2D" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Sprite">
      <summary>
        <para>Represents a Sprite object for use in 2D gameplay.</para>
        <para>
          <c>Sprites</c> are 2D graphic objects used for characters, props, projectiles and other elments of 2D gameplay. The graphics are obtained from bitmap images - <see cref="T:UnityEngine.Texture2D" />. The Sprite class primarily identifies the section of the image that should be used for a specific sprite. This information can then be used by a SpriteRenderer component on a GameObject to actually display the graphic.See Also: <see cref="T:UnityEngine.SpriteRenderer" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpriteRenderer">
      <summary>Renders a Sprite for 2D graphics.</summary>
    </member>
    <member name="T:UnityEngine.StateMachineBehaviour">
      <summary>
        <para>StateMachineBehaviour is a component that can be added to a state machine state. It's the base class every script on a state derives from.</para>
        <para>By default the Animator does instantiate a new instance of each behaviour define in the controller. The class attribute <see cref="T:UnityEngine.SharedBetweenAnimatorsAttribute" /> control how behaviours are instantiated. StateMachineBehaviour has some predefined messages: <c>OnStateEnter</c>, <c>OnStateExit</c>, <c>OnStateIK</c>, <c>OnStateMove</c>, <c>OnStateUpdate</c>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.StaticBatchingUtility">
      <summary>
        <para>StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.</para>
        <para>This step is useful as a performance optimization allowing engine to reduce number of draw-calls dramatically, but keep amount of rendered geometry intact.By calling one of the Combine methods you will create an internal mesh which will contain combined geometry, however each original GameObject will be present in the scene and will be culled individually. The fact that GameObjects can be culled individually allows run-time to render the same amount of geometry as it would without batching, unlike combining geometry in the modeling tool. Combining geometry in the modeling tool prevents efficient culling and results in much higher amount of geometry being rendered.Note that you do not need to call Combine methods on objects which were already marked as "Static" in the Editor. They will be prepared for static batching automatically during the Build Player step.IMPORTANT: only objects with the same material can be batched, thus it is useful to share as many textures/material as you can.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SurfaceEffector2D">
      <summary>
        <para>Applies tangent forces along the surfaces of colliders.</para>
        <para>When the source <see cref="T:UnityEngine.Collider2D" /> is a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> overlaps the source. When the source <see cref="T:UnityEngine.Collider" /> isn't a trigger, the effector will apply forces whenever the target <see cref="T:UnityEngine.Collider2D" /> is in contact with the source only.This effector can be used to create constant speed elevators and moving surfaces.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SystemInfo">
      <summary>Access system information.</summary>
    </member>
    <member name="T:UnityEngine.Terrain">
      <summary>The Terrain component renders the terrain.</summary>
    </member>
    <member name="T:UnityEngine.TerrainCollider">
      <summary>A heightmap based collider.</summary>
    </member>
    <member name="T:UnityEngine.TerrainData">
      <summary>
        <para>The TerrainData class stores heightmaps, detail mesh positions, tree instances, and terrain texture alpha maps.</para>
        <para>The <see cref="T:UnityEngine.Terrain" /> component links to the terrain data and renders it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextAsset">
      <summary>
        <para>Text file assets.</para>
        <para>You can use raw text files in your project as assets and get their contents through this class. Also, you can access the file as a raw byte array if you want to access data from binary files.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextGenerationSettings">
      <summary>A struct that stores the settings for TextGeneration.</summary>
    </member>
    <member name="T:UnityEngine.TextGenerator">
      <summary>
        <para>Class that can be used to generate text for rendering.</para>
        <para>Caches vertices, character info, and line info for memory friendlyness.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextMesh">
      <summary>A script interface for the text mesh component.</summary>
    </member>
    <member name="T:UnityEngine.Texture">
      <summary>Base class for texture handling. Contains functionality that is common to both <see cref="T:UnityEngine.Texture2D" /> and <see cref="T:UnityEngine.RenderTexture" /> classes.</summary>
    </member>
    <member name="T:UnityEngine.Texture2D">
      <summary>
        <para>Class for texture handling.</para>
        <para>Use this to create textures on the fly or to modify existing texture assets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Texture3D">
      <summary>
        <para>Class for handling 3D Textures, Use this to create 3D texture assets.</para>
        <para>3D textures are commonly used as lookup tables by shaders, or to represent volumetric data.Typically you'd create a 3D texture, fill it up with data (<see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" /> or <see cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />) and call <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> to upload the data to the GPU.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Time">
      <summary>The interface to get time information from Unity.</summary>
    </member>
    <member name="T:UnityEngine.Touch">
      <summary>
        <para>Structure describing the status of a finger touching the screen.</para>
        <para>Devices can track a number of different pieces of data about a touch on a touchscreen, including its <c>phase</c> (ie, whether it has just started, ended or moved), its position and whether the touch was a single contact or several taps. Furthermore, the continuity of a touch between frame updates can be detected by the device, so a consistent ID number can be reported across frames and used to determine how a particular finger is moving.The Touch struct is used by Unity to store data relating to a single touch instance and is returned by the <see cref="M:UnityEngine.Input.GetTouch(System.Int32)" /> function. Fresh calls to GetTouch will be required on each frame update to obtain the latest touch information from the device but the <see cref="P:UnityEngine.Touch.fingerId" /> property can be used to identify the same touch between frames.See Also: <see cref="M:UnityEngine.Input.GetTouch(System.Int32)" />, <see cref="T:UnityEngine.TouchPhase" /> enum.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TouchScreenKeyboard">
      <summary>
        <para>Interface into the native iPhone, Android, Windows Phone and Windows Store Apps on-screen keyboards - it is not available on other platforms.</para>
        <para>This interface allows to display different types of the keyboard: ASCII, Numbers, URL, Email, and others.Because the appearance of the keyboard has the potential to obscure portions of your user interface, it is up to you to make sure that parts of your user interface are not obscured when the keyboard is being displayed.<c>TouchScreenKeyboard.visible</c> and <c>TouchScreenKeyboard.area</c> should be used to determine if the keyboard is being shown (activated) and what portion of the screen is using.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TrailRenderer">
      <summary>
        <para>The trail renderer is used to make trails behind objects in the scene as they move about.</para>
        <para>This class is a script interface for a trail renderer component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Transform">
      <summary>
        <para>Position, rotation and scale of an object.</para>
        <para>Every object in a scene has a Transform. It's used to store and manipulate the position, rotation and scale of the object. Every Transform can have a parent, which allows you to apply position, rotation and scale hierarchically. This is the hierarchy seen in the Hierarchy pane. They also support enumerators so you can loop through children using:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Tree">
      <summary>Tree Component for the tree creator.</summary>
    </member>
    <member name="T:UnityEngine.TreeInstance">
      <summary>
        <para>Contains information about a tree placed in the Terrain game object.</para>
        <para>This struct can be accessed from the TerrainData Object.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TreePrototype">
      <summary>
        <para>Simple class that contains a pointer to a tree prototype.</para>
        <para>This class is used by the TerrainData gameObject.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector2">
      <summary>
        <para>Representation of 2D vectors and points.</para>
        <para>This structure is used in some places to represent 2D positions and vectors (e.g. texture coordinates in a <see cref="T:UnityEngine.Mesh" /> or texture offsets in <see cref="T:UnityEngine.Material" />). In the majority of other cases a Vector3 is used.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector3">
      <summary>
        <para>Representation of 3D vectors and points.</para>
        <para>This structure is used throughout Unity to pass 3D positions and directions around. It also contains functions for doing common vector operations.Besides the functions listed below, other classes can be used to manipulate vectors and points as well. For example the <see cref="T:UnityEngine.Quaternion" /> and the <see cref="T:UnityEngine.Matrix4x4" /> classes are useful for rotating or transforming vectors and points.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector4">
      <summary>
        <para>Representation of four-dimensional vectors.</para>
        <para>This structure is used in some places to represent four component vectors (e.g. mesh tangents, parameters for shaders). In the majority of other cases a <see cref="T:UnityEngine.Vector3" /> is used.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitForEndOfFrame">
      <summary>
        <para>Waits until the end of the frame after all cameras and GUI is rendered, just before displaying the frame on screen.</para>
        <para>You can use it to read the display into a texture, encode it as an image file (see Texture2D.ReadPixels and Texture2D.EncodeToPNG) and send it somewhere.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitForFixedUpdate">
      <summary>
        <para>Waits until next fixed frame rate update function.</para>
        <para>WaitForFixedUpdate can only be used with a <c>yield</c> statement in coroutines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitForSeconds">
      <summary>
        <para>Suspends the coroutine execution for the given amount of seconds.</para>
        <para>WaitForSeconds can only be used with a <c>yield</c> statement in coroutines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WebCamDevice">
      <summary>A structure describing the webcam device.</summary>
    </member>
    <member name="T:UnityEngine.WebCamTexture">
      <summary>WebCam Textures are textures onto which the live video input is rendered.</summary>
    </member>
    <member name="T:UnityEngine.WebGLInput">
      <summary>WebGLInput provides support for WebGL-specific functionalities.</summary>
    </member>
    <member name="T:UnityEngine.WheelCollider">
      <summary>
        <para>A special collider for vehicle wheels.</para>
        <para>Wheel collider is used to model vehicle wheels. It simulates a spring and damper suspension setup, and uses a slip based tire friction model to calculate wheel contact forces.Wheel's collision detection is performed by casting a ray from <see cref="P:UnityEngine.WheelCollider.center" /> downwards the local y-axis. The wheel has a <see cref="P:UnityEngine.WheelCollider.radius" /> and can extend downwards by <see cref="P:UnityEngine.WheelCollider.suspensionDistance" /> amount.The wheel is controlled with <see cref="P:UnityEngine.WheelCollider.motorTorque" />, <see cref="P:UnityEngine.WheelCollider.brakeTorque" /> and <see cref="P:UnityEngine.WheelCollider.steerAngle" /> properties.Wheel collider computes friction separately from the rest of physics engine, using a slip based friction model. This allows for more realistic behaviour, but makes wheel colliders ignore standard <see cref="T:UnityEngine.PhysicMaterial" /> settings. Simulation of different road materials is done by changing the <see cref="P:UnityEngine.WheelCollider.forwardFriction" /> and <see cref="P:UnityEngine.WheelCollider.sidewaysFriction" /> based on what material the wheel is hitting.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WheelFrictionCurve">
      <summary>
        <para>WheelFrictionCurve is used by the <see cref="T:UnityEngine.WheelCollider" /> to describe friction properties of the wheel tire.</para>
        <para>The curve takes a measure of tire slip as an input and gives a force as output. The curve is approximated by a two-piece spline. The first section goes from <c>(0,0)</c> to <c>(extremumSlip,extremumValue)</c>, at which point the curve's tangent is zero. The second section goes from <c>(extremumSlip,extremumValue)</c> to <c>(asymptoteSlip,asymptoteValue)</c>, where curve's tangent is again zero:Wheel collider computes friction separately from the rest of physics engine, using a slip based friction model. It separates the overall friction force into a "forwards" component (in the direction of rolling, and responsible for acceleration and braking) and "sideways" component (orthogonal to rolling, responsible for keeping the car oriented). Tire friction is described separately in these directions using <see cref="P:UnityEngine.WheelCollider.forwardFriction" /> and <see cref="P:UnityEngine.WheelCollider.sidewaysFriction" />. In both directions it is first determined how much the tire is slipping (what is the speed difference between the rubber and the road). Then this slip value is used to find out tire force exerted on the contact.The property of real tires is that for low slip they can exert high forces as the rubber compensates for the slip by stretching. Later when the slip gets really high, the forces are reduced as the tire starts to slide or spin. Thus tire friction curves have a shape like in the image above.Because the friction for the tires is computed separately, the <see cref="T:UnityEngine.PhysicMaterial" /> of the ground does not affect the wheels. Simulation of different road materials is done by changing the WheelCollider.forwardFriction and WheelCollider.sidewaysFriction of the wheel, based on what material the wheel is hitting.See Also: <see cref="T:UnityEngine.WheelCollider" />, <see cref="P:UnityEngine.WheelCollider.forwardFriction" />, <see cref="P:UnityEngine.WheelCollider.sidewaysFriction" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WheelHit">
      <summary>
        <para>Contact information for the wheel, reported by <see cref="T:UnityEngine.WheelCollider" />.</para>
        <para>Friction for the <see cref="T:UnityEngine.WheelCollider" /> is computed separately from the rest of the physics, using a slip based tire friction model. This allows for more realistic behaviour, but makes wheel colliders ignore standard <see cref="T:UnityEngine.PhysicMaterial" /> settings.The way to simulate different ground materials is to query <see cref="T:UnityEngine.WheelCollider" /> for its collision information (see <see cref="M:UnityEngine.WheelCollider.GetGroundHit(UnityEngine.WheelHit@)" />). Usually, you get the other collider the wheel is hitting, and modify the wheel's <see cref="P:UnityEngine.WheelCollider.forwardFriction" /> and <see cref="P:UnityEngine.WheelCollider.sidewaysFriction" /> based on the physic material of the ground.The other members of the WheelHit structure are usually queried for information purposes or special effects. For example, a "slipping tire" sound can be played if <see cref="P:UnityEngine.WheelHit.forwardSlip" /> or <see cref="P:UnityEngine.WheelHit.sidewaysSlip" /> exceed some threshold.See Also: <see cref="M:UnityEngine.WheelCollider.GetGroundHit(UnityEngine.WheelHit@)" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WheelJoint2D">
      <summary>The wheel joint allows the simulation of wheels by providing a constraining suspension motion with an optional motor.</summary>
    </member>
    <member name="T:UnityEngine.WindZone">
      <summary>
        <para>Wind Zones add realism to the trees you create by making them wave their branches and leaves as if blown by the wind.</para>
        <para>Note: This only works with trees created by the tree creator or imported from SpeedTree Modeler.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WWW">
      <summary>
        <para>Simple access to web pages.</para>
        <para>This is a small utility module for retrieving the contents of URLs.You start a download in the background by calling <c>WWW(url)</c> which returns a new WWW object.You can inspect the <c>isDone</c> property to see if the download has completed or yield the download object to automatically wait until it is (without blocking the rest of the game).Use it if you want to get some data from a web server for integration with a game such as highscore lists or calling home for some reason. There is also functionality to create textures from images downloaded from the web and to stream &amp; load new web player data files.The WWW class can be used to send both GET and POST requests to the server. The WWW class will use GET by default and POST if you supply a postData parameter.See Also: <see cref="T:UnityEngine.WWWForm" /> for a way to build valid form data for the postData parameter.Note: URLs passed to WWW class must be '%' escaped.Note:http://, https:// and file:// protocols are supported on iPhone. ftp:// protocol support is limited to anonymous downloads only. Other protocols are not supported.Note: When using file protocol on Windows and Windows Store Apps for accessing local files, you have to specify file:/// (with three slashes).Note: The security sandbox present in web-player builds prevents you from accessing content not hosted the server where the webplayer is hosted.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WWWForm">
      <summary>
        <para>Helper class to generate form data to post to web servers using the <see cref="T:UnityEngine.WWW" /> class.</para>
        <para>Here is a sample script that retrieves the high scores stored in a table in an SQL database.</para>
        <para>Here is a sample Perl script that processes the high scores stored in a table in an SQL database.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.YieldInstruction">
      <summary>Base class for all <c>yield</c> instructions.</summary>
    </member>
    <member name="T:UnityEngine.AndroidActivityIndicatorStyle">
      <summary>ActivityIndicator Style (Android Specific).</summary>
    </member>
    <member name="T:UnityEngine.AnimationBlendMode">
      <summary>Used by <see cref="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)" /> function.</summary>
    </member>
    <member name="T:UnityEngine.AnimationCullingType">
      <summary>
        <para>This enum controlls culling of Animation component.</para>
        <para>When culling is enabled, Unity might stop animating if it thinks that the results of the animation won't be visible to the user. This could save you some performance if you have things animating outside of the viewport, whose animation is only important when the user can actually see the thing that is being animated. When Animation component is culled it won't do anything: it won't update animation states, execute events or sample animations.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorControllerParameterType">
      <summary>
        <para>The type of the parameter.</para>
        <para>Can be bool, float, int or trigger.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorCullingMode">
      <summary>Culling mode for the Animator.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorRecorderMode">
      <summary>
        <para>The mode of the Animator's recorder.</para>
        <para>The recorder can either be Offline, in Playback or in Record.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorUpdateMode">
      <summary>The update mode of the Animator.</summary>
    </member>
    <member name="T:UnityEngine.AnisotropicFiltering">
      <summary>Anisotropic filtering mode.</summary>
    </member>
    <member name="T:UnityEngine.ApplicationInstallMode">
      <summary>Application installation mode (Read Only).</summary>
    </member>
    <member name="T:UnityEngine.ApplicationSandboxType">
      <summary>Application sandbox type.</summary>
    </member>
    <member name="T:UnityEngine.AudioClipLoadType">
      <summary>
        <para>Determines how the audio clip is loaded in.</para>
        <para>Determines whether the audio clip will be either loaded in memory in compressed form, such that every playback will decode the data on the fly ("CompressedInMemory"), decompressed at scene startup such that the clip can be played back at very low CPU usage and the audio data in ir can be modified ("DecompressOnLoad"), or streamed directly from the disk which will typically result in the lowest memory usage, as only the data for a short stream buffer needs to be kept in memory ("Streaming").</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioCompressionFormat">
      <summary>
        <para>An enum containing different compression types.</para>
        <para>This enum is used within the AudioImporter to define what type of compression will be used for an imported AudioClip.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioDataLoadState">
      <summary>Value describing the current load state of the audio data associated with an AudioClip.</summary>
    </member>
    <member name="T:UnityEngine.AudioReverbPreset">
      <summary>
        <para>Reverb presets used by the Reverb Zone class and the audio reverb filter.</para>
        <para>Component for audio sources.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioRolloffMode">
      <summary>Rolloff modes that a 3D sound can have in an audio source.</summary>
    </member>
    <member name="T:UnityEngine.AudioSourceCurveType">
      <summary>
        <para>This defines the curve type of the different custom curves that can be queried and set within the AudioSource.</para>
        <para>The AudioSource can hold a number of custom distance curves, this enum is used within the AudioSource API to differentiate between them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioSpeakerMode">
      <summary>
        <para>These are speaker types defined for use with <see cref="P:UnityEngine.AudioSettings.speakerMode" />.</para>
        <para>Your project's default speaker mode can be set in the Audiomanager through Edit-&gt;Project Settings-&gt;Audio.See Also: <see cref="T:UnityEngine.AudioSettings" />, Audio Manager.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioType">
      <summary>Type of the imported(native) data.</summary>
    </member>
    <member name="T:UnityEngine.AudioVelocityUpdateMode">
      <summary>Describes when an <see cref="T:UnityEngine.AudioSource" /> or <see cref="T:UnityEngine.AudioListener" /> is updated.</summary>
    </member>
    <member name="T:UnityEngine.AvatarIKGoal">
      <summary>
        <para>IK Goal.</para>
        <para>Used to set and get IK weights, position and rotation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AvatarIKHint">
      <summary>
        <para>IK Hint.</para>
        <para>Used to set and get IK weights and position.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AvatarTarget">
      <summary>
        <para>Target.</para>
        <para>Used for the MatchPosition, MatchRotation, and Set functions.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BlendWeights">
      <summary>
        <para>Blend weights.</para>
        <para>How many bones affect each vertex.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CameraClearFlags">
      <summary>Values for Camera.clearFlags, determining what to clear when rendering a <see cref="T:UnityEngine.Camera" />.</summary>
    </member>
    <member name="T:UnityEngine.CameraType">
      <summary>Describes different types of camera.</summary>
    </member>
    <member name="T:UnityEngine.CollisionDetectionMode">
      <summary>The collision detection mode constants used for <see cref="P:UnityEngine.Rigidbody.collisionDetectionMode" />.</summary>
    </member>
    <member name="T:UnityEngine.CollisionDetectionMode2D">
      <summary>Controls how collisions are detected when a <see cref="T:UnityEngine.Rigidbody2D" /> moves.</summary>
    </member>
    <member name="T:UnityEngine.CollisionFlags">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ColorSpace">
      <summary>Valid color spaces.</summary>
    </member>
    <member name="T:UnityEngine.ComputeBufferType">
      <summary>
        <see cref="T:UnityEngine.ComputeBuffer" /> type.</summary>
    </member>
    <member name="T:UnityEngine.ConfigurableJointMotion">
      <summary>Constrains movement for a <see cref="T:UnityEngine.ConfigurableJoint" /> along the 6 axes.</summary>
    </member>
    <member name="T:UnityEngine.ConnectionTesterStatus">
      <summary>The various test results the connection tester may return with.</summary>
    </member>
    <member name="T:UnityEngine.CubemapFace">
      <summary>
        <para>
          <see cref="T:UnityEngine.Cubemap" /> face.</para>
        <para>Used by Cubemap.GetPixel and Cubemap.SetPixel.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CursorLockMode">
      <summary>How the cursor should behave.</summary>
    </member>
    <member name="T:UnityEngine.CursorMode">
      <summary>How should the custom cursor be rendered.</summary>
    </member>
    <member name="T:UnityEngine.DepthTextureMode">
      <summary>
        <para>Depth texture generation mode for <see cref="T:UnityEngine.Camera" />.</para>
        <para>The flags can be combined, so you can set a Camera to generate both a Depth and Depth+Normals texture if needed.See Also: Using camera's depth textures, <see cref="P:UnityEngine.Camera.depthTextureMode" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DetailRenderMode">
      <summary>Render mode for detail prototypes.</summary>
    </member>
    <member name="T:UnityEngine.DeviceOrientation">
      <summary>
        <para>Describes physical orientation of the device as determined by the OS.</para>
        <para>If device is physically situated between discrete positions, as when (for example) rotated diagonally, system will report Unknown orientation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DeviceType">
      <summary>Enumeration for <see cref="P:UnityEngine.SystemInfo.deviceType" />, denotes a coarse grouping of kinds of devices.</summary>
    </member>
    <member name="T:UnityEngine.DrivenTransformProperties">
      <summary>An enumeration of transform properties that can be driven on a RectTransform by an object.</summary>
    </member>
    <member name="T:UnityEngine.EffectorForceMode2D">
      <summary>The mode used to apply <see cref="T:UnityEngine.Effector2D" /> forces.</summary>
    </member>
    <member name="T:UnityEngine.EffectorSelection2D">
      <summary>Selects the source and/or target to be used by an <see cref="T:UnityEngine.Effector2D" />.</summary>
    </member>
    <member name="T:UnityEngine.EventModifiers">
      <summary>Types of modifier key that can be active during a keystroke event.</summary>
    </member>
    <member name="T:UnityEngine.EventType">
      <summary>Types of UnityGUI input and processing events.</summary>
    </member>
    <member name="T:UnityEngine.FFTWindow">
      <summary>
        <para>Spectrum analysis windowing types.</para>
        <para>Use this to reduce leakage of signals across frequency bands.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FilterMode">
      <summary>Filtering mode for textures. Corresponds to the settings in a texture inspector.</summary>
    </member>
    <member name="T:UnityEngine.FocusType">
      <summary>Used by GUIUtility.GetControlID to inform the UnityGUI system if a given control can get keyboard focus.</summary>
    </member>
    <member name="T:UnityEngine.FogMode">
      <summary>Fog mode to use.</summary>
    </member>
    <member name="T:UnityEngine.FontStyle">
      <summary>Font Style applied to GUI Texts, Text Meshes or GUIStyles.</summary>
    </member>
    <member name="T:UnityEngine.ForceMode">
      <summary>Option for how to apply a force using <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</summary>
    </member>
    <member name="T:UnityEngine.ForceMode2D">
      <summary>Option for how to apply a force using <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />.</summary>
    </member>
    <member name="T:UnityEngine.FullScreenMovieControlMode">
      <summary>Describes options for displaying movie playback controls.</summary>
    </member>
    <member name="T:UnityEngine.FullScreenMovieScalingMode">
      <summary>Describes scaling modes for displaying movies.</summary>
    </member>
    <member name="T:UnityEngine.HideFlags">
      <summary>Bit mask that controls object destruction, saving and visibility in inspectors.</summary>
    </member>
    <member name="T:UnityEngine.HorizontalWrapMode">
      <summary>Wrapping modes for text that reaches the horizontal boundary.</summary>
    </member>
    <member name="T:UnityEngine.HumanBodyBones">
      <summary>Human Body Bones.</summary>
    </member>
    <member name="T:UnityEngine.ImagePosition">
      <summary>How image and text is placed inside <see cref="T:UnityEngine.GUIStyle" />.</summary>
    </member>
    <member name="T:UnityEngine.IMECompositionMode">
      <summary>Controls IME input.</summary>
    </member>
    <member name="T:UnityEngine.JointDriveMode">
      <summary>The <see cref="T:UnityEngine.ConfigurableJoint" /> attempts to attain position / velocity targets based on this flag.</summary>
    </member>
    <member name="T:UnityEngine.JointLimitState2D">
      <summary>Represents the state of a joint limit.</summary>
    </member>
    <member name="T:UnityEngine.JointProjectionMode">
      <summary>Determines how to snap physics joints back to its constrained position when it drifts off too much.</summary>
    </member>
    <member name="T:UnityEngine.KeyCode">
      <summary>Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.</summary>
    </member>
    <member name="T:UnityEngine.LightmapsMode">
      <summary>Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.</summary>
    </member>
    <member name="T:UnityEngine.LightmapsModeLegacy">
      <summary>Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy</summary>
    </member>
    <member name="T:UnityEngine.LightRenderMode">
      <summary>How the <see cref="T:UnityEngine.Light" /> is rendered.</summary>
    </member>
    <member name="T:UnityEngine.LightShadows">
      <summary>Shadow casting options for a <see cref="T:UnityEngine.Light" />.</summary>
    </member>
    <member name="T:UnityEngine.LightType">
      <summary>The type of a <see cref="T:UnityEngine.Light" />.</summary>
    </member>
    <member name="T:UnityEngine.LocationServiceStatus">
      <summary>Describes location service status.</summary>
    </member>
    <member name="T:UnityEngine.LODFadeMode">
      <summary>The LOD fade modes. Modes other than <see cref="F:UnityEngine.LODFadeMode.None" /> will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.</summary>
    </member>
    <member name="T:UnityEngine.LogType">
      <summary>The type of the log message in the delegate registered with Application.RegisterLogCallback.</summary>
    </member>
    <member name="T:UnityEngine.MasterServerEvent">
      <summary>Describes status messages from the master server as returned in <see href="MonoBehaviour.OnMasterServerEvent" cref="OnMasterServerEvent" />.</summary>
    </member>
    <member name="T:UnityEngine.MaterialGlobalIlluminationFlags">
      <summary>How the material should interact with lightmaps and lightprobes.</summary>
    </member>
    <member name="T:UnityEngine.MeshTopology">
      <summary>
        <para>Topology of <see cref="T:UnityEngine.Mesh" /> faces.</para>
        <para>Normally meshes are composed of triangles (three vertex indices per face), but in some cases you might want to render complex things that are made up from lines or points. Creating a <see cref="T:UnityEngine.Mesh" /> with that topology and using it to render is usually the most efficient way.See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NavMeshObstacleShape">
      <summary>Shape of the obstacle.</summary>
    </member>
    <member name="T:UnityEngine.NavMeshPathStatus">
      <summary>Status of path.</summary>
    </member>
    <member name="T:UnityEngine.NetworkConnectionError">
      <summary>
        <para>Possible status messages returned by Network.Connect and in <c>OnFailedToConnect</c> in case the error was not immediate.</para>
        <para>Also used by the <see cref="T:UnityEngine.MasterServer" /> in <c>OnFailedToConnectToMasterServer</c>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkDisconnection">
      <summary>The reason a disconnect event occured, like in <see href="MonoBehaviour.OnDisconnectedFromServer" cref="OnDisconnectedFromServer" />.</summary>
    </member>
    <member name="T:UnityEngine.NetworkLogLevel">
      <summary>Describes different levels of log information the network layer supports.</summary>
    </member>
    <member name="T:UnityEngine.NetworkPeerType">
      <summary>Describes the status of the network interface peer type as returned by Network.peerType.</summary>
    </member>
    <member name="T:UnityEngine.NetworkReachability">
      <summary>Describes network reachability options.</summary>
    </member>
    <member name="T:UnityEngine.NetworkStateSynchronization">
      <summary>Different types of synchronization for the <see cref="T:UnityEngine.NetworkView" /> component.</summary>
    </member>
    <member name="T:UnityEngine.NPOTSupport">
      <summary>NPOT <see cref="T:UnityEngine.Texture2D" /> support.</summary>
    </member>
    <member name="T:UnityEngine.ObstacleAvoidanceType">
      <summary>Level of obstacle avoidance.</summary>
    </member>
    <member name="T:UnityEngine.OffMeshLinkType">
      <summary>Link type specifier.</summary>
    </member>
    <member name="T:UnityEngine.ParticleRenderMode">
      <summary>
        <para>The rendering mode for legacy particles.</para>
        <para>This is used by the <see cref="T:UnityEngine.ParticleRenderer" /> to determine how to render the particles.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ParticleSystemRenderMode">
      <summary>
        <para>The rendering mode for particle systems (Shuriken).</para>
        <para>This is used by the <see cref="T:UnityEngine.ParticleSystemRenderer" /> to determine how to render the particles.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ParticleSystemSimulationSpace">
      <summary>The space to simulate particles in.</summary>
    </member>
    <member name="T:UnityEngine.PhysicMaterialCombine">
      <summary>Describes how physic materials of colliding objects are combined.</summary>
    </member>
    <member name="T:UnityEngine.PlayMode">
      <summary>Used by <see cref="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)" /> function.</summary>
    </member>
    <member name="T:UnityEngine.PrimitiveType">
      <summary>The various primitives that can be created using the GameObject.CreatePrimitive function.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralCacheSize">
      <summary>
        <para>Substance memory budget.</para>
        <para>This also affects the amount of working memory for the generation of the ProceduralMaterial.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ProceduralLoadingBehavior">
      <summary>ProceduralMaterial loading behavior.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralOutputType">
      <summary>The type of generated image in a ProceduralMaterial.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralProcessorUsage">
      <summary>
        <para>The global Substance engine processor usage (as used for the ProceduralMaterial.substanceProcessorUsage property).</para>
        <para>The values refer to the number of physical processor cores used for ProceduralMaterial generation.See Also: <see cref="P:UnityEngine.ProceduralMaterial.substanceProcessorUsage" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ProceduralPropertyType">
      <summary>The type of a ProceduralProperty.</summary>
    </member>
    <member name="T:UnityEngine.QueryTriggerInteraction">
      <summary>Overrides the global <see cref="P:UnityEngine.Physics.queriesHitTriggers" />.</summary>
    </member>
    <member name="T:UnityEngine.QueueMode">
      <summary>Used by <see cref="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)" /> function.</summary>
    </member>
    <member name="T:UnityEngine.RectTransform.Axis">
      <summary>An axis that can be horizontal or vertical.</summary>
    </member>
    <member name="T:UnityEngine.RectTransform.Edge">
      <summary>Enum used to specify one edge of a rectangle.</summary>
    </member>
    <member name="T:UnityEngine.RenderingPath">
      <summary>Rendering path of a <see cref="T:UnityEngine.Camera" />.</summary>
    </member>
    <member name="T:UnityEngine.RenderMode">
      <summary>RenderMode for the Canvas.</summary>
    </member>
    <member name="T:UnityEngine.RenderTextureFormat">
      <summary>Format of a <see cref="T:UnityEngine.RenderTexture" />.</summary>
    </member>
    <member name="T:UnityEngine.RenderTextureReadWrite">
      <summary>Color space conversion mode of a <see cref="T:UnityEngine.RenderTexture" />.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyConstraints">
      <summary>Use these flags to constrain motion of Rigidbodies.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyConstraints2D">
      <summary>Use these flags to constrain motion of the <see cref="T:UnityEngine.Rigidbody2D" />.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyInterpolation">
      <summary>
        <para>
          <see cref="T:UnityEngine.Rigidbody" /> interpolation mode.</para>
        <para>For the main characters or vehicles that are followed by the camera it is recommended to use interpolation. For any other rigidbodies it is recommended not to use interpolation.See Also: <see cref="P:UnityEngine.Rigidbody.interpolation" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RigidbodyInterpolation2D">
      <summary>Interpolation mode for Rigidbody2D objects.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodySleepMode2D">
      <summary>Settings for a Rigidbody2D's initial sleep state.</summary>
    </member>
    <member name="T:UnityEngine.RotationDriveMode">
      <summary>Control <see cref="T:UnityEngine.ConfigurableJoint" />'s rotation with either X &amp; YZ or Slerp Drive.</summary>
    </member>
    <member name="T:UnityEngine.RPCMode">
      <summary>Option for who will receive an RPC, used by NetworkView.RPC.</summary>
    </member>
    <member name="T:UnityEngine.RuntimeInitializeLoadType">
      <summary>Set RuntimeInitializeOnLoadMethod type.</summary>
    </member>
    <member name="T:UnityEngine.RuntimePlatform">
      <summary>
        <para>The platform application is running. Returned by Application.platform.</para>
        <para>Note: The difference between using RuntimePlatform and Platform dependent Compilation is that using RuntimePlatform is evaluated at runtime while Platform dependent Compilation is evaluated at compile time. So if you can use platform dependent compilation, don't hesitate to use it. In most cases, you can get the same functionality using both, and using the defines will produce smaller and faster code, as you don't need to check at runtime. There are some cases where RuntimePlatform is needed, for example: if you need to check which platform you are running a webplayer you may check this at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SamsungTV.GamePadMode">
      <summary>Types of input the gamepad can produce.</summary>
    </member>
    <member name="T:UnityEngine.SamsungTV.GestureMode">
      <summary>Types of input the gesture camera can produce.</summary>
    </member>
    <member name="T:UnityEngine.SamsungTV.TouchPadMode">
      <summary>Types of input the remote's touchpad can produce.</summary>
    </member>
    <member name="T:UnityEngine.ScaleMode">
      <summary>Scaling mode to draw textures with.</summary>
    </member>
    <member name="T:UnityEngine.ScreenOrientation">
      <summary>
        <para>Describes screen orientation.</para>
        <para>Currently this is only relevant on mobile devices.See Also: Screen.orientation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SendMessageOptions">
      <summary>
        <para>Options for how to send a message.</para>
        <para>This is used by SendMessage &amp; BroadcastMessage in <see cref="T:UnityEngine.GameObject" /> &amp; <see cref="T:UnityEngine.Component" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShadowProjection">
      <summary>Shadow projection type for Quality Settings.</summary>
    </member>
    <member name="T:UnityEngine.SkinQuality">
      <summary>The maximum number of bones affecting a single vertex.</summary>
    </member>
    <member name="T:UnityEngine.Space">
      <summary>The coordinate space in which to operate.</summary>
    </member>
    <member name="T:UnityEngine.SpriteAlignment">
      <summary>How a Sprite's graphic rectangle is aligned with its pivot point.</summary>
    </member>
    <member name="T:UnityEngine.SpriteMeshType">
      <summary>Defines the type of mesh generated for a sprite.</summary>
    </member>
    <member name="T:UnityEngine.SpritePackingMode">
      <summary>Sprite packing modes for the Sprite Packer.</summary>
    </member>
    <member name="T:UnityEngine.SpritePackingRotation">
      <summary>Sprite rotation modes for the Sprite Packer.</summary>
    </member>
    <member name="T:UnityEngine.StackTraceLogType">
      <summary>Stack trace logging options.</summary>
    </member>
    <member name="T:UnityEngine.SystemLanguage">
      <summary>The language the user's operating system is running in. Returned by Application.systemLanguage.</summary>
    </member>
    <member name="T:UnityEngine.Terrain.MaterialType">
      <summary>The type of the material used to render a terrain object. Could be one of the built-in types or custom.</summary>
    </member>
    <member name="T:UnityEngine.TerrainRenderFlags">
      <summary>Enum provding terrain rendering options.</summary>
    </member>
    <member name="T:UnityEngine.TextAlignment">
      <summary>
        <para>How multiline text should be aligned.</para>
        <para>This is used by the <see cref="P:UnityEngine.GUIText.alignment" /> property.See Also: GUI Text component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextAnchor">
      <summary>
        <para>Where the anchor of the text is placed.</para>
        <para>This is used by <see cref="P:UnityEngine.GUIText.anchor" /> property.See Also: GUI Text component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextClipping">
      <summary>Different methods for how the GUI system handles text being too large to fit the rectangle allocated.</summary>
    </member>
    <member name="T:UnityEngine.TextureCompressionQuality">
      <summary>
        <para>Compression Quality.</para>
        <para>Corresponds to the settings in a texture inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextureFormat">
      <summary>
        <para>Format used when creating textures from scripts.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.See Also: <see cref="T:UnityEngine.Texture2D" />, texture assets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextureWrapMode">
      <summary>
        <para>Wrap mode for textures.</para>
        <para>Corresponds to the settings in a texture inspector. You can either Tile the texture (Repeat) or map a single texture on the object (Clamp)See Also: <see cref="P:UnityEngine.Texture.wrapMode" />, texture assets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ThreadPriority">
      <summary>
        <para>Priority of a thread.</para>
        <para>Lower priority means a background operation will run less often and will take up less time, but will progress more slowly.See Also: <see cref="P:UnityEngine.Application.backgroundLoadingPriority" />, <see cref="P:UnityEngine.WWW.threadPriority" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TouchPhase">
      <summary>Describes phase of a finger touch.</summary>
    </member>
    <member name="T:UnityEngine.TouchScreenKeyboardType">
      <summary>Describes the type of keyboard.</summary>
    </member>
    <member name="T:UnityEngine.TransparencySortMode">
      <summary>
        <para>Transparent object sorting mode of a <see cref="T:UnityEngine.Camera" />.</para>
        <para>By default, perspective cameras sort objects based on distance from camera position to the object center; and orthographic cameras sort based on distance along the view direction.If you're making a 2D game with a perspective camera, you might want to use <see cref="F:UnityEngine.TransparencySortMode.Orthographic" /> sort mode so that objects are sorted based on distance along the camera's view.See Also: <see cref="P:UnityEngine.Camera.transparencySortMode" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.UserAuthorization">
      <summary>Constants to pass to <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" />.</summary>
    </member>
    <member name="T:UnityEngine.VerticalWrapMode">
      <summary>Wrapping modes for text that reaches the vertical boundary.</summary>
    </member>
    <member name="T:UnityEngine.WindZoneMode">
      <summary>
        <para>Modes a Wind Zone can have, either Spherical or Directional.</para>
        <para>You can have more than one Spherical Wind Zone in a scene, but it does not make much sense to have more than one Directional Wind Zone in your scene as it affects the whole scene. This Wind Zone Mode is used by the WindZone.mode member.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WrapMode">
      <summary>
        <para>Determines how time is treated outside of the keyframed range of an <see cref="T:UnityEngine.AnimationClip" /> or <see cref="T:UnityEngine.AnimationCurve" />.</para>
        <para>The WrapMode that the animation system uses for a specific animation is determined this way: You can set the WrapMode of an <see cref="T:UnityEngine.AnimationClip" /> in the import settings of the clip. This is the recommended way to control the WrapMode. When an <see cref="T:UnityEngine.AnimationState" /> is created, it inherits its WrapMode from the <see cref="T:UnityEngine.AnimationClip" /> it is created from, but you can also change it from code. If the WrapMode of an <see cref="T:UnityEngine.AnimationState" /> is set to Default, the animation system will use the WrapMode from the <see cref="T:UnityEngine.Animation" /> component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AddComponentMenu">
      <summary>
        <para>The AddComponentMenu attribute allows you to place a script anywhere in the "Component" menu, instead of just the "Component-&gt;Scripts" menu.</para>
        <para>You use this to organize the Component menu better, this way improving workflow when adding scripts. Important notice: You need to restart.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssemblyIsEditorAssembly">
      <summary>Assembly level attribute. Any classes in an assembly with this attribute will be considered to be Editor Classes.</summary>
    </member>
    <member name="T:UnityEngine.ColorUsageAttribute">
      <summary>
        <para>Attribute used to configure the usage of the ColorField and Color Picker for a color.</para>
        <para>Use this attribute on a Color to configure the Color Field and Color Picker to show/hide the alpha value and whether to treat the color as a HDR color or as a normal LDR color.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContextMenu">
      <summary>
        <para>The ContextMenu attribute allows you to add commands to the context menu.</para>
        <para>In the inspector of the attached script. When the user selects the context menu, the function will be executed.This is most useful for automatically setting up scene data from the script. The function has to be non-static.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContextMenuItemAttribute">
      <summary>Use this attribute to add a context menu to a field that calls a named method.</summary>
    </member>
    <member name="T:UnityEngine.CreateAssetMenuAttribute">
      <summary>Mark a ScriptableObject-derived type to be automatically listed in the Assets/Create submenu, so that instances of the type can be easily created and stored in the project as ".asset" files.</summary>
    </member>
    <member name="T:UnityEngine.DisallowMultipleComponent">
      <summary>Prevents MonoBehaviour of same type (or subtype) to be added more than once to a GameObject.</summary>
    </member>
    <member name="T:UnityEngine.ExecuteInEditMode">
      <summary>
        <para>Makes a script execute in edit mode.</para>
        <para>By default, script components are only executed in play mode. By adding this attribute, each script component will also have its callback functions executed while the Editor is not in playmode.The functions are not called constantly like they are in play mode. - <c>Update</c> is only called when something in the scene changed. - <c>OnGUI</c> is called when the Game View recieves an <see cref="T:UnityEngine.Event" />. - <c>OnRenderObject</c> and the other rendering callback functions are called on every repaint of the Scene View or Game View.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HeaderAttribute">
      <summary>
        <para>Use this <see cref="T:UnityEngine.PropertyAttribute" /> to add a header above some fields in the Inspector.</para>
        <para>The header is done using a <see cref="T:UnityEditor.DecoratorDrawer" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HelpURLAttribute">
      <summary>Provide a custom documentation URL for a class.</summary>
    </member>
    <member name="T:UnityEngine.HideInInspector">
      <summary>Makes a variable not show up in the inspector but be serialized.</summary>
    </member>
    <member name="T:UnityEngine.ImageEffectOpaque">
      <summary>
        <para>Any Image Effect with this attribute will be rendered after opaque geometry but before transparent geometry.</para>
        <para>This allows for effects which extensively use the depth buffer (SSAO, etc) to affect only opaque pixels. This attribute can be used to reduce the amount of visual artifacts in a scene with post processing.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ImageEffectTransformsToLDR">
      <summary>
        <para>When using HDR rendering it can sometime be desirable to switch to LDR rendering during ImageEffect rendering.</para>
        <para>Using this Attribute on an image effect will cause the destination buffer to be an LDR buffer, and switch the rest of the Image Effect pipeline into LDR mode. It is the responsibility of the Image Effect that this Attribute is associated to ensure that the output is in the LDR range.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MultilineAttribute">
      <summary>Attribute to make a string be edited with a multi-line textfield.</summary>
    </member>
    <member name="T:UnityEngine.NotConvertedAttribute">
      <summary>Instructs the build pipeline not to convert a type or member to the target platform.</summary>
    </member>
    <member name="T:UnityEngine.NotFlashValidatedAttribute">
      <summary>Instructs the build pipeline not to try and validate a type or member for the flash platform. (obsolete in Unity 5.0 and above)</summary>
    </member>
    <member name="T:UnityEngine.NotRenamedAttribute">
      <summary>
        <para>Prevent name mangling of constructors, methods, fields and properties.</para>
        <para>When applied to a type prevents all its members of being renamed.It can be used to provide stable member names for access from handwritten ActionScript code or to provide .net stubs for ActionScript types when combined with <see cref="T:UnityEngine.NotConvertedAttribute" />:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PropertyAttribute">
      <summary>
        <para>Base class to derive custom property attributes from. Use this to create custom attributes for script variables.</para>
        <para>A custom attributes can be hooked up with a custom <see cref="T:UnityEditor.PropertyDrawer" /> class to control how a script variable with that attribute is shown in the Inspector.See Also: <see cref="T:UnityEditor.PropertyDrawer" /> class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RangeAttribute">
      <summary>
        <para>Attribute used to make a float or int variable in a script be restricted to a specific range.</para>
        <para>When this attribute is used, the float or int will be shown as a slider in the Inspector instead of the default number field.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RequireComponent">
      <summary>
        <para>The RequireComponent attribute lets automatically add required component as a dependency.</para>
        <para>When you add a script which uses RequireComponent, the required component will automatically be added to the game object. This is useful to avoid setup errors. For example a script might require that a rigid body is always added to the same game object. Using RequireComponent this will be done automatically, thus you can never get the setup wrong.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RPC">
      <summary>
        <para>Attribute for setting up RPC functions.</para>
        <para>Given an @RPC (javascript) or [RPC] attribute (C#) any function can be called remotely through Unity Networking. The function must exist on both sending and recieving party.See Also: NetworkView.RPC.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RuntimeInitializeOnLoadMethodAttribute">
      <summary>
        <para>Allow an runtime class method to be initialized when Unity game loads runtime without action from the user.</para>
        <para>Methods marked [RuntimeInitializeOnLoadMethod] are invoked after scene has been loaded (i.e. after Awake method has been invoked). Note: Order of execution of methods marked [RuntimeInitializeOnLoadMethod] is not guaranteed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SelectionBaseAttribute">
      <summary>
        <para>Add this attribute to a script class to mark its GameObject as a selection base object for Scene View picking.</para>
        <para>In the Unity Scene View, when clicking to select objects, Unity will try to figure out the best object to select for you. If you click on an object that is part of a prefab, the root of the prefab is selected, because a prefab root is treated as a selection base. You can make other objects be treated as selection base too. You need to create a script class with the SelectionBase attribute, and then you need to add that script to the GameObject.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SerializeField">
      <summary>
        <para>Force Unity to serialize a private field.</para>
        <para>You will almost never need this. When Unity serializes your scripts, it will only serialize public fields. If in addition to that you also want Unity to serialize one of your private fields you can add the SerializeField attribute to the field. Unity will serialize all your script components, reload the new assemblies, and recreate your script components from the serialized verions. This serialization does not happen with .NET's serialization functionality, but with an internal Unity one.The serialization system used can do the following:- CAN serialize public nonstatic fields (of serializable types) - CAN serialize nonpublic nonstatic fields marked with the [SerializeField] attribute. - CANNOT serialize static fields. - CANNOT serialize properties.Your field will only serialize if it is of a type that Unity can serialize:Serializable types are:- All classes inheriting from UnityEngine.Object, for example GameObject, Component, MonoBehaviour, Texture2D, AnimationClip. - All basic data types like int, string, float, bool. - Some built-in types like Vector2, Vector3, Vector4, Quaternion, Matrix4x4, Color, Rect, LayerMask. - Arrays of a serializable type - List of a serializable type) - Enums - StructsNote: if you put one element in a list (or array) twice, when the list gets serialized, you'll get two copies of that element, instead of one copy being in the new list twice.Hint: Unity won't serialize Dictionary, however you could store a List&lt;&gt; for keys and a List&lt;&gt; for values, and sew them up in a non serialized dictionary on Awake(). This doesn't solve the problem of when you want to modify the dictionary and have it "saved" back, but it is a handy trick in a lot of other cases.For UnityScript users: Fields in c# is a script variable in UnityScript, and [SerializeField] becomes @SerializeField. [Serializable] on a class becomes @script Serializable in a UnityScript.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SharedBetweenAnimatorsAttribute">
      <summary>
        <para>SharedBetweenAnimatorsAttribute is an attribute that specify that this StateMachineBehaviour should be instantiate only once and shared among all Animator instance. This attribute reduce the memory footprint for each controller instance.</para>
        <para>It's up to the programmer to choose which StateMachineBehaviour could use this attribute. Be aware that if your StateMachineBehaviour change some member variable it will affect all other Animator instance using it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpaceAttribute">
      <summary>
        <para>Use this <see cref="T:UnityEngine.PropertyAttribute" /> to add some spacing in the Inspector.</para>
        <para>The spacing is done using a <see cref="T:UnityEditor.DecoratorDrawer" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextAreaAttribute">
      <summary>
        <para>Attribute to make a string be edited with a height-flexible and scrollable text area.</para>
        <para>You can specify the minimum and maximum lines for the TextArea, and the field will expand according to the size of the text. A scrollbar will appear if the text is bigger than the area available.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TooltipAttribute">
      <summary>Specify a tooltip for a field.</summary>
    </member>
    <member name="T:UnityEngine.UnityAPICompatibilityVersionAttribute">
      <summary>Declares an assembly to be compatible (API wise) with a specific Unity API. Used by internal tools to avoid processing the assembly in order to decide whether assemblies may be using old Unity API.</summary>
    </member>
    <member name="T:UnityEngine.Sprites.Packer.Execution">
      <summary>Sprite Packer execution mode.</summary>
    </member>
    <member name="T:UnityEngine.VersionControl.Asset.States">
      <summary>Describes the various version control states an asset can have.</summary>
    </member>
    <member name="T:UnityEngine.VersionControl.Message.Severity">
      <summary>Severity of a version control message.</summary>
    </member>
    <member name="T:UnityEngine.AnimationUtility.CurveModifiedType">
      <summary>Describes the type of modification that caused OnCurveWasModified to fire.</summary>
    </member>
    <member name="T:UnityEngine.Lightmapping.GIWorkflowMode">
      <summary>Workflow mode for lightmap baking. Default is Iterative.</summary>
    </member>
    <member name="T:UnityEngine.MaterialProperty.PropFlags">
      <summary>Flags that control how a <see cref="T:UnityEditor.MaterialProperty" /> is displayed.</summary>
    </member>
    <member name="T:UnityEngine.MaterialProperty.PropType">
      <summary>
        <para>Material property type.</para>
        <para>Material properties can be textures, colors, floats and so on.See Also: <see cref="P:UnityEditor.MaterialProperty.type" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MaterialProperty.TexDim">
      <summary>
        <para>Texture dimension of a property.</para>
        <para>Texture properties can accept regular (2D) textures, Cubemaps etc.See Also: <see cref="P:UnityEditor.MaterialProperty.textureDimension" />.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.Nintendo3DS.LogoStyle">
      <summary>Nintendo 3DS logo style specification.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize">
      <summary>Nintendo 3DS distribution media size.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.Nintendo3DS.Region">
      <summary>Nintendo 3DS Title region.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.Nintendo3DS.TargetPlatform">
      <summary>Nintendo 3DS target platform.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PS4.PS4AppCategory">
      <summary>PS4 application category.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PS4.PS4EnterButtonAssignment">
      <summary>PS4 enter button assignment.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment">
      <summary>Remote Play key assignment.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaAppCategory">
      <summary>Application package category enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaDRMType">
      <summary>DRM type enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaEnterButtonAssignment">
      <summary>Enter button assignment enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaMemoryExpansionMode">
      <summary>Memory expansion mode enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaPowerMode">
      <summary>Power mode enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.PSVita.PSVitaTvBootMode">
      <summary>PS Vita TV boot mode enum.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories">
      <summary>Types of available product categories.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.TizenCapability">
      <summary>Tizen application capabilities.</summary>
    </member>
    <member name="T:UnityEngine.PlayerSettings.WSACompilationOverrides">
      <summary>Compilation overrides for C# files.</summary>
    </member>
    <member name="T:UnityEngine.ShaderUtil.ShaderPropertyTexDim">
      <summary>Representation of the texture dimensions.</summary>
    </member>
    <member name="T:UnityEngine.ShaderUtil.ShaderPropertyType">
      <summary>Type of a given texture property.</summary>
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.Initialize(System.String)">
      <summary>Manually initializes the advertisement system. Normally this is done from editor, and you should only call this method if you have disabled UnityAds from the Editor settings in Connect window.</summary>
      <param name="appId">Your game id. You can see a list of your registered games at the UnityAds admin site.</param>
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.Initialize(System.String,System.Boolean)">
      <summary>Manually initializes the advertisement system. Normally this is done from editor, and you should only call this method if you have disabled UnityAds from the Editor settings in Connect window.</summary>
      <param name="appId">Your game id. You can see a list of your registered games at the UnityAds admin site.</param>
      <param name="testMode">In test mode, you will see test advertisement. Can be overruled by settings in the admin site for game.</param>
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.IsReady">
      <summary>Returns whether an advertisement is ready to be shown. Zones are configured per game in the UnityAds admin site, where you can also set your default zone.</summary>
      <seealso cref="M:UnityEngine.Advertisements.Advertisement.Show" />
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.IsReady(System.String)">
      <summary>Returns whether an advertisement is ready to be shown. Zones are configured per game in the UnityAds admin site, where you can also set your default zone.</summary>
      <param name="zoneId">Optional zone identifier. If not specified, your default zone specified in UnityAds server-side admin settings will be used.</param>
      <seealso cref="M:UnityEngine.Advertisements.Advertisement.Show" />
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.Show">
      <summary>Show an advertisement in your project.</summary>
      <seealso cref="M:UnityEngine.Advertisements.Advertisement.IsReady" />
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.Show(System.String)">
      <summary>Show an advertisement in your project.</summary>
      <param name="zoneId">Optional zone identifier. If not specified, your default zone specified in the admin settings will be used.</param>
      <seealso cref="M:UnityEngine.Advertisements.Advertisement.IsReady" />
    </member>
    <member name="M:UnityEngine.Advertisements.Advertisement.Show(System.String,UnityEngine.Advertisements.ShowOptions)">
      <summary>Show an advertisement in your project.</summary>
      <param name="zoneId">Optional zone identifier. If not specified, your default zone specified in the admin settings will be used.</param>
      <param name="options">Specify e.g. callback handler to be called when video has finished.</param>
      <seealso cref="M:UnityEngine.Advertisements.Advertisement.IsReady" />
    </member>
    <member name="F:UnityEngine.Advertisements.Advertisement.DebugLevel.None">
      <summary>Prints out no debugging output.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.Advertisement.DebugLevel.Error">
      <summary>Prints all error messages.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.Advertisement.DebugLevel.Warning">
      <summary>Prints out warnings.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.Advertisement.DebugLevel.Info">
      <summary>Prints all informational messages.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.Advertisement.DebugLevel.Debug">
      <summary>Prints all debugging messages.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.ShowResult.Failed">
      <summary>Indicates that the advertisement failed to complete.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.ShowResult.Skipped">
      <summary>Indicates that the advertisement was skipped.</summary>
    </member>
    <member name="F:UnityEngine.Advertisements.ShowResult.Finished">
      <summary>Indicates that the advertisement completed successfully.</summary>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.CustomEvent(System.String)">
      <summary>
        <para>Custom Events (optional).</para>
        <para>Unity Analytics allows you to track specific events within your game. By configuring a series of Custom Events within your game, you can create your own Funnel Analysis to observe your players' game behavior. Good places to put custom events include: milestones, new levels, scene transitions, etc.In addition to tracking custom events, Unity Analytics also allows you to pass in custom dimensions (dictionary) relating to the event. These custom dimensions are primarily useful to know additional specifications about the user at the time the custom event was reached.</para>
      </summary>
      <param name="customEventName">Name of custom event. Name cannot include the prefix "unity." - This is a reserved keyword.</param>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.SetUserBirthYear(System.Int32)">
      <summary>
        <para>User Demographics (optional).</para>
        <para>Depending on the genre of your project, creating custom segments around gender and age of your users may interest you. Whether you're receiving this information on signup of your project, or from a third-party SDK, eg: Facebook, you can send these demographics to Unity Analytics.</para>
      </summary>
      <param name="birthYear">Birth year of user. Must be 4-digit year format, only.</param>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.SetUserGender(UnityEngine.Analytics.Gender)">
      <summary>
        <para>User Demographics (optional).</para>
        <para>Depending on the genre of your project, creating custom segments around gender and age of your users may interest you. Whether you're receiving this information on signup of your project, or from a third-party SDK, eg: Facebook, you can send these demographics to Unity Analytics.</para>
      </summary>
      <param name="gender">Gender of user can be "Female", "Male", or "Unknown".</param>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.SetUserId(System.String)">
      <summary>User Demographics (optional).</summary>
      <param name="userId">User id.</param>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.Transaction(System.String,System.Decimal,System.String)">
      <summary>
        <para>Tracking Monetization (optional).</para>
        <para>Unity Analytics provides a flexible method for tracking monetization events through in-app purchases. This method should be called every time a player triggers a monetization event.The Transaction method requires a price parameter, a currency and an optional Apple iTunes / Google Play receipt string.</para>
      </summary>
      <param name="productId">The id of the purchased item.</param>
      <param name="amount">The price of the item.</param>
      <param name="currency">Abbreviation of the currency used for the transaction. For example “USD” (United States Dollars). See http://en.wikipedia.org/wiki/ISO_4217 for a standardized list of currency abbreviations.</param>
    </member>
    <member name="M:UnityEngine.Analytics.Analytics.Transaction(System.String,System.Decimal,System.String,System.String,System.String)">
      <summary>
        <para>Tracking Monetization (optional).</para>
        <para>Unity Analytics provides a flexible method for tracking monetization events through in-app purchases. This method should be called every time a player triggers a monetization event.The Transaction method requires a price parameter, a currency and an optional Apple iTunes / Google Play receipt string.</para>
      </summary>
      <param name="productId">The id of the purchased item.</param>
      <param name="amount">The price of the item.</param>
      <param name="currency">Abbreviation of the currency used for the transaction. For example “USD” (United States Dollars). See http://en.wikipedia.org/wiki/ISO_4217 for a standardized list of currency abbreviations.</param>
      <param name="receiptPurchaseData">Receipt data (iOS) / receipt ID (android) / for in-app purchases to verify purchases with Apple iTunes / Google Play. Use null in the absence of receipts.</param>
      <param name="signature">Android receipt signature. If using native Android use the INAPP_DATA_SIGNATURE string containing the signature of the purchase data that was signed with the private key of the developer. The data signature uses the RSASSA-PKCS1-v1_5 scheme. Pass in null in absence of a signature.</param>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.Ok">
      <summary>Analytics API result: Sucess.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.NotInitialized">
      <summary>Analytics API result: Analytics not initialized.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.AnalyticsDisabled">
      <summary>Analytics API result: Analytics is disabled.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.TooManyItems">
      <summary>Analytics API result: Too many parameters.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.SizeLimitReached">
      <summary>Analytics API result: Argument size limit.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.TooManyRequests">
      <summary>Analytics API result: Too many requests.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.InvalidData">
      <summary>Analytics API result: Invalid argument value.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.AnalyticsResult.UnsupportedPlatform">
      <summary>Analytics API result: This platform doesn't support Analytics.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.Gender.Male">
      <summary>User Demographics: Male Gender of a user.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.Gender.Female">
      <summary>User Demographics: Female Gender of a user.</summary>
    </member>
    <member name="F:UnityEngine.Analytics.Gender.Unknown">
      <summary>User Demographics: Unknown Gender of a user.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeApproximatelyEqual(System.Single,System.Single)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeEqual``1(``0,``0)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeEqual``1(``0,``0,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeFalse(System.Boolean)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeFalse(System.Boolean,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeNull``1(``0)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsNull``1(``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeNull``1(``0,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsNull``1(``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeTrue(System.Boolean)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustBeTrue(System.Boolean,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeApproximatelyEqual(System.Single,System.Single)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeEqual``1(``0,``0)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeEqual``1(``0,``0,System.String)">
      <summary>An extension method for <see cref="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0)" />.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeNull``1(``0)">
      <summary>An extension method for Assertions.Assert.AreNotNull.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Must.MustExtensions.MustNotBeNull``1(``0,System.String)">
      <summary>An extension method for Assertions.Assert.AreNotNull.</summary>
    </member>
    <member name="F:UnityEngine.Assertions.Assert.raiseExceptions">
      <summary>
        <para>Should an exception be thrown on a failure.</para>
        <para>If true, an Assertinos.AssertionException will be thrown instead of logging a message. This will break the control flow of the execution.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean)">
      <summary>Asserts that the condition is false.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean,System.String)">
      <summary>Asserts that the condition is false.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNotNull``1(``0)">
      <summary>Asserts that the value is not null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNotNull``1(``0,System.String)">
      <summary>Asserts that the value is not null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNull``1(``0)">
      <summary>Asserts that the value is null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNull``1(``0,System.String)">
      <summary>Asserts that the value is null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean)">
      <summary>Asserts that the condition is true.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean,System.String)">
      <summary>Asserts that the condition is true.</summary>
    </member>
    <member name="P:UnityEngine.Audio.AudioMixer.outputAudioMixerGroup">
      <summary>
        <para>Routing target.</para>
        <para>The audio mixer to which this mixer routes its output.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.ClearFloat(System.String)">
      <summary>Resets an exposed parameter to its initial value.</summary>
      <param name="name">Exposed parameter.</param>
      <returns>Returns false if the parameter was not found or could not be set.</returns>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.FindMatchingGroups(System.String)">
      <summary>Connected groups in the mixer form a path from the mixer's master group to the leaves. This path has the format "Master Group/Child of Master Group/Grandchild of Master Group", so to find the grandchild group in this example, a valid search string would be for instance "randchi" which would return exactly one group while "hild" or "oup/" would return 2 different groups.</summary>
      <param name="subPath">Sub-string of the paths to be matched.</param>
      <returns>Groups in the mixer whose paths match the specified search path.</returns>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.FindSnapshot(System.String)">
      <summary>The name must be an exact match.</summary>
      <param name="name">Name of snapshot object to be returned.</param>
      <returns>The snapshot identified by the name.</returns>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.GetFloat(System.String,System.Single@)">
      <summary>Returns the value of the exposed parameter specified. If the parameter doesn't exist the function returns false. Prior to calling SetFloat and after ClearFloat has been called on this parameter the value returned will be that of the current snapshot or snapshot transition.</summary>
      <param name="name">Name of exposed parameter.</param>
      <param name="value">Return value of exposed parameter.</param>
      <returns>Returns false if the exposed parameter specified doesn't exist.</returns>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.SetFloat(System.String,System.Single)">
      <summary>Sets the value of the exposed parameter specified. When a parameter is exposed, it is not controlled by mixer snapshots and can therefore only be changed via this function.</summary>
      <param name="name">Name of exposed parameter.</param>
      <param name="value">New value of exposed parameter.</param>
      <returns>Returns false if the exposed parameter was not found or snapshots are currently being edited.</returns>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixer.TransitionToSnapshots(UnityEngine.Audio.AudioMixerSnapshot[],System.Single[],System.Single)">
      <summary>Transitions to a weighted mixture of the snapshots specified. This can be used for games that specify the game state as a continuum between states or for interpolating snapshots from a triangulated map location.</summary>
      <param name="snapshots">The set of snapshots to be mixed.</param>
      <param name="weights">The mix weights for the snapshots specified.</param>
      <param name="timeToReach">Relative time after which the mixture should be reached from any current state.</param>
    </member>
    <member name="M:UnityEngine.Audio.AudioMixerSnapshot.TransitionTo(System.Single)">
      <summary>Performs an interpolated transition towards this snapshot over the time interval specified.</summary>
      <param name="timeToReach">Relative time after which this snapshot should be reached from any current state.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.#ctor">
      <summary>Constructor.</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.AddListener(UnityEngine.Events.UnityAction)">
      <summary>
        <para>Add a non persistent listener to the UnityEvent.</para>
        <para>Use this to add a runtime callback.</para>
      </summary>
      <param name="call">Callback function.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.Invoke">
      <summary>Invoke all registered callbacks (runtime and peristent).</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.RemoveListener(UnityEngine.Events.UnityAction)">
      <summary>
        <para>Remove a non persistent listener from the UnityEvent.</para>
        <para>Use this to remove a runtime callback.</para>
      </summary>
      <param name="call">Callback function.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentEventCount">
      <summary>Get the number of registered persistent listeners.</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentMethodName(System.Int32)">
      <summary>Get the target method name of the listener at index index.</summary>
      <param name="index">Index of the listener to query.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentTarget(System.Int32)">
      <summary>Get the target component of the listener at index index.</summary>
      <param name="index">Index of the listener to query.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.RemoveAllListeners">
      <summary>Remove all listeners from the event.</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.SetPersistentListenerState(System.Int32,UnityEngine.Events.UnityEventCallState)">
      <summary>Modify the execution state of a persistent listener.</summary>
      <param name="index">Index of the listener to query.</param>
      <param name="state">State to set.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetValidMethodInfo(System.Object,System.String,System.Type[])">
      <summary>Given an object, function name, and a list of argument types; find the method that matches.</summary>
      <param name="obj">Object to search for the method.</param>
      <param name="functionName">Function name to search for.</param>
      <param name="argumentTypes">Argument types for the function.</param>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.EventDefined">
      <summary>The listener will use the function binding specified by the even.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Void">
      <summary>The listener will bind to zero argument functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Object">
      <summary>The listener will bind to one argument Object functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Int">
      <summary>The listener will bind to one argument int functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Float">
      <summary>The listener will bind to one argument float functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.String">
      <summary>The listener will bind to one argument string functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Bool">
      <summary>The listener will bind to one argument bool functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.Off">
      <summary>Callback is not issued.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.EditorAndRuntime">
      <summary>Callback is always issued.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.RuntimeOnly">
      <summary>Callback is only issued in the Runtime and Editor playmode.</summary>
    </member>
    <member name="P:UnityEngine.iOS.ADBannerView.layout">
      <summary>
        <para>Banner layout.</para>
        <para>You can set manual layout to move banner around yourself.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.ADBannerView.loaded">
      <summary>
        <para>Checks if banner contents are loaded.</para>
        <para>You should hide banner if it is not loaded to avoid showing blank view.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.ADBannerView.position">
      <summary>
        <para>The position of the banner view.</para>
        <para>It uses unity GUI coords and convention, so it is top-left corner coords. If you change it, banner will become manually layed-out automatically. Please note that for Traditional Banner x component is ignored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.ADBannerView.size">
      <summary>
        <para>The size of the banner view.</para>
        <para>It uses unity GUI coords.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.ADBannerView.visible">
      <summary>
        <para>Banner visibility. Initially banner is not visible.</para>
        <para>Please note that if you hide banner, ads might not be reloaded with time, so if you no longer need banner it is better to delete it completely.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.ADBannerView.#ctor(System.Type,UnityEngine.iOS.ADBannerView.Layout)">
      <summary>
        <para>Creates a banner view with given type and auto-layout params.</para>
        <para>Please check if given type is available by calling <see cref="M:UnityEngine.iOS.ADBannerView.IsAvailable(System.Type)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.ADBannerView.IsAvailable(System.Type)">
      <summary>Checks if the banner type is available (e.g. MediumRect is available only starting with ios6).</summary>
    </member>
    <member name="P:UnityEngine.iOS.ADInterstitialAd.isAvailable">
      <summary>Checks if InterstitialAd is available (it is iPad-only and was added in iOS 4.3).</summary>
    </member>
    <member name="P:UnityEngine.iOS.ADInterstitialAd.loaded">
      <summary>Has the interstitial ad object downloaded an advertisement? (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.iOS.ADInterstitialAd.#ctor">
      <summary>Creates an interstitial ad.</summary>
    </member>
    <member name="M:UnityEngine.iOS.ADInterstitialAd.#ctor(System.Boolean)">
      <summary>Creates an interstitial ad.</summary>
    </member>
    <member name="M:UnityEngine.iOS.ADInterstitialAd.ReloadAd">
      <summary>
        <para>Reload advertisement.</para>
        <para>Call it when you are done with current one (if you want more ads downloaded).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.ADInterstitialAd.Show">
      <summary>Shows full-screen advertisement to user.</summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.advertisingIdentifier">
      <summary>
        <para>Advertising ID.</para>
        <para>ASIdentifierManager advertisingIdentifier.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.advertisingTrackingEnabled">
      <summary>
        <para>Is advertising tracking enabled.</para>
        <para>Indicates whether user has limited ad tracking.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.generation">
      <summary>
        <para>The generation of the device. (Read Only)</para>
        <para>See DeviceGeneration enumeration for possible return values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.systemVersion">
      <summary>
        <para>iOS version.</para>
        <para>iOS version as a string. E.g. "7.0" or "8.1".</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.vendorIdentifier">
      <summary>
        <para>Vendor ID.</para>
        <para>UIDevice identifierForVendor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.Device.ResetNoBackupFlag(System.String)">
      <summary>Reset "no backup" file flag: file will be synced with iCloud/iTunes backup and can be deleted by OS in low storage situations.</summary>
    </member>
    <member name="M:UnityEngine.iOS.Device.SetNoBackupFlag(System.String)">
      <summary>
        <para>Set file flag to be excluded from iCloud/iTunes backup.</para>
        <para>As a side-effect, if it was located in Caches folder, it won't be deleted by OS.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.defaultSoundName">
      <summary>The default system sound. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertAction">
      <summary>The title of the action button or slider.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertBody">
      <summary>The message displayed in the notification alert.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertLaunchImage">
      <summary>Identifies the image used as the launch image when the user taps the action button.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.applicationIconBadgeNumber">
      <summary>The number to display as the application's icon badge.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.fireDate">
      <summary>The date and time when the system should deliver the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.hasAction">
      <summary>A boolean value that controls whether the alert action is visible or not.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.repeatCalendar">
      <summary>The calendar type (Gregorian, Chinese, etc) to use for rescheduling the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.repeatInterval">
      <summary>The calendar interval at which to reschedule the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.soundName">
      <summary>The name of the sound file to play when an alert is displayed.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.timeZone">
      <summary>The time zone of the notification's fire date.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.userInfo">
      <summary>A dictionary for passing custom information to the notified application.</summary>
    </member>
    <member name="M:UnityEngine.iOS.LocalNotification.#ctor">
      <summary>Creates a new local notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.deviceToken">
      <summary>Device token received from Apple Push Service after calling <c>NotificationServices.RegisterForRemoteNotificationTypes</c>. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.enabledNotificationTypes">
      <summary>
        <para>Enabled local and remote notification types.</para>
        <para>Note: enabled notification types can be changed by users modifying notification options for the app in iOS settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.localNotificationCount">
      <summary>The number of received local notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.localNotifications">
      <summary>The list of objects representing received local notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.registrationError">
      <summary>Returns an error that might occur on registration for remote notifications via <c>NotificationServices.RegisterForRemoteNotificationTypes</c>. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.remoteNotificationCount">
      <summary>The number of received remote notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.remoteNotifications">
      <summary>The list of objects representing received remote notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.scheduledLocalNotifications">
      <summary>All currently scheduled local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.CancelAllLocalNotifications">
      <summary>Cancels the delivery of all scheduled local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.CancelLocalNotification(UnityEngine.iOS.LocalNotification)">
      <summary>Cancels the delivery of the specified scheduled local notification.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ClearLocalNotifications">
      <summary>Discards of all received local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ClearRemoteNotifications">
      <summary>Discards of all received remote notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.GetLocalNotification(System.Int32)">
      <summary>Returns an object representing a specific local notification. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.GetRemoteNotification(System.Int32)">
      <summary>Returns an object representing a specific remote notification. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.PresentLocalNotificationNow(UnityEngine.iOS.LocalNotification)">
      <summary>Presents a local notification immediately.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.RegisterForNotifications(UnityEngine.iOS.NotificationType)">
      <summary>
        <para>Register to receive local and remote notifications of the specified types from a provider via Apple Push Service.</para>
        <para>After an application registers for the specified remote notification types, the device token is received from Apple Push Service and is available via <see cref="P:UnityEngine.iOS.NotificationServices.deviceToken" />.</para>
      </summary>
      <param name="notificationTypes">Notification types to register for.</param>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.RegisterForNotifications(UnityEngine.iOS.NotificationType,System.Boolean)">
      <summary>
        <para>Register to receive local and remote notifications of the specified types from a provider via Apple Push Service.</para>
        <para>After an application registers for the specified remote notification types, the device token is received from Apple Push Service and is available via <see cref="P:UnityEngine.iOS.NotificationServices.deviceToken" />.</para>
      </summary>
      <param name="notificationTypes">Notification types to register for.</param>
      <param name="registerForRemote">Specify true to also register for remote notifications.</param>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ScheduleLocalNotification(UnityEngine.iOS.LocalNotification)">
      <summary>Schedules a local notification.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.UnregisterForRemoteNotifications">
      <summary>Unregister for remote notifications.</summary>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResources.enabled">
      <summary>Indicates whether player was built with "Use On Demand Resources" player setting enabled.</summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResources.PreloadAsync(System.String[])">
      <summary>
        <para>Creates an On Demand Resources (ODR) request.</para>
        <para>The request will include all resources indicated by the given tags. If operation completes successfuly, then request object will keep those resources alive until <see cref="M:UnityEngine.iOS.OnDemandResourcesRequest.Dispose" /> is called or request gets collected by a garbage collector.See Also: <see cref="T:UnityEngine.iOS.OnDemandResourcesRequest" />.</para>
      </summary>
      <param name="tags">Tags for On Demand Resources that should be included in the request.</param>
      <returns>Object representing ODR request.</returns>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResourcesRequest.error">
      <summary>
        <para>Returns an error after operation is complete.</para>
        <para>Returns error's message or null if operation has successfuly completed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResourcesRequest.loadingPriority">
      <summary>
        <para>Sets the priority for request.</para>
        <para>Value range is [0; 1] or greater than 1 to give the request special "urgent" status.Equivalent of setting <c>loadingPriority</c> property on <c>NSBundleResourceRequest</c> class.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResourcesRequest.Dispose">
      <summary>
        <para>Release all resources kept alive by On Demand Resources (ODR) request.</para>
        <para>
          <see cref="T:UnityEngine.iOS.OnDemandResourcesRequest" /> will keep ODR resource alive until either <see cref="M:UnityEngine.iOS.OnDemandResourcesRequest.Dispose" />() is called or request object is collected by garbage collector, which is equivalent of calling <c>endAccessingResources</c> on <c>NSBundleResourceRequest</c> class.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResourcesRequest.GetResourcePath(System.String)">
      <summary>Gets file system's path to the resource available in On Demand Resources (ODR) request.</summary>
      <param name="resourceName">Resource name.</param>
      <seealso cref="T:UnityEngine.iOS.OnDemandResourcesRequest" />
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.alertBody">
      <summary>The message displayed in the notification alert. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.applicationIconBadgeNumber">
      <summary>The number to display as the application's icon badge. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.hasAction">
      <summary>A boolean value that controls whether the alert action is visible or not. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.soundName">
      <summary>The name of the sound file to play when an alert is displayed. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.userInfo">
      <summary>A dictionary for passing custom information to the notified application. (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.DontShow">
      <summary>Do not show ActivityIndicator.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.WhiteLarge">
      <summary>The large white style of indicator (UIActivityIndicatorViewStyleWhiteLarge).</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.White">
      <summary>The standard white style of indicator (UIActivityIndicatorViewStyleWhite).</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.Gray">
      <summary>The standard gray style of indicator (UIActivityIndicatorViewStyleGray).</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.Top">
      <summary>Traditional Banner: align to screen top.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.Bottom">
      <summary>Traditional Banner: align to screen bottom.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.TopLeft">
      <summary>Rect Banner: place in top-left corner.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.TopRight">
      <summary>Rect Banner: place in top-right corner.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.TopCenter">
      <summary>Rect Banner: align to screen top, placing at the center.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.BottomLeft">
      <summary>Rect Banner: place in bottom-left corner.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.BottomRight">
      <summary>Rect Banner: place in bottom-right corner.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.BottomCenter">
      <summary>Rect Banner: align to screen bottom, placing at the center.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.CenterLeft">
      <summary>Rect Banner: align to screen left, placing at the center.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.CenterRight">
      <summary>Rect Banner: align to screen right, placing at the center.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.Center">
      <summary>Rect Banner: place exactly at screen center.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Layout.Manual">
      <summary>
        <para>Completely manual positioning.</para>
        <para>Please use ADBannerView.position.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Type.Banner">
      <summary>
        <para>Traditional Banner (it takes full screen width).</para>
        <para>iOS type: ADAdTypeBanner.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.iOS.ADBannerView.Type.MediumRect">
      <summary>
        <para>Rect Banner (300x250).</para>
        <para>iOS type: ADAdTypeMediumRectangle.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.GregorianCalendar">
      <summary>Identifies the Gregorian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.BuddhistCalendar">
      <summary>Identifies the Buddhist calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.ChineseCalendar">
      <summary>Identifies the Chinese calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.HebrewCalendar">
      <summary>Identifies the Hebrew calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IslamicCalendar">
      <summary>Identifies the Islamic calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IslamicCivilCalendar">
      <summary>Identifies the Islamic civil calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.JapaneseCalendar">
      <summary>Identifies the Japanese calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.RepublicOfChinaCalendar">
      <summary>Identifies the Republic of China (Taiwan) calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.PersianCalendar">
      <summary>Identifies the Persian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IndianCalendar">
      <summary>Identifies the Indian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.ISO8601Calendar">
      <summary>Identifies the ISO8601.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Era">
      <summary>Specifies the era unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Year">
      <summary>Specifies the year unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Month">
      <summary>Specifies the month unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Day">
      <summary>Specifies the day unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Hour">
      <summary>Specifies the hour unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Minute">
      <summary>Specifies the minute unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Second">
      <summary>Specifies the second unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Week">
      <summary>Specifies the week unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Weekday">
      <summary>Specifies the weekday unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.WeekdayOrdinal">
      <summary>Specifies the ordinal weekday unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Quarter">
      <summary>Specifies the quarter of the calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone">
      <summary>iPhone, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone3G">
      <summary>iPhone, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone3GS">
      <summary>iPhone, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch1Gen">
      <summary>iPod Touch, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch2Gen">
      <summary>iPod Touch, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch3Gen">
      <summary>iPod Touch, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad1Gen">
      <summary>iPad, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone4">
      <summary>iPhone, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch4Gen">
      <summary>iPod Touch, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad2Gen">
      <summary>iPad, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone4S">
      <summary>iPhone, fifth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad3Gen">
      <summary>iPad, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5">
      <summary>iPhone5.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch5Gen">
      <summary>iPod Touch, fifth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini1Gen">
      <summary>iPadMini, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad4Gen">
      <summary>iPad, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5C">
      <summary>iPhone 5C.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5S">
      <summary>iPhone 5S.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadAir1">
      <summary>iPad Air.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini2Gen">
      <summary>iPadMini Retina (second generation).</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6">
      <summary>iPhone 6.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6Plus">
      <summary>iPhone 6 plus.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini3Gen">
      <summary>iPad Mini 3.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadAir2">
      <summary>iPad Air 2.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhoneUnknown">
      <summary>Yet unknown iPhone.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadUnknown">
      <summary>Yet unknown iPad.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouchUnknown">
      <summary>Yet unknown iPodTouch.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.None">
      <summary>No notification types specified.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Badge">
      <summary>Notification is a badge shown above the application's icon.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Sound">
      <summary>Notification is an alert sound.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Alert">
      <summary>Notification is an alert message.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.BasicResponse.#ctor">
      <summary>Constructor for response class.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.advertise">
      <summary>Bool to describe if the created match should be advertised.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.eloScore">
      <summary>The optional game defined Elo score for the client making the request. The Elo score is averaged against all clients in a match and that value is used to produce better search results when listing available matches. If the Elo is provided the result set will be ordered according to the magnitude of the absoloute value of the difference of the a client searching for a match and the network average for all clients in each match. If the Elo score is not provided (and therefore 0 for all matches) the Elo score will not affect the search results. Each game can calculate this value as they wish according to whatever scale is best for that game.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.matchAttributes">
      <summary>Match attributes describing game specific features for this match. Each attribute is a key/value pair of a string key with a long value. Each match may have up to 10 of these values. The game is free to use this as desired to assist in finding better match results when clients search for matches to join.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.name">
      <summary>Name of the match to create.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.password">
      <summary>Password for the match to create. Leave blank for no password. Cannot be null.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.privateAddress">
      <summary>The (optional) private network address for the client making the request. This is the local network available private address another client on the same network could use to connect directly to the client making the request and may be used to better connect multiple clients. If it is not supplied the networking layer will still be completely functional.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.publicAddress">
      <summary>The (optional) public network address for the client making the request. This is the internet available public address another client on the internet (but not the local network) could use to connect directly to the client making the request and may be used to better connect multiple clients. If it is not supplied the networking layer will still be completely functional.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchRequest.size">
      <summary>Max number of clients that may join the match to create, including the host.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateMatchRequest.#ctor">
      <summary>Class constructor.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateMatchRequest.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateMatchRequest.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.accessTokenString">
      <summary>JSON encoding for the binary access token this client uses to authenticate its session for future commands.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.address">
      <summary>Network address to connect to in order to join the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.networkId">
      <summary>The network id for the match created.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.nodeId">
      <summary>NodeId for the requesting client in the created match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.port">
      <summary>Network port to connect to in order to join the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.CreateMatchResponse.usingRelay">
      <summary>If the match is hosted by a relay server.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateMatchResponse.#ctor">
      <summary>Constructor for response class.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateMatchResponse.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.CreateOrJoinMatchRequest.#ctor">
      <summary>Constructor for CreateOrJoinMatchRequest class.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.DestroyMatchRequest.networkId">
      <summary>NetworkID of the match to destroy.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DestroyMatchRequest.#ctor">
      <summary>Class constructor.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DestroyMatchRequest.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DestroyMatchRequest.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.DropConnectionRequest.networkId">
      <summary>NetworkID of the match the client to drop is in.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.DropConnectionRequest.nodeId">
      <summary>NodeID of the connection to drop.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DropConnectionRequest.#ctor">
      <summary>Class constructor.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DropConnectionRequest.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.DropConnectionRequest.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchRequest.eloScore">
      <summary>The optional game defined Elo score for the client making the request. The Elo score is averaged against all clients in a match and that value is used to produce better search results when listing available matches. If the Elo is provided the result set will be ordered according to the magnitude of the absoloute value of the difference of the a client searching for a match and the network average for all clients in each match. If the Elo score is not provided (and therefore 0 for all matches) the Elo score will not affect the search results. Each game can calculate this value as they wish according to whatever scale is best for that game.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchRequest.networkId">
      <summary>NetworkID of the match to join.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchRequest.password">
      <summary>Password for the match to join. Leave blank for no password. Cannot be null.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchRequest.privateAddress">
      <summary>The (optional) private network address for the client making the request. This is the local network available private address another client on the same network could use to connect directly to the client making the request and may be used to better connect multiple clients. If it is not supplied the networking layer will still be completely functional.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchRequest.publicAddress">
      <summary>The (optional) public network address for the client making the request. This is the internet available public address another client on the internet (but not the local network) could use to connect directly to the client making the request and may be used to better connect multiple clients. If it is not supplied the networking layer will still be completely functional.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.JoinMatchRequest.#ctor">
      <summary>Class constructor.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.JoinMatchRequest.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.JoinMatchRequest.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.accessTokenString">
      <summary>JSON encoding for the binary access token this client uses to authenticate its session for future commands.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.address">
      <summary>Network address to connect to in order to join the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.networkId">
      <summary>NetworkID of the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.nodeId">
      <summary>NodeID for the requesting client in the mach that it is joining.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.port">
      <summary>Network port to connect to in order to join the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.JoinMatchResponse.usingRelay">
      <summary>If the match is hosted by a relay server.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.JoinMatchResponse.#ctor">
      <summary>Constructor for response class.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.JoinMatchResponse.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.eloScore">
      <summary>The optional game defined Elo score for the client making the request. The Elo score is averaged against all clients in a match and that value is used to produce better search results when listing available matches. If the Elo is provided the result set will be ordered according to the magnitude of the absoloute value of the difference of the a client searching for a match and the network average for all clients in each match. If the Elo score is not provided (and therefore 0 for all matches) the Elo score will not affect the search results. Each game can calculate this value as they wish according to whatever scale is best for that game.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.includePasswordMatches">
      <summary>Only return matches that have a password if this is true, only return matches without a password if this is false.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.matchAttributeFilterEqualTo">
      <summary>List of match attributes to filter against. This will filter down to matches that both have a name that contains the entire text string provided and the value specified in the filter is equal to the attribute value for the matching name. No additional wildcards are allowed in the name. A maximum of 10 filters can be specified between all 3 filter lists.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.matchAttributeFilterGreaterThan">
      <summary>List of match attributes to filter against. This will filter down to matches that both have a name that contains the entire text string provided and the value specified in the filter is greater than the attribute value for the matching name. No additional wildcards are allowed in the name. A maximum of 10 filters can be specified between all 3 filter lists.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.matchAttributeFilterLessThan">
      <summary>List of match attributes to filter against. This will filter down to matches that both have a name that contains the entire text string provided and the value specified in the filter is less than the attribute value for the matching name. No additional wildcards are allowed in the name. A maximum of 10 filters can be specified between all 3 filter lists.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.nameFilter">
      <summary>Name filter to apply to the match list.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.pageNum">
      <summary>1 based page number requested.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchRequest.pageSize">
      <summary>Number of results per page to be returned.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchRequest.#ctor">
      <summary>Class constructor.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchRequest.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchRequest.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.ListMatchResponse.matches">
      <summary>List of matches fitting the requested description.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchResponse.#ctor">
      <summary>Constructor for response class.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchResponse.#ctor">
      <summary>Constructor for response class.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.ListMatchResponse.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.averageEloScore">
      <summary>The optional game defined Elo score for the match as a whole. The Elo score is averaged against all clients in a match and that value is used to produce better search results when listing available matches. If the Elo is provided the result set will be ordered according to the magnitude of the absoloute value of the difference of the a client searching for a match and the network average for all clients in each match. If the Elo score is not provided (and therefore 0 for all matches) the Elo score will not affect the search results. Each game can calculate this value as they wish according to whatever scale is best for that game.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.currentSize">
      <summary>Current number of users connected to a match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.directConnectInfos">
      <summary>Direct connection info for network games; This is not required for games utilizing matchmaker.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.hostNodeId">
      <summary>The NodeID of the host in a matchmaker match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.isPrivate">
      <summary>Describes if this match is considered private.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.matchAttributes">
      <summary>Match attributes describing game specific features for this match. Each attribute is a key/value pair of a string key with a long value. Each match may have up to 10 of these values. The game is free to use this as desired to assist in finding better match results when clients search for matches to join.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.maxSize">
      <summary>Max number of users that may connect to a match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.name">
      <summary>Name of the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDesc.networkId">
      <summary>NetworkID of the match.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.MatchDesc.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchDirectConnectInfo.nodeId">
      <summary>NodeID of the client described in this direct connect info.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.accessToken">
      <summary>The binary access token this client uses to authenticate its session for future commands.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.address">
      <summary>IP address of the host of the match,.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.networkId">
      <summary>The unique ID of this match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.nodeId">
      <summary>NodeID for this member client in the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.port">
      <summary>Port of the host of the match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.MatchInfo.usingRelay">
      <summary>Flag to say if the math uses a relay server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.NetworkMatch.baseUri">
      <summary>The base URI of the UNET MatchMaker that this NetworkMatch will communicate with.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.CreateMatch(System.String,System.UInt32,System.Boolean,System.String)">
      <summary>
        <para>A match accessor to create a new match hosted on this client.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="matchName">Name of match to create.</param>
      <param name="matchSize">Maximum number of users in the match.</param>
      <param name="matchAdvertise">Flag to advertise this match in searches.</param>
      <param name="matchPassword">Password required to enter the match.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.CreateMatch(UnityEngine.Networking.Match.CreateMatchRequest)">
      <summary>
        <para>A match accessor to create a new match hosted on this client.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="req">A CreateMatchRequest describing the match to create.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.DestroyMatch(UnityEngine.Networking.Types.NetworkID)">
      <summary>
        <para>Destroy a match (that this client owns) on the UNET Matchmaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="netId">Id of the match to destroy.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.DestroyMatch(UnityEngine.Networking.Match.DestroyMatchRequest)">
      <summary>
        <para>Destroy a match (that this client owns) on the UNET Matchmaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="req">A CreateMatchRequest describing the match to destroy.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.DropConnection(UnityEngine.Networking.Types.NetworkID,UnityEngine.Networking.Types.NodeID)">
      <summary>
        <para>This causes a client to be dropped from a UNET Matchmaker match.</para>
        <para>Only the host can do this (?). This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="netId">Id of the match to drop from.</param>
      <param name="dropNodeId">NodeId of the client to drop.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.DropConnection(UnityEngine.Networking.Match.DropConnectionRequest)">
      <summary>
        <para>This causes a client to be dropped from a UNET Matchmaker match.</para>
        <para>Only the host can do this (?). This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="req">A DropConnectionRequest describing the match to destroy.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.JoinMatch(UnityEngine.Networking.Types.NetworkID,System.String)">
      <summary>
        <para>Join a match on the UNET Matchmaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="netId">Id of the match to join.</param>
      <param name="matchPassword">Password to join with.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.JoinMatch(UnityEngine.Networking.Match.JoinMatchRequest)">
      <summary>
        <para>Join a match on the UNET Matchmaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="req">A JoinMatchRequest describing the match to destroy.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.ListMatches(System.Int32,System.Int32,System.String)">
      <summary>
        <para>This requests a list of the active matches from a UNET MatchMaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="startPageNumber">First page of results.</param>
      <param name="resultPageSize">Number of matches in each page.</param>
      <param name="matchNameFilter">String to filter names on.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.ListMatches(UnityEngine.Networking.Match.ListMatchRequest)">
      <summary>
        <para>This requests a list of the active matches from a UNET MatchMaker.</para>
        <para>This is asynchronous, the callback function will be invoked when the operation completes.</para>
      </summary>
      <param name="req">A ListMatchRequest describing the match to destroy.</param>
      <returns>A coroutine for managing the async operation. if using the callback, this can be ignored.</returns>
    </member>
    <member name="M:UnityEngine.Networking.Match.NetworkMatch.SetProgramAppID(UnityEngine.Networking.Types.AppID)">
      <summary>Set this before calling any UNET functions. Must match AppID for this program from the Cloud API.</summary>
      <param name="programAppID">AppID that corresponds to the Cloud API AppID for this app.</param>
    </member>
    <member name="P:UnityEngine.Networking.Match.Request.accessTokenString">
      <summary>The JSON encoded binary access token this client uses to authenticate its session for future commands.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Request.appId">
      <summary>AppID for the current game, required in every request. This is generated from the Cloud API.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Request.domain">
      <summary>Domain for the request. All commands will be sandboxed to their own domain; For example no clients with domain 1 will see matches with domain 2. This can be used to prevent incompatible client versions from communicating.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Request.projectId">
      <summary>The Cloud Project Id for this game, required in every request. This is used to match games of the same type.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Request.sourceId">
      <summary>SourceID for the current client, required in every request. This is generated from the Cloud API.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Match.Request.version">
      <summary>Matchmaker protocol version info.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.Request.IsValid">
      <summary>Accessor to verify if the contained data is a valid request with respect to initialized variables and accepted parameters.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.Request.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Response.extendedInfo">
      <summary>Extended string information that is returned when the server encounters an error processing a request.</summary>
    </member>
    <member name="P:UnityEngine.Networking.Match.Response.success">
      <summary>Bool describing if the request was successful.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Match.Response.ToString">
      <summary>Provides string description of current class data.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.AddPlayerMessage.msgData">
      <summary>The extra message data included in the AddPlayerMessage.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.AddPlayerMessage.msgSize">
      <summary>The size of the extra message data included in the AddPlayerMessage.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.AddPlayerMessage.playerControllerId">
      <summary>
        <para>The playerId of the new player.</para>
        <para>This is specified by the client when he calls NetworkClient.AddPlayer(someId).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.ErrorMessage.errorCode">
      <summary>
        <para>The error code.</para>
        <para>This is a value from the UNETError enumeration.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.IntegerMessage.value">
      <summary>The integer value to serialize.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerInfoMessage.address">
      <summary>The IP address of the peer.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerInfoMessage.connectionId">
      <summary>The id of the NetworkConnection associated with the peer.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerInfoMessage.isHost">
      <summary>True if this peer is the host of the network game.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerInfoMessage.isYou">
      <summary>True if the peer if the same as the current client.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerInfoMessage.port">
      <summary>The network port being used by the peer.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.PeerListMessage.peers">
      <summary>The list of participants in a networked game.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.RemovePlayerMessage.playerControllerId">
      <summary>
        <para>The player ID of the player object which should be removed.</para>
        <para>This is specified by the client when he calls NetworkClient.RemovePlayer(someId).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSystem.StringMessage.value">
      <summary>The string that will be serialized.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkAccessToken.array">
      <summary>Binary field for the actual token.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Types.NetworkAccessToken.GetByteString">
      <summary>Accessor to get an encoded string from the m_array data.</summary>
    </member>
    <member name="M:UnityEngine.Networking.Types.NetworkAccessToken.IsValid">
      <summary>Checks if the token is a valid set of data with respect to default values (returns true if the values are not default, does not validate the token is a current legitimate token with respect to the server's auth framework).</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.AppID.Invalid">
      <summary>Invalid AppID.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkAccessLevel.Invalid">
      <summary>Invalid access level, signifying no access level has been granted/specified.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkAccessLevel.User">
      <summary>User access level. This means you can do operations which affect yourself only, like disconnect yourself from the match.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkAccessLevel.Owner">
      <summary>Access level Owner, generally granting access for operations key to the peer host server performing it's work.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkAccessLevel.Admin">
      <summary>Administration access level, generally describing clearence to perform game altering actions against anyone inside a particular match.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NetworkID.Invalid">
      <summary>Invalid NetworkID.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.NodeID.Invalid">
      <summary>The invalid case of a NodeID.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Types.SourceID.Invalid">
      <summary>Invalid SourceID.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ChannelQOS.QOS">
      <summary>Channel quality of service.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ChannelQOS.#ctor(UnityEngine.Networking.QosType)">
      <summary>UnderlyingModel.MemDoc.MemDocModel.</summary>
      <param name="value">Requested type of quality of service (default Unreliable).</param>
    </member>
    <member name="M:UnityEngine.Networking.ChannelQOS.#ctor">
      <summary>UnderlyingModel.MemDoc.MemDocModel.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ChannelQOS.#ctor(UnityEngine.Networking.ChannelQOS)">
      <summary>UnderlyingModel.MemDoc.MemDocModel.</summary>
      <param name="channel">Copy constructor.</param>
    </member>
    <member name="F:UnityEngine.Networking.Channels.DefaultReliable">
      <summary>The id of the default reliable channel used by the UNet HLAPI, This channel is used for state updates and spawning.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Channels.DefaultUnreliable">
      <summary>The id of the default unreliable channel used for the UNet HLAPI. This channel is used for movement updates.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.localPlayers">
      <summary>A list of all players added to the game.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.objects">
      <summary>
        <para>This is a dictionary of networked objects that have been spawned on the client.</para>
        <para>The key of the dictionary is the NetworkIdentity netId of the objects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.prefabs">
      <summary>
        <para>This is a dictionary of the prefabs that are registered on the client.</para>
        <para>The key to the dictionary is the prefab asset Id.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.ready">
      <summary>Return true when a client connection has been set as ready.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.readyConnection">
      <summary>
        <para>The NetworkConnection object that is currently "ready". This is the connection being used connect to the server where objects are spawned from.</para>
        <para>This connection can be used to send messages to the server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.ClientScene.spawnableObjects">
      <summary>
        <para>This is dictionary of the disabled NetworkIdentity objects in the scene that could be spawned by messages from the server.</para>
        <para>The key to the dictionary is the NetworkIdentity sceneId.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.AddPlayer(UnityEngine.Networking.NetworkConnection,System.Int16,UnityEngine.Networking.MessageBase)">
      <summary>
        <para>This adds a player object for this client. This causes an AddPlayer message to be sent to the server, and NetworkManager.OnServerAddPlayer will be called. If an extra message was passed to AddPlayer, then OnServerAddPlayer will be called with a NetworkReader that contains the contents of the message.</para>
        <para>The playerControllerId is the local player ID for the player, for example like which controller a player is using. This is not the global overall player number.</para>
      </summary>
      <param name="readyConn">The connection to become ready for this client.</param>
      <param name="playerControllerId">The local player ID number.</param>
      <param name="extraMessage">An extra message object that can be passed to the server for this player.</param>
      <returns>True if player was added.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.AddPlayer(UnityEngine.Networking.NetworkConnection,System.Int16)">
      <summary>
        <para>This adds a player object for this client. This causes an AddPlayer message to be sent to the server, and NetworkManager.OnServerAddPlayer will be called. If an extra message was passed to AddPlayer, then OnServerAddPlayer will be called with a NetworkReader that contains the contents of the message.</para>
        <para>The playerControllerId is the local player ID for the player, for example like which controller a player is using. This is not the global overall player number.</para>
      </summary>
      <param name="readyConn">The connection to become ready for this client.</param>
      <param name="playerControllerId">The local player ID number.</param>
      <returns>True if player was added.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.AddPlayer(System.Int16)">
      <summary>
        <para>This adds a player object for this client. This causes an AddPlayer message to be sent to the server, and NetworkManager.OnServerAddPlayer will be called. If an extra message was passed to AddPlayer, then OnServerAddPlayer will be called with a NetworkReader that contains the contents of the message.</para>
        <para>The playerControllerId is the local player ID for the player, for example like which controller a player is using. This is not the global overall player number.</para>
      </summary>
      <param name="playerControllerId">The local player ID number.</param>
      <returns>True if player was added.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.ClearSpawners">
      <summary>This clears the registered spawn prefabs and spawn handler functions for this client.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.ConnectLocalServer">
      <summary>
        <para>Create and connect a local client instance to the local server.</para>
        <para>This client acts like normal remote client but internally all messages are routed directly to the server process.</para>
      </summary>
      <returns>A client object for communicating with the local server.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.DestroyAllClientObjects">
      <summary>
        <para>Destroys all networked objects on the client.</para>
        <para>This can be used to clean up when a network connection is closed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.FindLocalObject(System.UInt32)">
      <summary>
        <para>This finds the local NetworkIdentity object with the specified network Id.</para>
        <para>NetId is a unique number assigned to all objects with NetworkIdentity components in a game. This number is the same on the server and all connected clients for a particular object, so it can be used to identify objects across the network. The FindLocalObject() function is called on a client to transform a netId received from a server to a local game object.</para>
      </summary>
      <returns>The game object that matches the netId.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.Ready(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Signal that the client connection is ready to enter the game.</para>
        <para>This could be for example when a client enters an ongoing game and has finished loading the current scene. The server should respond to the SYSTEM_READY event with an appropriate handler which instantiates the players object for example.</para>
      </summary>
      <param name="conn">The client connection which is ready.</param>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.RegisterPrefab(UnityEngine.GameObject)">
      <summary>
        <para>Registers a prefab with the UNET spawning system.</para>
        <para>When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instanciate a corresponding client object with the same netId.</para>
        <para>The optional custom spawn and un-spawn handler functions can be used to implement more advanced spawning strategies such as pbject pools.</para>
      </summary>
      <param name="prefab">A Prefab that will be spawned.</param>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.RegisterPrefab(UnityEngine.GameObject,UnityEngine.Networking.SpawnDelegate,UnityEngine.Networking.UnSpawnDelegate)">
      <summary>
        <para>Registers a prefab with the UNET spawning system.</para>
        <para>When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instanciate a corresponding client object with the same netId.</para>
        <para>The optional custom spawn and un-spawn handler functions can be used to implement more advanced spawning strategies such as pbject pools.</para>
      </summary>
      <param name="prefab">A Prefab that will be spawned.</param>
      <param name="spawnHandler">A method to use as a custom spawnhandler on clients.</param>
      <param name="unspawnHandler">A method to use as a custom un-spawnhandler on clients.</param>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.RegisterSpawnHandler(UnityEngine.Networking.NetworkHash128,UnityEngine.Networking.SpawnDelegate,UnityEngine.Networking.UnSpawnDelegate)">
      <summary>
        <para>This is an advanced spawning funciotn that registers a custom assetId with the UNET spawning system.</para>
        <para>This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data.</para>
      </summary>
      <param name="assetId">Custom assetId string.</param>
      <param name="spawnHandler">A method to use as a custom spawnhandler on clients.</param>
      <param name="unspawnHandler">A method to use as a custom un-spawnhandler on clients.</param>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.RemovePlayer(System.Int16)">
      <summary>
        <para>Remove the specified player ID from the game.</para>
        <para>Both the client and the server will destroy the player object and remove him from the player list.</para>
      </summary>
      <returns>Returns true if the player was successfully destoyed and removed.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.SetLocalObject(System.UInt32,UnityEngine.GameObject)">
      <summary>
        <para>NetId is a unique number assigned to all objects with NetworkIdentity components in a game.</para>
        <para>This number is the same on the server and all connected clients for a particular object, so it can be used to identify objects across the network. The FindLocalObject() function is called on a client to transform a netId received from a server to a local game object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.UnregisterPrefab(UnityEngine.GameObject)">
      <summary>Removes a registered spawn prefab.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ClientScene.UnregisterSpawnHandler(UnityEngine.Networking.NetworkHash128)">
      <summary>Removes a registered spawn handler function.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.AckDelay">
      <summary>How long in ms receiver will wait before it will force send acknowledgements back without waiting any payload.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.AllCostTimeout">
      <summary>Defines timeout in ms after that message with AllCost deliver qos will force resend without acknowledgement waiting.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.ChannelCount">
      <summary>Return amount of channels for current configuration.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.Channels">
      <summary>Allow access to channels list.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.ConnectTimeout">
      <summary>Timeout in ms which library will wait before it will send another connection request.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.DisconnectTimeout">
      <summary>How long (in ms) library will wait before it will consider connection as disconnected.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.FragmentSize">
      <summary>What should be maximum fragment size (in Bytes) for fragmented messages.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.IsAcksLong">
      <summary>If it is true, connection will use 64 bit mask to acknowledge received reliable messages.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.MaxCombinedReliableMessageCount">
      <summary>Maximum amount of small reliable messages which will combine in one "array of messages". Useful if you are going to send a lot of small reliable messages.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.MaxCombinedReliableMessageSize">
      <summary>Maximum size of reliable message which library will consider as small and will try to combine in one "array of messages" message.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.MaxConnectionAttempt">
      <summary>How many attempt library will get before it will consider the connection as disconnected.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.MaxSentMessageQueueSize">
      <summary>Defines maximum messages which will wait for sending before user will receive error on Send() call.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.MinUpdateTimeout">
      <summary>Minimal send update timeout (in ms) for connection. this timeout could be increased by library if flow control will required.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.NetworkDropThreshold">
      <summary>How many (in %) packet need to be dropped due network condition before library will throttle send rate.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.OverflowDropThreshold">
      <summary>How many (in %) packet need to be dropped due lack of internal bufferes before library will throttle send rate.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.PacketSize">
      <summary>What is a maximum packet size (in Bytes) (including payload and all header). Packet can contain multiple messages inside.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.PingTimeout">
      <summary>Timeout in ms between control protocol messages.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.ReducedPingTimeout">
      <summary>Timeout in ms for control messages which library will use before it will accumulate statistics.</summary>
    </member>
    <member name="P:UnityEngine.Networking.ConnectionConfig.ResendTimeout">
      <summary>Minimum timeout (in ms) which library will wait before it will resend reliable message.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionConfig.#ctor">
      <summary>Will create default connection config or will copy them from another.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionConfig.#ctor(UnityEngine.Networking.ConnectionConfig)">
      <summary>Will create default connection config or will copy them from another.</summary>
      <param name="config">Connection config.</param>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionConfig.GetChannel(System.Byte)">
      <summary>Return the QoS set for the given channel or throw an out of range exception.</summary>
      <param name="idx">Index in array.</param>
      <returns>Channel QoS.</returns>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionConfig.Validate(UnityEngine.Networking.ConnectionConfig)">
      <summary>Validate parameters of connection config. Will throw exceptions if parameters are incorrect.</summary>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionSimulatorConfig.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
      <summary>Will create object describing network simulation parameters.</summary>
      <param name="outMinDelay">Minimal simulation delay for outgoing traffic in ms.</param>
      <param name="outAvgDelay">Average simulation delay for outgoing traffic in ms.</param>
      <param name="inMinDelay">Minimal simulation delay for incoming traffic in ms.</param>
      <param name="inAvgDelay">Average simulation delay for incoming traffic in ms.</param>
      <param name="packetLossPercentage">Probability of packet loss 0 &lt;= p &lt;= 1.</param>
    </member>
    <member name="M:UnityEngine.Networking.ConnectionSimulatorConfig.Dispose">
      <summary>Destructor.</summary>
    </member>
    <member name="P:UnityEngine.Networking.GlobalConfig.MaxPacketSize">
      <summary>
        <para>Defines maximum possible packet size in bytes for all network connections.</para>
        <para>The packet size associated with specific connections must be lower than this value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.GlobalConfig.ReactorMaximumReceivedMessages">
      <summary>
        <para>Defines maximum amount of messages in the receive queue.</para>
        <para>Messages which exceed this limit will be dropped.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.GlobalConfig.ReactorMaximumSentMessages">
      <summary>
        <para>Defines maximum message count in sent queue.</para>
        <para>Messages which exceed this limit will be dropped and Send calls will return errors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.GlobalConfig.ReactorModel">
      <summary>
        <para>Defines reactor model for the network library.</para>
        <para>With the select model, received packets will be handled as soon as they arrive. With the fixed rate model, incoming packets will only be handled periodically. The select model is good for non-mobile devices, where the battery life is not important. Fixed rate is not as CPU intensive and will save battery life on mobile devices but this decreases performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.GlobalConfig.ThreadAwakeTimeout">
      <summary>Defines (1) for select reactor, minimum time period, when system will check if there are any messages for send (2) for fixrate reactor, minimum interval of time, when system will check for sending and receiving messages.</summary>
    </member>
    <member name="M:UnityEngine.Networking.GlobalConfig.#ctor">
      <summary>Create new global config object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.DefaultConfig">
      <summary>Defines config for default connections in the topology.</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.MaxDefaultConnections">
      <summary>Defines how many connection with default config be permitted.</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.MessagePoolSizeGrowthFactor">
      <summary>Library keep and reuse internal pools of messages. By default they have size 128. If this value is not enough pools will be automatically increased. This value defines how they will increase. Default value is 0.75, so if original pool size was 128, the new pool size will be 128 * 1.75 = 224.</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.ReceivedMessagePoolSize">
      <summary>What is the size of received messages pool (default 128 bytes).</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.SentMessagePoolSize">
      <summary>Defines size of sent message pool (default value 128).</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.SpecialConnectionConfigs">
      <summary>List of special connection configs.</summary>
    </member>
    <member name="P:UnityEngine.Networking.HostTopology.SpecialConnectionConfigsCount">
      <summary>Returns count of special connection added to topology.</summary>
    </member>
    <member name="M:UnityEngine.Networking.HostTopology.#ctor(UnityEngine.Networking.ConnectionConfig,System.Int32)">
      <summary>Create topology.</summary>
      <param name="defaultConfig">Default config.</param>
      <param name="maxDefaultConnections">Maximum default connections.</param>
    </member>
    <member name="M:UnityEngine.Networking.HostTopology.AddSpecialConnectionConfig(UnityEngine.Networking.ConnectionConfig)">
      <summary>Add special connection to topology (for example if you need to keep connection to standalone chat server you will need to use this function). Returned id should be use as one of parameters (with ip and port) to establish connection to this server.</summary>
      <param name="config">Connection config for special connection.</param>
      <returns>Id of this connection, user should use this id when he calls <see cref="M:UnityEngine.Networking.NetworkTransport.Connect(System.Int32,System.String,System.Int32,System.Int32,System.Byte@)" />.</returns>
    </member>
    <member name="M:UnityEngine.Networking.HostTopology.GetSpecialConnectionConfig(System.Int32)">
      <summary>Return reference to special connection config. Parameters of this config can be changed.</summary>
      <param name="i">Config id.</param>
      <returns>Connection config.</returns>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.currentLogLevel">
      <summary>The current logging level that UNET is running with.</summary>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.currentLogLevel">
      <summary>The current logging level that UNET is running with.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.Debug">
      <summary>Setting LogFilter.currentLogLevel to this will enable verbose debug logging.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.Error">
      <summary>Setting LogFilter.currentLogLevel to this will error and above messages.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.Info">
      <summary>Setting LogFilter.currentLogLevel to this will log only info and above messages. This is the default level.</summary>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.logDebug">
      <summary>Checks if debug logging is enabled.</summary>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.logError">
      <summary>Checks if error logging is enabled.</summary>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.logInfo">
      <summary>Checks if info level logging is enabled.</summary>
    </member>
    <member name="P:UnityEngine.Networking.LogFilter.logWarn">
      <summary>Checks if wanring level logging is enabled.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.Warn">
      <summary>Setting LogFilter.currentLogLevel to this will log wanring and above messages.</summary>
    </member>
    <member name="M:UnityEngine.Networking.MessageBase.Deserialize(UnityEngine.Networking.NetworkReader)">
      <summary>
        <para>This method is used to populate a message object from a NetworkReader stream.</para>
        <para>Developers may implement this method for precise control of serialization, but they do no have to. An implemenation of this method will be generated for derived classes.</para>
      </summary>
      <param name="reader">Stream to read from.</param>
    </member>
    <member name="M:UnityEngine.Networking.MessageBase.Serialize(UnityEngine.Networking.NetworkWriter)">
      <summary>
        <para>The method is used to populate a NetworkWriter stream from a message object.</para>
        <para>Developers may implement this method for precise control of serialization, but they do no have to. An implemenation of this method will be generated for derived classes.</para>
      </summary>
      <param name="writer">Stream to write to.</param>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.AddPlayer">
      <summary>
        <para>Internal networking system message for adding player objects to client instances.</para>
        <para>This is sent to the server when a client calls NetworkClient.AddPlayer(). The server should have a handler for this message type to add the player object to the game and notify the client with NetworkServer.AddPlayer().</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Animation">
      <summary>
        <para>Internal networking system message for sending synchronizing animation state.</para>
        <para>Used by the NetworkAnimation component.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.AnimationParameters">
      <summary>
        <para>Internal networking system message for sending synchronizing animation parameter state.</para>
        <para>Used by the NetworkAnimation component.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.AnimationTrigger">
      <summary>
        <para>Internal networking system message for sending animation triggers.</para>
        <para>Used by the NetworkAnimation component.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Command">
      <summary>Internal networking system message for sending a command from client to server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Connect">
      <summary>Internal networking system message for communicating a connection has occurred.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.CRC">
      <summary>Internal networking system message for HLAPI CRC checking.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Disconnect">
      <summary>Internal networking system message for communicating a disconnect has occurred,.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Error">
      <summary>Internal networking system message for communicating an error.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Highest">
      <summary>The highest value of built-in networking system message ids. User messages must be above this value.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.InternalHighest">
      <summary>The highest value of internal networking system message ids. User messages must be above this value. User code cannot replace these handlers.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LobbyAddPlayerFailed">
      <summary>Internal networking system message for communicating failing to add lobby player.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LobbyReadyToBegin">
      <summary>Internal networking system message for communicating a player is ready in the lobby.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LobbyReturnToLobby">
      <summary>Internal networking system messages used to return the game to the lobby scene.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LobbySceneLoaded">
      <summary>Internal networking system message for communicating a lobby player has loaded the game scene.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LocalChildTransform">
      <summary>Internal networking system message for sending tranforms for client object from client to server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LocalClientAuthority">
      <summary>Internal networking system message for setting authority to a client for an object.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.LocalPlayerTransform">
      <summary>Internal networking system message for sending tranforms from client to server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.NetworkInfo">
      <summary>Internal networking system message for sending information about network peers to clents.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.NotReady">
      <summary>
        <para>Internal networking system message for server to tell clients they are no longer ready.</para>
        <para>Can be used when switching scenes, to stop receiving network traffic during the switch.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.ObjectDestroy">
      <summary>Internal networking system message for destroying objects.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.ObjectHide">
      <summary>Internal networking system message for hiding objects.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.ObjectSpawn">
      <summary>Internal networking system message for spawning objects.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.ObjectSpawnScene">
      <summary>Internal networking system message for spawning scene objects.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Owner">
      <summary>Internal networking system message for telling clients they own a player object.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Ready">
      <summary>Internal networking system message for clients to tell server they are ready.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.RemovePlayer">
      <summary>Internal networking system message for removing a player object which was spawned for a client.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Rpc">
      <summary>Internal networking system message for sending a ClientRPC from server to client.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.Scene">
      <summary>Internal networking system message that tells clients which scene to load when they connect to a server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.SpawnFinished">
      <summary>Internal networking system messages used to tell when the initial contents of a scene is being spawned.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.SyncEvent">
      <summary>Internal networking system message for sending a SyncEvent from server to client.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.SyncList">
      <summary>Internal networking system message for sending a USyncList generic list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.MsgType.UpdateVars">
      <summary>Internal networking system message for updating SyncVars on a client from a server.</summary>
    </member>
    <member name="M:UnityEngine.Networking.MsgType.MsgTypeToString(System.Int16)">
      <summary>Returns the name of internal message types by their id.</summary>
      <param name="value">A internal message id value.</param>
      <returns>The name of the internal message.</returns>
    </member>
    <member name="P:UnityEngine.Networking.NetworkAnimator.animator">
      <summary>The animator component to synchronize.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkAnimator.GetParameterAutoSend(System.Int32)">
      <summary>Gets whether an animation parameter should be auto sent.</summary>
      <param name="index">Index of the parameter in the Animator.</param>
      <returns>True if the parameter should be sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkAnimator.SetParameterAutoSend(System.Int32,System.Boolean)">
      <summary>Sets whether an animation parameter should be auto sent.</summary>
      <param name="index">Index of the parameter in the Animator.</param>
      <param name="value">The new value.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkAnimator.SetTrigger(System.String)">
      <summary>
        <para>Causes an animation trigger to be invoked for a networked object.</para>
        <para>If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkAnimator.SetTrigger(System.Int32)">
      <summary>
        <para>Causes an animation trigger to be invoked for a networked object.</para>
        <para>If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients.</para>
      </summary>
      <param name="hash">Hash id of trigger (from the Animator).</param>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.connectionToClient">
      <summary>The <see cref="T:UnityEngine.Networking.NetworkConnection" /> associated with this <see cref="T:UnityEngine.Networking.NetworkIdentity" />. This is only valid for player objects on the server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.connectionToServer">
      <summary>The <see cref="T:UnityEngine.Networking.NetworkConnection" /> associated with this <see cref="T:UnityEngine.Networking.NetworkIdentity" />. This is only valid for player objects on the server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.hasAuthority">
      <summary>
        <para>This returns true if this object is the authoritative version of the object in the distributed network application.</para>
        <para>The LocalPlayerAuthority value on the NetworkIdentity determines how authority is determined. For most objects, authority is held by the server / host. For objects with LocalPlayerAuthority set, authority is held by the client of that player.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.isClient">
      <summary>Returns true if running as a client and this object was spawned by a server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.isLocalPlayer">
      <summary>
        <para>This returns true if this object is the one that represents the player on the local machine.</para>
        <para>In multiplayer games, there are multiple instances of the Player object. The client needs to know which one is for "themselves" so that only that player processes input and potentially has a camera attached. The IsLocalPlayer function will return true only for the player instance that belongs to the player on the local machine, so it can be used to filter out input for non-local players.This example shows processing input for only the local player.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.isServer">
      <summary>
        <para>Returns true if this object is active on an active server.</para>
        <para>This is only true if the object has been spawned. This is different from NetworkServer.active, which is true if the server itself is active rather than this object being active.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.localPlayerAuthority">
      <summary>This value is set on the NetworkIdentity and is accessible here for convenient access for scripts.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.netId">
      <summary>
        <para>The unique network Id of this object.</para>
        <para>This is assigned at runtime by the network server and will be unique for all objects for that network session.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkBehaviour.playerControllerId">
      <summary>
        <para>The id of the player associated with thei behaviour.</para>
        <para>This is only valid if the object is a local player.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.ClearAllDirtyBits">
      <summary>
        <para>This clears all the dirty bits that were set on this script by SetDirtyBits();</para>
        <para>This is automatically invoked when an update is sent for this object, but can be called manually as well.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.GetNetworkChannel">
      <summary>
        <para>This virtual function is used to specify the QoS channel to use for SyncVar updates for this script.</para>
        <para>Using the NetworkSettings custom attribute causes this function to be implemented for this script, but developers can also implement it themselves.</para>
      </summary>
      <returns>The QoS channel for this script.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.GetNetworkSendInterval">
      <summary>
        <para>This virtual function is used to specify the send interval to use for SyncVar updates for this script.</para>
        <para>Using the NetworkSettings custom attribute causes this function to be implemented for this script, but developers can also implement it themselves.</para>
      </summary>
      <returns>The time in seconds between updates.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.InvokeCommand(System.Int32,UnityEngine.Networking.NetworkReader)">
      <summary>Manually invoke a Command.</summary>
      <param name="cmdHash">Hash of the Command name.</param>
      <param name="reader">Parameters to pass to the command.</param>
      <returns>Returns true if successful.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.InvokeRPC(System.Int32,UnityEngine.Networking.NetworkReader)">
      <summary>Manually invoke an RPC function.</summary>
      <param name="cmdHash">Hash of the RPC name.</param>
      <param name="reader">Parameters to pass to the RPC function.</param>
      <returns>Returns true if successful.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.InvokeSyncEvent(System.Int32,UnityEngine.Networking.NetworkReader)">
      <summary>Manually invoke a SyncEvent.</summary>
      <param name="cmdHash">Hash of the SyncEvent name.</param>
      <param name="reader">Parameters to pass to the SyncEvent.</param>
      <returns>Returns true if successful.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnCheckObserver(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Callback used by the visibility system to determine if an observer (player) can see this object.</para>
        <para>If this function returns true, the network connection will be added as an observer.</para>
      </summary>
      <param name="conn">Network connection of a player.</param>
      <returns>True if the player can see this object.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnDeserialize(UnityEngine.Networking.NetworkReader,System.Boolean)">
      <summary>Virtual function to override to receive custom serialization data.</summary>
      <param name="reader">Reader to read from the stream.</param>
      <param name="initialState">True if being sent initial state.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnNetworkDestroy">
      <summary>
        <para>This is invoked on clients when the server has caused this object to be destroyed.</para>
        <para>This can be used as a hook to invoke effects or do client specific cleanup.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnRebuildObservers(System.Boolean)">
      <summary>
        <para>Callback used by the visibility system to (re)construct the set of observers that can see this object.</para>
        <para>Implementations of this callback should add network connections of players that can see this object to the observers set.</para>
      </summary>
      <param name="initialize">True if the set of observers is being built for the first time.</param>
      <returns>Return true if this function did work.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnSerialize(UnityEngine.Networking.NetworkWriter,System.Boolean)">
      <summary>Virtual function to override to send custom serialization data.</summary>
      <param name="writer">Writer to use to write to the stream.</param>
      <param name="initialState">If this is being called to send initial state.</param>
      <returns>True if data was written.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnSetLocalVisibility(System.Boolean)">
      <summary>
        <para>Callback used by the visibility system for objects on a host.</para>
        <para>Objects on a host (with a local client) cannot be disabled or destroyed when they are not visibile to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host.</para>
      </summary>
      <param name="vis">New visibility state.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnStartAuthority">
      <summary>
        <para>This is invoked on behaviours that have authority, based on context and the LocalPlayerAuthority value on the NetworkIdentity.</para>
        <para>This is called after OnStartServer and OnStartClient.When NetworkIdentity.AssignClientAuthority() is called on the server, this will be called on the client that owns the object. When an object is spawned with NetworkServer.SpawnWithClientAuthority(), this will be called on the client that owns the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnStartClient">
      <summary>
        <para>Called on every NetworkBehaviour when it is activated on a client.</para>
        <para>Objects on the host have this function called, as there is a local client on the host. The values of SyncVars on object are guaranteed to be initialized correctly with the latest state from the server when this function is called on the client.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnStartLocalPlayer">
      <summary>
        <para>Called when the local player object has been set up.</para>
        <para>This happens after OnStartClient(), as it is triggered by an ownership message from the server. This is an appropriate place to activate components or functionality that should only be active for the local player, such as cameras and input.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnStartServer">
      <summary>
        <para>Called when the server starts listening.</para>
        <para>This happens when an object is spawned, or for scene objects it happens when NetworkServer.SpawnObjects() is called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.OnStopAuthority">
      <summary>
        <para>This is invoked on behaviours when authority is removed.</para>
        <para>When NetworkIdentity.RemoveClientAuthority() is called on the server, this will be called on the client that owns the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.PreStartClient">
      <summary>An internal method called on client objects to resolve GameObject references.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkBehaviour.SetDirtyBit(System.UInt32)">
      <summary>Used to set the behaviour as dirty, so that a network update will be sent for the object.</summary>
      <param name="dirtyBit">Bit mask to set.</param>
    </member>
    <member name="F:UnityEngine.Networking.NetworkBroadcastResult.broadcastData">
      <summary>The data broadcast by the server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkBroadcastResult.serverAddress">
      <summary>The IP address of the server that broadcasts this data.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.active">
      <summary>True if a network client is currently active.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.allClients">
      <summary>
        <para>A list of all the active network clients in the current process.</para>
        <para>This is NOT a list of all clients that are connected to the remote server, it is client instances on the local game.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.connection">
      <summary>The NetworkConnection object this client is using.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.handlers">
      <summary>The registered network message handlers.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.hostTopology">
      <summary>
        <para>The host topology that this client is using.</para>
        <para>This is read-only once the client is started.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.isConnected">
      <summary>This gives the current connection status of the client.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.networkConnectionClass">
      <summary>
        <para>The class to use when creating new NetworkConnections.</para>
        <para>This can be set with SetNetworkConnectionClass.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.numChannels">
      <summary>The number of QoS channels currently configured for this client.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.peers">
      <summary>
        <para>The other network participants in the current game.</para>
        <para>This is only populated if the server has been configured to distribute peer information.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.serverIp">
      <summary>
        <para>The IP address of the server that this client is connected to.</para>
        <para>This will be empty if the client has not connected yet.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkClient.serverPort">
      <summary>
        <para>The port of the server that this client is connected to.</para>
        <para>This will be zero if the client has not connected yet.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.#ctor">
      <summary>Creates a new NetworkClient instance.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Configure(UnityEngine.Networking.ConnectionConfig,System.Int32)">
      <summary>
        <para>This configures the transport layer settings for a client.</para>
        <para>The settings in the ConnectionConfig or HostTopology object will be used to configure the transport layer connection used by this client. This must match the configuration of the server.</para>
      </summary>
      <param name="config">Transport layer configuration object.</param>
      <param name="maxConnections">The maximum number of connections to allow.</param>
      <returns>True if the configuration was successful.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Configure(UnityEngine.Networking.HostTopology)">
      <summary>
        <para>This configures the transport layer settings for a client.</para>
        <para>The settings in the ConnectionConfig or HostTopology object will be used to configure the transport layer connection used by this client. This must match the configuration of the server.</para>
      </summary>
      <param name="topology">Transport layer topology object.</param>
      <returns>True if the configuration was successful.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Connect(System.String,System.Int32)">
      <summary>
        <para>Connect client to a NetworkServer instance.</para>
        <para>Connecting to a server is asynchronous. There is connection message that is fired when the client connects. If the connection fails, a MsgType.SYSTEM_ERROR message will be generated. Once a connection is established you are able to send messages on the connection using NetworkClient.Send(). If using other features of the high level api, the client should call NetworkClient.IsReady() once it is ready to participate in the game. At that point the client will be sent spawned objects and state update messages.</para>
      </summary>
      <param name="serverIp">Target IP address or hostname.</param>
      <param name="serverPort">Target port number.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.ConnectWithSimulator(System.String,System.Int32,System.Int32,System.Single)">
      <summary>Connect client to a NetworkServer instance with simulated latency and packet loss.</summary>
      <param name="serverIp">Target IP address or hostname.</param>
      <param name="serverPort">Target port number.</param>
      <param name="latency">Simulated latency in milliseconds.</param>
      <param name="packetLoss">Simulated packet loss percentage.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Disconnect">
      <summary>
        <para>Disconnect from server.</para>
        <para>The disconnect message will be invoked.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.GetConnectionStats">
      <summary>Retrieves statistics about the network packets sent on this connection.</summary>
      <returns>Dictionary of packet statistics for the client's connection.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.GetRTT">
      <summary>
        <para>Gets the Return Trip Time for this connection.</para>
        <para>This value is calculated by the UTransport layer.</para>
      </summary>
      <returns>Return trip time in milliseconds.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.GetStatsIn(System.Int32@,System.Int32@)">
      <summary>Get inbound network statistics for the client.</summary>
      <param name="numMsgs">Number of messages received so far.</param>
      <param name="numBytes">Number of bytes received so far.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.GetStatsOut(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>Get outbound network statistics for the client.</summary>
      <param name="numMsgs">Number of messages sent so far (including collated messages send through buffer).</param>
      <param name="numBufferedMsgs">Number of messages sent through buffer.</param>
      <param name="numBytes">Number of bytes sent so far.</param>
      <param name="lastBufferedPerSecond">Number of messages buffered for sending per second.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.RegisterHandler(System.Int16,UnityEngine.Networking.NetworkMessageDelegate)">
      <summary>
        <para>Register a handler for a particular message type.</para>
        <para>There are several system message types which you can add handlers for. You can also add your own message types.</para>
      </summary>
      <param name="msgType">Message type number.</param>
      <param name="handler">Function handler which will be invoked for when this message type is received.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.ResetConnectionStats">
      <summary>
        <para>Resets the statistics return by NetworkClient.GetConnectionStats() to zero values.</para>
        <para>Useful when building per-second network statistics.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Send(System.Int16,UnityEngine.Networking.MessageBase)">
      <summary>
        <para>This sends a network message with a message Id to the server. This message is sent on channel zero, which be default is the reliable channel.</para>
        <para>The message must be an instance of a class derived from MessageBase.</para>
        <para>The message id passed to Send() is used to identify the handler function to invoke on the server when the message is received.</para>
      </summary>
      <param name="msgType">The id of the message to send.</param>
      <param name="msg">A message instance to send.</param>
      <returns>True if message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SendByChannel(System.Int16,UnityEngine.Networking.MessageBase,System.Int32)">
      <summary>
        <para>This sends a network message with a message Id to the server on a specific channel.</para>
        <para>This does the same thing as NetworkClient.Send(), but allows a transport layer QoS channel to be specified.</para>
      </summary>
      <param name="msgType">The id of the message to send.</param>
      <param name="msg">The message to send.</param>
      <param name="channelId">The channel to send the message on.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SendBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>
        <para>This sends the data in an array of bytes to the server that the client is connected to.</para>
        <para>The data must be properly formatted.</para>
      </summary>
      <param name="data">Data to send.</param>
      <param name="numBytes">Number of bytes of data.</param>
      <param name="channelId">The QoS channel to send data on.</param>
      <returns>True if successfully sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SendUnreliable(System.Int16,UnityEngine.Networking.MessageBase)">
      <summary>
        <para>This sends a network message with a message Id to the server on channel one, which be default is the un-reliable channel.</para>
        <para>This does the same thing as NetworkClient.Send(), except that it send on the unreliable channel.</para>
      </summary>
      <param name="msgType">The message id to send.</param>
      <param name="msg">The message to send.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SendWriter(UnityEngine.Networking.NetworkWriter,System.Int32)">
      <summary>
        <para>This sends the contents of the NetworkWriter's buffer to the connected server on the specified channel.</para>
        <para>The format of the data in the writer must be properly formatted for it to be processed as a message by the server. The functions StartMessage() and FinishMessage() can be used to properly format messages:</para>
      </summary>
      <param name="writer">Writer object containing data to send.</param>
      <param name="channelId">QoS channel to send data on.</param>
      <returns>True if data successfully sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SetMaxDelay(System.Single)">
      <summary>Set the maximum amount of time that can pass for transmitting the send buffer.</summary>
      <param name="seconds">Delay in seconds.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.SetNetworkConnectionClass">
      <summary>
        <para>This sets the class that is used when creating new network connections.</para>
        <para>The class must be derived from NetworkConnection.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.Shutdown">
      <summary>
        <para>Shut down a client.</para>
        <para>This should be done when a client is no longer going to be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.UnregisterHandler(System.Int16)">
      <summary>Unregisters a network message handler.</summary>
      <param name="msgType">The message type to unregister.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.GetTotalConnectionStats">
      <summary>Retrieves statistics about the network packets sent on all connections.</summary>
      <returns>Dictionary of stats.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkClient.ShutdownAll">
      <summary>
        <para>Shuts down all network clients.</para>
        <para>This also shuts down the transport layer.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.address">
      <summary>The IP address associated with the connection.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkConnection.clientOwnedObjects">
      <summary>
        <para>A list of the NetworkIdentity objects owned by this connection.</para>
        <para>This includes the player object for the connection - if it has localPlayerAutority set, and any objects spawned with local authority or set with AssignLocalAuthority. This list is read only. This list can be used to validate messages from clients, to ensure that clients are only trying to control objects that they own.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.connectionId">
      <summary>
        <para>Unique identifier for this connection.</para>
        <para>Connect Ids begin at one for remote connections.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.hostId">
      <summary>Transport level host id for this connection.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.isReady">
      <summary>
        <para>Flag that tells if the connection has been marked as "ready" by a client calling ClientScene.Ready().</para>
        <para>This property is read-only. It is set by the system on the client when ClientScene.Ready() is called, and set by the system on the server when a ready message is received from a client.A client that is ready is sent spawned objects by the server and updates to the state of spawned objects. A client that is not ready is not sent spawned objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.lastMessageTime">
      <summary>
        <para>The last time that a message was received on this connection.</para>
        <para>This includes internal system messages (such as Commands and ClientRpc calls) and user messages.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkConnection.logNetworkMessages">
      <summary>
        <para>Setting this to true will log the contents of network message to the console.</para>
        <para>Warning: this can be a lot of data and can be very slow. Both incoming and outgoing messages are logged. The format of the logs is:ConnectionSend con:1 bytes:11 msgId:5 FB59D743FD120000000000 ConnectionRecv con:1 bytes:27 msgId:8 14F21000000000016800AC3FE090C240437846403CDDC0BD3B0000Note that these are application level network messages, not protocol level packets. There will typically be multiple network messages combined in a single protocol packet.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkConnection.playerControllers">
      <summary>
        <para>The list of players for this connection.</para>
        <para>In most cases this will be a single player. But, for "Couch Multiplayer" there could be multiple players for a single client. To see the players on your own client see <see cref="P:UnityEngine.Networking.ClientScene.localPlayers" /> list.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.Disconnect">
      <summary>Disconnects this connection.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.Dispose">
      <summary>Disposes of this connection, releasing channel buffers that it holds.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.FlushChannels">
      <summary>
        <para>This causes the channels of the network connection to flush their data to the transport layer.</para>
        <para>This is called automatically by connections used by NetworkServer and NetworkClient, but can be called manually for connections used in other contexts.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.GetStatsIn(System.Int32@,System.Int32@)">
      <summary>Get statistics for incoming traffic.</summary>
      <param name="numMsgs">Number of messages received.</param>
      <param name="numBytes">Number of bytes received.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.GetStatsOut(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>Get statistics for outgoing traffic.</summary>
      <param name="numMsgs">Number of messages sent.</param>
      <param name="numBufferedMsgs">Number of messages currently buffered for sending.</param>
      <param name="numBytes">Number of bytes sent.</param>
      <param name="lastBufferedPerSecond">How many messages were buffered in the last second.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.HandleBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>
        <para>This makes the connection process the data contained in the buffer, and call handler functions.</para>
        <para>The data is assumed to have come from the network, and contains network messages.This function is used by network connections when they receive data.</para>
      </summary>
      <param name="buffer">Data to process.</param>
      <param name="receivedSize">Size of the data to process.</param>
      <param name="channelId">Channel the data was recieved on.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.HandleReader(UnityEngine.Networking.NetworkReader,System.Int32,System.Int32)">
      <summary>
        <para>This makes the connection process the data contained in the stream, and call handler functions.</para>
        <para>The data in the stream is assumed to have come from the network, and contains network messages.This function is used by network connections when they receive data.</para>
      </summary>
      <param name="reader">Stream that contains data.</param>
      <param name="receivedSize">Size of the data.</param>
      <param name="channelId">Channel the data was received on.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.Initialize(System.String,System.Int32,System.Int32,UnityEngine.Networking.HostTopology)">
      <summary>
        <para>This inializes the internal data structures of a NetworkConnection object, including channel buffers.</para>
        <para>This is called by NetworkServer and NetworkClient on connection objects, but if used outside of that context, this function should be called before the connection is used.</para>
      </summary>
      <param name="hostTopology">The topology to be used.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.InvokeHandler(System.Int16,UnityEngine.Networking.NetworkReader,System.Int32)">
      <summary>
        <para>This function invokes the registered handler function for a message.</para>
        <para>Network connections used by the NetworkClient and NetworkServer use this function for handling network messages.</para>
      </summary>
      <param name="msgType">The message type of the handler to use.</param>
      <param name="reader">The stream to read the contents of the message from.</param>
      <param name="channelId">The channel that the message arrived on.</param>
      <returns>True if a handler function was found and invoked.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.InvokeHandler(UnityEngine.Networking.NetworkMessage)">
      <summary>
        <para>This function invokes the registered handler function for a message.</para>
        <para>Network connections used by the NetworkClient and NetworkServer use this function for handling network messages.</para>
      </summary>
      <param name="netMsg">The message object to process.</param>
      <returns>True if a handler function was found and invoked.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.InvokeHandlerNoData(System.Int16)">
      <summary>
        <para>This function invokes the registered handler function for a message, without any message data.</para>
        <para>This is useful to invoke handlers that dont have any additional data, such as the handlers for MsgType.Connect.</para>
      </summary>
      <param name="msgType">The message id of the handler to invoke.</param>
      <returns>True if a handler function was found and invoked.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.RegisterHandler(System.Int16,UnityEngine.Networking.NetworkMessageDelegate)">
      <summary>This registers a handler function for a message Id.</summary>
      <param name="msgType">The message Id to register.</param>
      <param name="handler">The handler function to register.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.ResetStats">
      <summary>Resets the statistics that are returned from NetworkClient.GetConnectionStats().</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.Send(System.Int16,UnityEngine.Networking.MessageBase)">
      <summary>This sends a network message with a message Id on the connection. This message is sent on channel zero, which be default is the reliable channel.</summary>
      <param name="msgType">The id of the message to send.</param>
      <param name="msg">The message to send.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SendByChannel(System.Int16,UnityEngine.Networking.MessageBase,System.Int32)">
      <summary>This sends a network message on the connection using a specific transport layer channel.</summary>
      <param name="msgType">The message id to send.</param>
      <param name="msg">The message to send.</param>
      <param name="channelId">The transport layer channel to send on.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SendBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>This sends an array of bytes on the connection.</summary>
      <param name="bytes">The array of data to be sent.</param>
      <param name="numBytes">The number of bytes in the array to be sent.</param>
      <param name="channelId">The transport channel to send on.</param>
      <returns>Success if data was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SendUnreliable(System.Int16,UnityEngine.Networking.MessageBase)">
      <summary>This sends a network message with a message Id on the connection. This message is sent on channel one, which be default is the un-reliable channel.</summary>
      <param name="msgType">The message id to send.</param>
      <param name="msg">The message to send.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SendWriter(UnityEngine.Networking.NetworkWriter,System.Int32)">
      <summary>
        <para>This sends the contents of a NetworkWriter object on the connection.</para>
        <para>The example below constructs a writer and sends it on a connection.</para>
      </summary>
      <param name="writer">A writer object containing data to send.</param>
      <param name="channelId">The transport channel to send on.</param>
      <returns>True if the data was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SetChannelOption(System.Int32,UnityEngine.Networking.ChannelOption,System.Int32)">
      <summary>
        <para>This sets an option on the network channel.</para>
        <para>Channel options are usually advanced tuning parameters.</para>
      </summary>
      <param name="channelId">The channel the option will be set on.</param>
      <param name="option">The option to set.</param>
      <param name="value">The value for the option.</param>
      <returns>True if the option was set.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.SetMaxDelay(System.Single)">
      <summary>The maximum time in seconds that messages are buffered before being sent.</summary>
      <param name="seconds">Time in seconds.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.ToString">
      <summary>Returns a string representation of the NetworkConnection object state.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.TransportRecieve(System.Byte[],System.Int32,System.Int32)">
      <summary>
        <para>This virtual function allows custom network connection classes to process data from the network before it is passed to the application.</para>
        <para>The default implementation of this function calls HandleBytes() on the received data. Custom implmentations can also use HandleBytes(), but can pass modified versions of the data received or other data.This example logs the data received to the console, then passes it to HandleBytes.</para>
        <para>Other uses for this function could be data compression or data encryption.Custom network connection classes are used by setting NetworkServer.NetworkConnectionClass and NetworkClient.NetworkConnectionClass.</para>
      </summary>
      <param name="bytes">The data recieved.</param>
      <param name="numBytes">The size of the data recieved.</param>
      <param name="channelId">The channel that the data was received on.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.TransportSend(System.Byte[],System.Int32,System.Int32,System.Byte@)">
      <summary>
        <para>This virtual function allows custom network connection classes to process data send by the application before it goes to the network transport layer.</para>
        <para>The default implementation of this function calls NetworkTransport.Send() with the supplied data, but custom implementations can pass modified versions of the data. This example logs the sent data to the console:</para>
        <para>Other uses for this function could be data compression or data encryption.Custom network connection classes are used by setting NetworkServer.NetworkConnectionClass and NetworkClient.NetworkConnectionClass.</para>
      </summary>
      <param name="bytes">Data to send.</param>
      <param name="numBytes">Size of data to send.</param>
      <param name="channelId">Channel to send data on.</param>
      <param name="error">Error code for send.</param>
      <returns>True if data was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkConnection.UnregisterHandler(System.Int16)">
      <summary>This removes the handler registered for a message Id.</summary>
      <param name="msgType">The message id to unregister.</param>
    </member>
    <member name="P:UnityEngine.Networking.NetworkCRC.scriptCRCCheck">
      <summary>
        <para>Enables a CRC check between server and client that ensures the <see cref="T:UnityEngine.Networking.NetworkBehaviour" /> scripts match.</para>
        <para>This may not be appropriate in some cases, such a when the client and server are different Unity projects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkCRC.scripts">
      <summary>
        <para>A dictionary of script QoS channels.</para>
        <para>This is used to compare script network configurations between clients and servers.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkCRC.RegisterBehaviour(System.String,System.Int32)">
      <summary>This is used to setup script network settings CRC data.</summary>
      <param name="name">Script name.</param>
      <param name="channel">QoS Channel.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkCRC.ReinitializeScriptCRCs">
      <summary>
        <para>This can be used to reinitialize the set of script CRCs.</para>
        <para>This is very rarely required - only when NetworkBehaviour scripts are dynamically loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastData">
      <summary>
        <para>The data to include in the broadcast message when running as a server.</para>
        <para>If using NetworkManager integration, this will be overriden with the NetworkManager's address.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastInterval">
      <summary>How often in milliseconds to broadcast when running as a server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastKey">
      <summary>A key to identify this application in broadcasts.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastPort">
      <summary>The network port to broadcast on and listen to.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastsReceived">
      <summary>
        <para>A dictionary of broadcasts received from servers.</para>
        <para>The key is the server address, and the value is a NetworkBroadcastResult object that contains the data sent by the server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastSubVersion">
      <summary>The sub-version of the application to broadcast. This is used to match versions of the same application.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.broadcastVersion">
      <summary>The version of the application to broadcast. This is used to match versions of the same application.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.hostId">
      <summary>The TransportLayer hostId being used (read-only).</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.isClient">
      <summary>True if running in client mode (read-only).</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.isServer">
      <summary>True if running in server mode (read-only).</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.offsetX">
      <summary>The horizontal offset of the GUI if active.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.offsetY">
      <summary>The vertical offset of the GUI if active.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.running">
      <summary>True is broadcasting or listening (read-only).</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.showGUI">
      <summary>True to draw the default Broacast control UI.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkDiscovery.useNetworkManager">
      <summary>
        <para>True to integrate with the NetworkManager.</para>
        <para>When running as a server, this will include the NetworkManager's address in broadcast messages. When running as a client, this will be able to join matching games found by using the NetworkManager.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkDiscovery.Initialize">
      <summary>Initializes the NetworkDiscovery component.</summary>
      <returns>Return true if the network port was available.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkDiscovery.OnReceivedBroadcast(System.String,System.String)">
      <summary>This is a virtual function that can be implemented to handle broadcast messages when running as a client.</summary>
      <param name="fromAddress">The IP address of the server.</param>
      <param name="data">The data broadcast by the server.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkDiscovery.StartAsClient">
      <summary>Starts listening for broadcasts messages.</summary>
      <returns>True is able to listen.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkDiscovery.StartAsServer">
      <summary>Starts sending broadcast messages.</summary>
      <returns>True is able to broadcast.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkDiscovery.StopBroadcast">
      <summary>Stops listening and broadcasting.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkHash128.IsValid">
      <summary>A valid NetworkHash has a non-zero value.</summary>
      <returns>True if the value is non-zero.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkHash128.Reset">
      <summary>Resets the value of a NetworkHash to zero (invalid).</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkHash128.ToString">
      <summary>Returns a string representation of a NetworkHash object.</summary>
      <returns>A hex asset string.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkHash128.Parse(System.String)">
      <summary>This parses the string representation of a NetworkHash into a binary object.</summary>
      <param name="text">A hex string to parse.</param>
      <returns>A 128 bit network hash object.</returns>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.assetId">
      <summary>Unique identifier used to find the source assets when server spawns the on clients.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.clientAuthorityOwner">
      <summary>
        <para>The client that has authority for this object. This will be null if no client has authority.</para>
        <para>This is set for player objects his LocalPlayerAuthority, and for objects set with AssignClientAuthority, and spawned with SpawnWithClientAuthority.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.connectionToClient">
      <summary>The UConnection associated with this NetworkIdentity. This is only valid for player objects on the server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.connectionToServer">
      <summary>The UConnection associated with this NetworkIdentity. This is only valid for player objects on a local client.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.hasAuthority">
      <summary>
        <para>This returns true if this object is the authoritative version of the object in the distributed network application.</para>
        <para>This value is determined at runtime, as opposed to LocalPlayerAuthority which is set on the prefab. For most objects, authority is held by the server / host. For objects with LocalPlayerAuthority set, authority is held by the client of that player.For objects that had their authority set by AssignClientAuthority on the server, this will be true on the client that owns the object. NOT on other clients.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.isClient">
      <summary>Returns true if running as a client and this object was spawned by a server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.isLocalPlayer">
      <summary>
        <para>This returns true if this object is the one that represents the player on the local machine.</para>
        <para>This is set when the server has spawned an object for this particular client.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.isServer">
      <summary>Returns true if running as a server, which spawned the object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.localPlayerAuthority">
      <summary>
        <para>LocalPlayerAuthority means that the client of the "owning" player has authority over their own player object.</para>
        <para>Authority for this object will be on the player's client. So hasAuthority will be true on that client - and false on the server and on other clients.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.netId">
      <summary>Unique identifier for this particular object instance, used for tracking objects between networked clients and the server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.observers">
      <summary>The set of network connections (players) that can see this object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.playerControllerId">
      <summary>
        <para>The id of the player associated with this object.</para>
        <para>This will only be valid if this object is for a local player.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.sceneId">
      <summary>
        <para>A unique identifier for NetworkIdentity objects within a scene.</para>
        <para>This is used for spawning scene objects on clients.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkIdentity.serverOnly">
      <summary>Flag to make this object only exist when the game is running as a server (or host).</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkIdentity.AssignClientAuthority(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>This assigns control of an object to a client via the client's NetworkConnection.</para>
        <para>This causes hasAuthority to be set on the client that owns the object, and OnStartAuthority will be called on that client. This object then will be in the clientOwnedObjects list for the connection.Authority can be removed with RemoveClientAuthority. Only one client can own an object at any time. Only NetworkIdentities with LocalPlayerAuthority set can have client authority assigned. This does not need to be called for player objects, as their authority is setup automatically.</para>
      </summary>
      <param name="conn">The connection of the client to assign authority to.</param>
      <returns>True if authority was assigned.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkIdentity.ForceSceneId(System.Int32)">
      <summary>
        <para>Force the scene ID to a specific value.</para>
        <para>This can be used to fix an invalid scene ID. If you process all the NetworkIdentity components in a scene you can assign them new values starting from 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkIdentity.RebuildObservers(System.Boolean)">
      <summary>This causes the set of players that can see this object to be rebuild. The OnRebuildObservers callback function will be invoked on each NetworkBehaviour.</summary>
      <param name="initialize">True if this is the first time.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkIdentity.RemoveClientAuthority(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Removes ownership for an object for a client by its conneciton.</para>
        <para>This applies to objects that had authority set by AssignClientAuthority, or SpawnWithClientAuthority. Authority cannot be removed for player objects.</para>
      </summary>
      <param name="conn">The connection of the client to remove authority for.</param>
      <returns>True if authority is removed.</returns>
    </member>
    <member name="F:UnityEngine.Networking.NetworkInstanceId.Invalid">
      <summary>
        <para>A static invalid NetworkInstanceId that can be used for comparisons.</para>
        <para>The default value of NetworkInstanceId.Value is zero, and IsEmpty() can be used to check this. But NetworkInstanceId.Invalid is available for specifically setting and checking for invalid IDs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkInstanceId.Value">
      <summary>The internal value of this identifier.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkInstanceId.IsEmpty">
      <summary>
        <para>Returns true if the value of the NetworkInstanceId is zero.</para>
        <para>Object that have not been spawned will have a value of zero.</para>
      </summary>
      <returns>True if zero.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkInstanceId.ToString">
      <summary>Returns a string of "NetID:value".</summary>
      <returns>String representation of this object.</returns>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.gamePlayerPrefab">
      <summary>
        <para>This is the prefab of the player to be created in the PlayScene.</para>
        <para>When CheckReadyToBegin starts the game from the lobby, a new player object is created from this prefab, and that object is made the active player object using [NetworkServer.ReplacePlayerForConnection].</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.lobbyPlayerPrefab">
      <summary>
        <para>This is the prefab of the player to be created in the LobbyScene.</para>
        <para>This prefab must have a NetworkLobbyPlayer component on it.In the lobby scene, this will be the active player object, but in other scenes while the game is running, this will be replaced by a player object created from the GamePlayerPrefab. But once returned to the lobby scene this will again become the active player object.This can be used to store user data that persists for the lifetime of the session, such as color choices or weapon choices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.lobbyScene">
      <summary>The scene to use for the lobby. This is similar to the offlineScene of the NetworkManager.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkLobbyManager.lobbySlots">
      <summary>
        <para>These slots track players that enter the lobby.</para>
        <para>The slotId on players is global to the game - across all players.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.maxPlayers">
      <summary>
        <para>The maximum number of players allowed in the game.</para>
        <para>Note that this is the number "players" not clients or connections. There can be multiple players per client.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.maxPlayersPerConnection">
      <summary>
        <para>The maximum number of players per connection.</para>
        <para>Calling [ClientScene.AddPlayer] will fail if this limit is reached.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.minPlayers">
      <summary>
        <para>The minimum number of players required to be ready for the game to start.</para>
        <para>If this is zero then the game can start with any number of players.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.playScene">
      <summary>The scene to use for the playing the game from the lobby. This is similar to the onlineScene of the NetworkManager.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyManager.showLobbyGUI">
      <summary>
        <para>This flag enables display of the default lobby UI.</para>
        <para>This is rendered using the old GUI system, so is only recommended for testing purposes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.CheckReadyToBegin">
      <summary>
        <para>CheckReadyToBegin checks all of the players in the lobby to see if their readyToBegin flag is set.</para>
        <para>If all of the players are ready, then the server switches from the LobbyScene to the PlayScene - essentially starting the game. This is called automatically in response to NetworkLobbyPlayer.SendReadyToBeginMessage().</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientAddPlayerFailed">
      <summary>
        <para>Called on the client when adding a player to the lobby fails.</para>
        <para>This could be because the lobby is full, or the connection is not allowed to have more players.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientConnect(UnityEngine.Networking.NetworkConnection)">
      <summary>This is called on the client when it connects to server.</summary>
      <param name="conn">The connection that connected.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientDisconnect(UnityEngine.Networking.NetworkConnection)">
      <summary>This is called on the client when disconnected from a server.</summary>
      <param name="conn">The connection that disconnected.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientEnter">
      <summary>This is a hook to allow custom behaviour when the game client enters the lobby.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientExit">
      <summary>This is a hook to allow custom behaviour when the game client exits the lobby.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyClientSceneChanged(UnityEngine.Networking.NetworkConnection)">
      <summary>This is called on the client when the client is finished loading a new networked scene.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerConnect(UnityEngine.Networking.NetworkConnection)">
      <summary>This is called on the server when a new client connects to the server.</summary>
      <param name="conn">The new connection.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerCreateGamePlayer(UnityEngine.Networking.NetworkConnection,System.Int16)">
      <summary>
        <para>This allows customization of the creation of the GamePlayer object on the server.</para>
        <para>By default the gamePlayerPrefab is used to create the game-player, but this function allows that behaviour to be customized. The object returned from the function will be used to replace the lobby-player on the connection.</para>
      </summary>
      <param name="conn">The connection the player object is for.</param>
      <param name="playerControllerId">The controllerId of the player on the connnection.</param>
      <returns>A new GamePlayer object.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerCreateLobbyPlayer(UnityEngine.Networking.NetworkConnection,System.Int16)">
      <summary>
        <para>This allows customization of the creation of the lobby-player object on the server.</para>
        <para>By default the lobbyPlayerPrefab is used to create the lobby-player, but this function allows that behaviour to be customized.</para>
      </summary>
      <param name="conn">The connection the player object is for.</param>
      <param name="playerControllerId">The controllerId of the player.</param>
      <returns>The new lobby-player object.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerDisconnect(UnityEngine.Networking.NetworkConnection)">
      <summary>This is called on the server when a client disconnects.</summary>
      <param name="conn">The connection that disconnected.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerPlayerRemoved(UnityEngine.Networking.NetworkConnection,System.Int16)">
      <summary>This is called on the server when a player is removed.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerPlayersReady">
      <summary>
        <para>This is called on the server when all the players in the lobby are ready.</para>
        <para>The default implementation of this function uses ServerChangeScene() to switch to the game player scene. By implementing this callback you can customize what happens when all the players in the lobby are ready, such as adding a countdown or a confirmation for a group leader.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerSceneChanged(System.String)">
      <summary>This is called on the server when a networked scene finishes loading.</summary>
      <param name="sceneName">Name of the new scene.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyServerSceneLoadedForPlayer(UnityEngine.GameObject,UnityEngine.GameObject)">
      <summary>
        <para>This is called on the server when it is told that a client has finished switching from the lobby scene to a game player scene.</para>
        <para>When switching from the lobby, the lobby-player is replaced with a game-player object. This callback function gives an opportunity to apply state from the lobby-player to the game-player object.</para>
      </summary>
      <param name="lobbyPlayer">The lobby player object.</param>
      <param name="gamePlayer">The game player object.</param>
      <returns>False to not allow this player to replace the lobby player.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyStartClient(UnityEngine.Networking.NetworkClient)">
      <summary>This is called on the client when a client is started.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyStartHost">
      <summary>This is called on the host when a host is started.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyStartServer">
      <summary>This is called on the server when the server is started - including when a host is started.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyStopClient">
      <summary>This is called on the client when the client stops.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.OnLobbyStopHost">
      <summary>This is called on the host when the host is stopped.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.SendReturnToLobby">
      <summary>Sends a message to the server to make the game return to the lobby scene.</summary>
      <returns>True if message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.ServerReturnToLobby">
      <summary>Calling this causes the server to switch back to the lobby scene.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyManager.TryToAddPlayer">
      <summary>
        <para>This is used on clients to attempt to add a player to the game.</para>
        <para>This may fail if the game is full or the connection cannot have more players.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyPlayer.readyToBegin">
      <summary>
        <para>This is a flag that control whether this player is ready for the game to begin.</para>
        <para>When all players are ready to begin, the game will start. This should not be set directly, the SendReadyToBeginMessage function should be called on the client to set it on the server.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkLobbyPlayer.ShowLobbyGUI">
      <summary>
        <para>This flag controls whether the default UI is shown for the lobby player.</para>
        <para>As this UI is rendered using the old GUI system, it is only recommended for testing purposes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkLobbyPlayer.slot">
      <summary>
        <para>The slot within the lobby that this player inhabits.</para>
        <para>Lobby slots are global for the game - each player has a unique slotId.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.OnClientEnterLobby">
      <summary>This is a hook that is invoked on all player objects when entering the lobby.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.OnClientExitLobby">
      <summary>This is a hook that is invoked on all player objects when exiting the lobby.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.RemovePlayer">
      <summary>
        <para>This removes this player from the lobby.</para>
        <para>This player object will be destroyed - on the server and on all clients.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.SendNotReadyToBeginMessage">
      <summary>This is used on clients to tell the server that this player is not ready for the game to begin.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.SendReadyToBeginMessage">
      <summary>This is used on clients to tell the server that this player is ready for the game to begin.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkLobbyPlayer.SendSceneLoadedMessage">
      <summary>
        <para>This is used on clients to tell the server that the client has switched from the lobby to the GameScene and is ready to play.</para>
        <para>This message triggers the server to replace the lobby player with the game player.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.networkSceneName">
      <summary>
        <para>The name of the current network scene.</para>
        <para>This is populated if the NetworkManager is doing scene management. This should not be changed directly. Calls to ServerChangeScene() cause this to change. New clients that connect to a server will automatically load this scene.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.singleton">
      <summary>The NetworkManager singleton object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.autoCreatePlayer">
      <summary>A flag to control whether or not player objects are automatically created on connect, and on scene change.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.channels">
      <summary>The Quality-of-Service channels to use for the network transport layer.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.client">
      <summary>
        <para>The current NetworkClient being used by the manager.</para>
        <para>This is populated when StartClient or StartLocalClient are called.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.connectionConfig">
      <summary>
        <para>The custom network configuration to use.</para>
        <para>This will be used to configure the network transport layer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.customConfig">
      <summary>Flag to enable custom network configuration.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.dontDestroyOnLoad">
      <summary>
        <para>A flag to control whether the NetworkManager object is destroyed when the scene changes.</para>
        <para>This should be set if your game has a single NetworkManager that exists for the lifetime of the process. If there is a NetworkManager in each scene, then this should not be set.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.isNetworkActive">
      <summary>
        <para>True if the NetworkServer or NetworkClient isactive.</para>
        <para>This is read-only. Calling StopServer() or StopClient() turns this off.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.logLevel">
      <summary>The log level specifically to user for network log messages.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.matches">
      <summary>
        <para>The list of matches that are available to join.</para>
        <para>This will be populated if UMatch.ListMatches() has been called.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.matchHost">
      <summary>The hostname of the matchmaking server.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.matchInfo">
      <summary>
        <para>A MatchInfo instance that will be used when StartServer() or StartClient() are called.</para>
        <para>Populating NetworkManager.matchInfo will make the game user the MatchMaker and RelayServer.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.matchMaker">
      <summary>
        <para>The UMatch matchmaker object.</para>
        <para>This is populated if StartMatchMaker() has been called. It is used to communicate with the matchmaking service.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.matchName">
      <summary>The name of the current match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.matchPort">
      <summary>The port of the matchmaking service.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManager.matchSize">
      <summary>The maximum number of players in the current match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.maxConnections">
      <summary>
        <para>The maximum number of concurrent network connections to support.</para>
        <para>The effects the memory usage of the network layer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.maxDelay">
      <summary>
        <para>The maximum delay before sending packets on connections.</para>
        <para>In seconds. The default of 0.01 seconds means packets will be delayed at most by 10 milliseconds. Setting this to zero will disable HLAPI connection buffering.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.networkAddress">
      <summary>
        <para>The network address currently in use.</para>
        <para>For clients, this is the address of the server that is connected to. For servers, this is the local address.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.networkPort">
      <summary>
        <para>The network port currently in use.</para>
        <para>For clients, this is the port of the server connected to. For servers, this is the listen port.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.numPlayers">
      <summary>
        <para>NumPlayers is the number of active player objects across all connections on the server.</para>
        <para>This is only valid on the host / server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.offlineScene">
      <summary>
        <para>The scene to switch to when offline.</para>
        <para>Setting this makes the NetworkManager do scene management. This scene will be switched to when a network session is completed - such as a client disconnect, or a server shutdown.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.onlineScene">
      <summary>
        <para>The scene to switch to when online.</para>
        <para>Setting this makes the NetworkManager do scene management. This scene will be switched to when a network session is started - such as a client connect, or a server listen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.packetLossPercentage">
      <summary>
        <para>The percentage of incoming and outgoing packets to be dropped for clients.</para>
        <para>This is only used when useSimulator is set.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.playerPrefab">
      <summary>
        <para>The default prefab to be used to create player objects on the server.</para>
        <para>Player objects are created in the default handler for AddPlayer() on the server. Implementing OnServerAddPlayer overrides this behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.playerSpawnMethod">
      <summary>The current method of spawning players used by the NetworkManager.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.runInBackground">
      <summary>
        <para>Controls whether the program runs when it is in the background.</para>
        <para>This is required when multiple instances of a program using networking are running on the same machine, such as when testing using localhost. But this is not recommended when deploying to mobile platforms.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.scriptCRCCheck">
      <summary>
        <para>Flag for using the script CRC check between server and clients.</para>
        <para>Enables a CRC check between server and client that ensures the NetworkBehaviour scripts match. This may not be appropriate in some cases, such a when the client and server are different Unity projects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.secureTunnelEndpoint">
      <summary>
        <para>Allows you to specify an EndPoint object instead of setting networkAddress and networkPort (required for some platforms such as Xbox One).</para>
        <para>Setting this object overrides the networkAddress and networkPort fields, and will be used instead of making connections.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.sendPeerInfo">
      <summary>A flag to control sending the network information about every peer to all members of a match.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.serverBindAddress">
      <summary>
        <para>The IP address to bind the server to.</para>
        <para>This is only used if serverBindToIP is set to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.serverBindToIP">
      <summary>
        <para>Flag to tell the server whether to bind to a specific IP address.</para>
        <para>If this is false, then no specific IP address is bound to (IP_ANY).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.simulatedLatency">
      <summary>
        <para>The delay in milliseconds to be added to incoming and outgoing packets for clients.</para>
        <para>This is only used when useSimulator is set.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.spawnPrefabs">
      <summary>
        <para>List of prefabs that will be registered with the spawning system.</para>
        <para>For each of these prefabs, ClientManager.RegisterPrefab() will be automatically invoke.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.startPositions">
      <summary>The list of currently registered player start positions for the current scene.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkManager.useSimulator">
      <summary>Flag that control whether clients started by this NetworkManager will use simulated latency and packet loss.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.GetStartPosition">
      <summary>
        <para>This finds a spawn position based on NetworkStartPosition objects in the scene.</para>
        <para>This is used by the default implementation of OnServerAddPlayer.</para>
      </summary>
      <returns>Returns the transform to spawn a player at, or null.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.IsClientConnected">
      <summary>
        <para>This checks if the NetworkManager has a client and that it is connected to a server.</para>
        <para>This is more specific than NetworkClient.isActive, which will be true if there are any clients active, rather than just the NetworkManager's client.</para>
      </summary>
      <returns>True if the NetworkManagers client is connected to a server.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnClientConnect(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Called on the client when connected to a server.</para>
        <para>The default implementation of this function sets the client as ready and adds a player.</para>
      </summary>
      <param name="conn">Connection to the server.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnClientDisconnect(UnityEngine.Networking.NetworkConnection)">
      <summary>Called on clients when disconnected from a server.</summary>
      <param name="conn">Connection to the server.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnClientError(UnityEngine.Networking.NetworkConnection,System.Int32)">
      <summary>Called on clients when a network error occurs.</summary>
      <param name="conn">Connection to a server.</param>
      <param name="errorCode">Error code.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnClientNotReady(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Called on clients when a servers tells the client it is no longer ready.</para>
        <para>This is commonly used when switching scenes.</para>
      </summary>
      <param name="conn">Connection to a server.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnClientSceneChanged(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Called on clients when a scene has completed loaded, when the scene load was initiated by the server.</para>
        <para>Scene changes can cause player objects to be destroyed. The default implementation of OnClientSceneChanged in the NetworkManager is to add a player object for the connection if no player object exists.</para>
      </summary>
      <param name="conn">The network connection that the scene change message arrived on.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnMatchCreate(UnityEngine.Networking.Match.CreateMatchResponse)">
      <summary>
        <para>This is invoked when a match has been created.</para>
        <para>The default implementation of this starts a host for the match.</para>
      </summary>
      <param name="matchInfo">Info about the match that has been created.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnMatchJoined(UnityEngine.Networking.Match.JoinMatchResponse)">
      <summary>
        <para>This is invoked when a match is joined.</para>
        <para>The default implementation of this starts a client.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnMatchList(UnityEngine.Networking.Match.ListMatchResponse)">
      <summary>
        <para>This is invoked when a list of matches is returned from ListMatches().</para>
        <para>The default implementation of this just stores the list of matches.</para>
      </summary>
      <param name="matchList">A list of available matches.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerAddPlayer(UnityEngine.Networking.NetworkConnection,System.Int16)">
      <summary>
        <para>Called on the server when a client adds a new player with ClientScene.AddPlayer.</para>
        <para>The default implementation for this function creates a new player object from the playerPrefab.</para>
      </summary>
      <param name="conn">Connection from client.</param>
      <param name="playerControllerId">Id of the new player.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerConnect(UnityEngine.Networking.NetworkConnection)">
      <summary>Called on the server when a new client connects.</summary>
      <param name="conn">Connection from client.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerDisconnect(UnityEngine.Networking.NetworkConnection)">
      <summary>Called on the server when a client disconnects.</summary>
      <param name="conn">Connection from client.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerError(UnityEngine.Networking.NetworkConnection,System.Int32)">
      <summary>Called on the server when a network error occurs for a client connection.</summary>
      <param name="conn">Connection from client.</param>
      <param name="errorCode">Error code.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerReady(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Called on the server when a client is ready.</para>
        <para>The default implementation of this function calls NetworkServer.SetClientReady() to continue the network setup process.</para>
      </summary>
      <param name="conn">Connection from client.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerRemovePlayer(UnityEngine.Networking.NetworkConnection,UnityEngine.Networking.PlayerController)">
      <summary>
        <para>Called on the server when a client removes a player.</para>
        <para>The default implementation of this function destroys the corresponding player object.</para>
      </summary>
      <param name="conn">The connection to remove the player from.</param>
      <param name="player">The controller id of the player to remove.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnServerSceneChanged(System.String)">
      <summary>Called on the server when a scene is completed loaded, when the scene load was initiated by the server with ServerChangeScene().</summary>
      <param name="sceneName">The name of the new scene.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStartClient(UnityEngine.Networking.NetworkClient)">
      <summary>
        <para>This is a hook that is invoked when the client is started.</para>
        <para>StartClient has multiple signatures, but they all cause this hook to be called.</para>
      </summary>
      <param name="client">The NetworkClient object that was started.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStartHost">
      <summary>
        <para>This hook is invoked when a host is started.</para>
        <para>StartHost has multiple signatures, but they all cause this hook to be called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStartServer">
      <summary>
        <para>This hook is invoked when a server is started - including when a host is started.</para>
        <para>StartServer has multiple signatures, but they all cause this hook to be called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStopClient">
      <summary>This hook is called when a client is stopped.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStopHost">
      <summary>This hook is called when a host is stopped.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.OnStopServer">
      <summary>This hook is called when a server is stopped - including when a host is stopped.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.ServerChangeScene(System.String)">
      <summary>
        <para>This causes the server to switch scenes and sets the networkSceneName.</para>
        <para>Clients that connect to this server will automatically switch to this scene. This is called autmatically if onlineScene or offlineScene are set, but it can be called from user code to switch scenes again while the game is in progress. This automatically sets clients to be not-ready. The clients must call NetworkClient.Ready() again to participate in the new scene.</para>
      </summary>
      <param name="newSceneName">The name of the scene to change to. The server will change scene immediately, and a message will be sent to connected clients to ask them to change scene also.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.SetMatchHost(System.String,System.Int32,System.Boolean)">
      <summary>This set the address of the matchmaker service.</summary>
      <param name="newHost">Hostname of matchmaker service.</param>
      <param name="port">Port of matchmaker service.</param>
      <param name="https">Protocol used by matchmaker service.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StartClient">
      <summary>This starts a network client. It uses the networkAddress and networkPort properties as the address to connect to.</summary>
      <returns>The client object created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StartHost">
      <summary>
        <para>This starts a network "host" - a server and client in the same application.</para>
        <para>The client returned from StartHost() is a special "local" client that communicates to the in-process server using a message queue instead of the real network. But in almost all other cases, it can be treated as a normal client.</para>
      </summary>
      <returns>The client object created - this is a "local client".</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StartMatchMaker">
      <summary>
        <para>This starts matchmaker for the NetworkManager.</para>
        <para>This uses the matchHost and matchPort properties as the address of the matchmaker service to connect to.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StartServer">
      <summary>
        <para>This starts a new server.</para>
        <para>This uses the networkPort property as the listen port.</para>
      </summary>
      <returns>True is the server was started.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StopClient">
      <summary>Stops the client that the manager is using.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StopHost">
      <summary>This stops both the client and the server that the manager is using.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StopMatchMaker">
      <summary>Stops the matchmaker that the NetworkManager is using.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.StopServer">
      <summary>Stops the server that the manager is using.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.UseExternalClient(UnityEngine.Networking.NetworkClient)">
      <summary>
        <para>This allows the NetworkManager to use a client object created externally to the NetworkManager instead of using StartClient().</para>
        <para>The StartClient() function creates a client object, but this is not always what is desired. UseExternalClient allows a NetworkClient object to be created by other code and used with the NetworkManager.The client object will have the standard NetworkManager message handlers registered on it.</para>
      </summary>
      <param name="externalClient">The NetworkClient object to use.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.RegisterStartPosition(UnityEngine.Transform)">
      <summary>
        <para>Registers the transform of a game object as a player spawn location.</para>
        <para>This is done automatically by NetworkStartPosition components, but can be done manually from user script code.</para>
      </summary>
      <param name="start">Transform to register.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.Shutdown">
      <summary>
        <para>Shuts down the NetworkManager completely and destroy the singleton.</para>
        <para>This is required if a new NetworkManager instance needs to be created after the original one was destroyed. The example below has a reference to the GameObject with the NetworkManager on it and destroys the instance before calling Shutdown() and switching scenes.</para>
        <para>This cleanup allows a new scene with a new NetworkManager to be loaded.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkManager.UnRegisterStartPosition(UnityEngine.Transform)">
      <summary>
        <para>Unregisters the transform of a game object as a player spawn location.</para>
        <para>This is done automatically by the <see cref="T:UnityEngine.Networking.NetworkStartPosition" /> component, but can be done manually from user code.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManagerHUD.manager">
      <summary>The NetworkManager associated with this HUD.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManagerHUD.offsetX">
      <summary>The horizontal offset in pixels to draw the HUD runtime GUI at.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManagerHUD.offsetY">
      <summary>The vertical offset in pixels to draw the HUD runtime GUI at.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkManagerHUD.showGUI">
      <summary>Whether to show the default control HUD at runtime.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkMessage.channelId">
      <summary>The transport layer channel the message was sent on.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkMessage.conn">
      <summary>The connection the message was recieved on.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkMessage.msgType">
      <summary>The id of the message type of the message.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkMessage.reader">
      <summary>
        <para>A NetworkReader object that contains the contents of the message.</para>
        <para>For some built-in message types with no body, this can be null.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkMessage.ReadMessage">
      <summary>
        <para>ReadMessage is used to extract a typed network message from the NetworkReader of a NetworkMessage object.</para>
        <para>For example in a handler for the AddPlayer message:</para>
        <para>The AddPlayerMessage that is created will be populated by calling DeSerialize(). So when it is returned form ReadMessage it is ready to use.</para>
      </summary>
      <returns>The type of the Network Message, must be derived from MessageBase.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkMessage.Dump(System.Byte[],System.Int32)">
      <summary>Returns a string with the numeric representation of each byte in the payload.</summary>
      <param name="payload">Network message payload to dump.</param>
      <param name="sz">Length of payload in bytes.</param>
      <returns>Dumped info from payload.</returns>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.checkMethod">
      <summary>Which method to use for checking proximity of players.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.forceHidden">
      <summary>
        <para>Flag to force this object to be hidden for players.</para>
        <para>If this object is a player object, it will not be hidden for that player.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.visRange">
      <summary>The maximim range that objects will be visible at.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.visUpdateInterval">
      <summary>How often (in seconds) that this object should update the set of players that can see it.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkReader.Position">
      <summary>The current position within the buffer.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.#ctor">
      <summary>Creates a new NetworkReader object.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.#ctor(System.Byte[])">
      <summary>Creates a new NetworkReader object.</summary>
      <param name="buffer">A buffer to construct the reader with, this buffer is NOT copied.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadBoolean">
      <summary>Reads a boolean from the stream.</summary>
      <returns>The value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadByte">
      <summary>Reads a byte from the stream.</summary>
      <returns>The value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadBytes(System.Int32)">
      <summary>Reads a number of bytes from the stream.</summary>
      <param name="count">Number of bytes to read.</param>
      <returns>Bytes read. (this is a copy).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadBytesAndSize">
      <summary>
        <para>This read a 16-bit byte count and a array of bytes of that size from the stream.</para>
        <para>The format used by this function is the same as NetworkWriter.WriteBytesAndSize().</para>
      </summary>
      <returns>The bytes read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadChar">
      <summary>Reads a char from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadColor">
      <summary>Reads a unity Color objects.</summary>
      <returns>The color read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadColor32">
      <summary>Reads a unity color32 objects.</summary>
      <returns>The colo read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadDouble">
      <summary>Reads a double from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadGameObject">
      <summary>Reads a reference to a GameObject from the stream.</summary>
      <returns>The GameObject referenced.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadInt16">
      <summary>Reads a signed 16 bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadInt32">
      <summary>Reads a signed 32bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadInt64">
      <summary>Reads a signed 64 bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadMatrix4x4">
      <summary>Reads a unity Matrix4x4 object.</summary>
      <returns>The matrix read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadMessage">
      <summary>This is a utility function to read a typed network message from the stream.</summary>
      <returns>The type of the Network Message, must be derived from MessageBase.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadNetworkHash128">
      <summary>Reads a NetworkHash128 assetId.</summary>
      <returns>The assetId object read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadNetworkId">
      <summary>Reads a NetworkInstanceId from the stream.</summary>
      <returns>The NetworkInstanceId read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadNetworkIdentity">
      <summary>Reads a reference to a NetworkIdentity from the stream.</summary>
      <returns>The NetworkIdentity object read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadPackedUInt32">
      <summary>Reads a 32-bit variable-length-encoded value.</summary>
      <returns>The 32 bit value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadPackedUInt64">
      <summary>Reads a 64-bit variable-length-encoded value.</summary>
      <returns>The 64 bit value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadPlane">
      <summary>Reads a unity Plane object.</summary>
      <returns>The plane read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadQuaternion">
      <summary>Reads a Unity Quaternion object.</summary>
      <returns>The quaternion read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadRay">
      <summary>Reads a Unity Ray object.</summary>
      <returns>The ray read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadRect">
      <summary>Reads a Unity Rect object.</summary>
      <returns>The rect read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadSByte">
      <summary>Reads a signed byte from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadSceneId">
      <summary>Reads a NetworkSceneId from the stream.</summary>
      <returns>The NetworkSceneId read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadSingle">
      <summary>Reads a float from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadString">
      <summary>Reads a string from the stream. (max of 32k bytes).</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadTransform">
      <summary>
        <para>Reads a reference to a Transform from the stream.</para>
        <para>The game object of this Transform must have a NetworkIdentity.</para>
      </summary>
      <returns>The transform object read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadUInt16">
      <summary>Reads an unsigned 16 bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadUInt32">
      <summary>Reads an unsigned 32 bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadUInt64">
      <summary>Reads an unsigned 64 bit integer from the stream.</summary>
      <returns>Value read.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadVector2">
      <summary>Reads a Unity Vector2 object.</summary>
      <returns>The vector read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadVector3">
      <summary>Reads a Unity Vector3 objects.</summary>
      <returns>The vector read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ReadVector4">
      <summary>Reads a Unity Vector4 object.</summary>
      <returns>The vector read from the stream.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.SeekZero">
      <summary>Sets the current position of the reader's stream to the start of the stream.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkReader.ToString">
      <summary>Returns a string representation of the reader's buffer.</summary>
      <returns>Buffer contents.</returns>
    </member>
    <member name="P:UnityEngine.Networking.NetworkSceneId.Value">
      <summary>The internal value for this object.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkSceneId.IsEmpty">
      <summary>Returns true if the value is zero. Non-scene objects - ones which are spawned at runtime will have a sceneId of zero.</summary>
      <returns>True if zero.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkSceneId.ToString">
      <summary>Returns a string like SceneId:value.</summary>
      <returns>String representation of this object.</returns>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.active">
      <summary>
        <para>Checks if the server has been started.</para>
        <para>This will be true after NetworkServer.Listen() has been called.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.connections">
      <summary>
        <para>A list of all the current connections from clients.</para>
        <para>The connections in the list are at the index of their connectionId. There may be nulls in this list for disconnceted clients.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.handlers">
      <summary>
        <para>Dictionary of the message handlers registered with the server.</para>
        <para>The key to the dictionary is the message Id.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.hostTopology">
      <summary>
        <para>The host topology that the server is using.</para>
        <para>This is read-only once the server is started.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.localClientActive">
      <summary>
        <para>True is a local client is currently active on the server.</para>
        <para>This will be true for "Hosts" on hosted server games.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.localConnections">
      <summary>A list of local connections on the server.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.maxDelay">
      <summary>
        <para>The maximum delay before sending packets on connections.</para>
        <para>In seconds. The default of 0.01 seconds means packets will be delayed at most by 10 milliseconds. Setting this to zero will disable HLAPI connection buffering.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.networkConnectionClass">
      <summary>
        <para>The class to be used when creating new network connections.</para>
        <para>This can be set with SetNetworkConnectionClass.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.numChannels">
      <summary>The number of channels the network is configure with.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.objects">
      <summary>
        <para>This is a dictionary of networked objects that have been spawned on the server.</para>
        <para>The key to the dictionary is NetworkIdentity netId.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkServer.sendPeerInfo">
      <summary>Setting this true will make the server send peer info to all participants of the network.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendNetworkInfo(UnityEngine.Networking.NetworkConnection)">
      <summary>This sends information about all participants in the current network game to the connection.</summary>
      <param name="targetConnection">Connection to send peer info to.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.AddExternalConnection(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>This accepts a network connection from another external source and adds it to the server.</para>
        <para>This connection will use the callbacks registered with the server, and can have players added to it like any other connection.</para>
      </summary>
      <param name="conn">Network connection to add.</param>
      <returns>True if added.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.AddPlayerForConnection(UnityEngine.Networking.NetworkConnection,UnityEngine.GameObject,System.Int16)">
      <summary>
        <para>When an AddPlayer message handler has received a request from a player, the server calls this to assoicate the player object with the connection.</para>
        <para>When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for "adding" a player, not for "replacing" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail.</para>
      </summary>
      <param name="conn">Connection which is adding the player.</param>
      <param name="player">Player object spawned for the player.</param>
      <param name="playerControllerId">The player controller ID number as specified by client.</param>
      <returns>True if player was added.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ClearHandlers">
      <summary>Clear all registered callback handlers.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ClearLocalObjects">
      <summary>This clears all of the networked objects that the server is aware of. This can be required if a scene change deleted all of the objects without destroying them in the normal manner.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ClearSpawners">
      <summary>Clears all registered spawn prefab and spawn handler functions for this server.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Configure(UnityEngine.Networking.ConnectionConfig,System.Int32)">
      <summary>This configures the tranport layer settings for the server.</summary>
      <param name="config">Transport layer confuration object.</param>
      <param name="maxConnections">The maximum number of client connections to allow.</param>
      <returns>True if successfully configured.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Configure(UnityEngine.Networking.HostTopology)">
      <summary>This configures the tranport layer settings for the server.</summary>
      <param name="topology">Transport layer topology object to use.</param>
      <returns>True if successfully configured.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Destroy(UnityEngine.GameObject)">
      <summary>Destroys this object and corresponding objects on all clients.</summary>
      <param name="obj">Game object to destroy.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.DestroyPlayersForConnection(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>This destroys all the player objects associated with a NetworkConnections on a server.</para>
        <para>This is used when a client disconnects, to remove the players for that client.</para>
      </summary>
      <param name="conn">The connections object to clean up for.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.DisconnectAll">
      <summary>
        <para>Disconnect all currently connected clients.</para>
        <para>This can only be called on the server. Clients will receive the SYSTEM_DISCONNECT message.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.FindLocalObject(System.UInt32)">
      <summary>
        <para>This finds the NetworkIdentity game object that matches a netId.</para>
        <para>Since netIds are the same on the server and all clients for a game, this allows clients to send a netId of a local game objects, and have the server find the corresponding server object.</para>
      </summary>
      <returns>The game object that matches the netId.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.GetConnectionStats">
      <summary>Gets aggregate packet stats for all connections.</summary>
      <returns>Dictionary of msg types and packet statistics.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.GetStatsIn(System.Int32@,System.Int32@)">
      <summary>Get inbound network statistics for the server.</summary>
      <param name="numMsgs">Number of messages received so far.</param>
      <param name="numBytes">Number of bytes received so far.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.GetStatsOut(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>Get outbound network statistics for the client.</summary>
      <param name="numMsgs">Number of messages sent so far (including collated messages send through buffer).</param>
      <param name="numBufferedMsgs">Number of messages sent through buffer.</param>
      <param name="numBytes">Number of bytes sent so far.</param>
      <param name="lastBufferedPerSecond">Number of messages buffered for sending per second.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Listen(System.String,System.Int32)">
      <summary>Start the server on the given port number. Note that if a match has been created, this will listen using the relay server instead of a local socket.</summary>
      <param name="ipAddress">The IP address to bind to (optional).</param>
      <param name="serverPort">Listen port number.</param>
      <returns>True if listen succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Listen(System.Int32)">
      <summary>Start the server on the given port number. Note that if a match has been created, this will listen using the relay server instead of a local socket.</summary>
      <param name="serverPort">Listen port number.</param>
      <returns>True if listen succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ListenRelay(System.String,System.Int32,UnityEngine.Networking.Types.NetworkID,UnityEngine.Networking.Types.SourceID,UnityEngine.Networking.Types.NodeID)">
      <summary>Starts a server using a relay server. This is the manual way of using the relay server, as the regular NetworkServer.Connect() will automatically use the relay server if a match exists.</summary>
      <param name="relayIp">Relay server IP Address.</param>
      <param name="relayPort">Relay server port.</param>
      <param name="netGuid">GUID of the network to create.</param>
      <param name="sourceId">This server's sourceId.</param>
      <param name="nodeId">The node to join the network with.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.RegisterHandler(System.Int16,UnityEngine.Networking.NetworkMessageDelegate)">
      <summary>
        <para>Register a handler for a particular message type.</para>
        <para>There are several system message types which you can add handlers for. You can also add your own message types.</para>
        <para>The system message types are listed below:</para>
        <para>Most of these messages are for internal use only. Users should not define message ids in this range.</para>
      </summary>
      <param name="msgType">Message type number.</param>
      <param name="handler">Function handler which will be invoked for when this message type is received.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.RemoveExternalConnection(System.Int32)">
      <summary>This removes an external connection added with AddExternalConnection().</summary>
      <param name="connectionId">The id of the connection to remove.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ReplacePlayerForConnection(UnityEngine.Networking.NetworkConnection,UnityEngine.GameObject,System.Int16)">
      <summary>
        <para>This replaces the player object for a connection with a different player object. The old player object is not destroyed.</para>
        <para>If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changin scenes.</para>
      </summary>
      <param name="conn">Connection which is adding the player.</param>
      <param name="player">Player object spawned for the player.</param>
      <param name="playerControllerId">The player controller ID number as specified by client.</param>
      <returns>True if player was replaced.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Reset">
      <summary>Reset the NetworkServer singleton.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.ResetConnectionStats">
      <summary>Resets the packet stats on all connections.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendByChannelToAll(System.Int16,UnityEngine.Networking.MessageBase,System.Int32)">
      <summary>Sends a network message to all connected clients on a specified transport layer QoS channel.</summary>
      <param name="msgType">The message id.</param>
      <param name="msg">The message to send.</param>
      <param name="channelId">The transport layer channel to use.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendByChannelToReady(UnityEngine.GameObject,System.Int16,UnityEngine.Networking.MessageBase,System.Int32)">
      <summary>Sends a network message to all connected clients that are "ready" on a specified transport layer QoS channel.</summary>
      <param name="contextObj">An object to use for context when calculating object visibility. If null, then the message is sent to all ready clients.</param>
      <param name="msgType">The message id.</param>
      <param name="msg">The message to send.</param>
      <param name="channelId">The transport layer channel to send on.</param>
      <returns>True if the message was sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendBytesToPlayer(UnityEngine.GameObject,System.Byte[],System.Int32,System.Int32)">
      <summary>
        <para>This sends an array of bytes to a specific player.</para>
        <para>This bypasses the usual serialization and message structures, allowing raw bytes to be send to a player. The contents will be processed as a message on the client of the player, so it must be structured properly.</para>
      </summary>
      <param name="player">The player to send he bytes to.</param>
      <param name="buffer">Array of bytes to send.</param>
      <param name="numBytes">Size of array.</param>
      <param name="channelId">Transport layer channel id to send bytes on.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendBytesToReady(System.Byte[],System.Int32,System.Int32)">
      <summary>
        <para>This sends an array of bytes to all ready players.</para>
        <para>This bypasses the usual serialization and message structures, allowing raw bytes to be send to all ready players. The contents will be processed as a message on the client of the player, so it must be structured properly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendToAll``1(System.Int16,``0)">
      <summary>Send a message structure with the given type number to all connected clients.</summary>
      <returns>Success if message is sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendToClient``1(System.Int32,System.Int16,``0)">
      <summary>Send a message to the client which owns the given connection ID.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendToClientOfPlayer``1(UnityEngine.GameObject,System.Int16,``0)">
      <summary>Send a message to the client which owns the given player object instance.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendToReady``1(System.Int16,``0)">
      <summary>
        <para>Send a message structure with the given type number to only clients which are ready.</para>
        <para>See Networking.NetworkClient.Ready.</para>
      </summary>
      <returns>Success if message is sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendUnreliableToAll``1(System.Int16,``0)">
      <summary>Send given message structure as an unreliable message to all connected clients.</summary>
      <returns>Success if message is sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendUnreliableToReady``1(System.Int16,``0)">
      <summary>
        <para>Send given message structure as an unreliable message only to ready clients.</para>
        <para>See Networking.NetworkClient.Ready.</para>
      </summary>
      <returns>Success if message is sent.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SendWriterToReady(UnityEngine.Networking.NetworkWriter,System.Int32)">
      <summary>Sends the contents of a NetworkWriter object to the ready players.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SetAllClientsNotReady">
      <summary>
        <para>Marks all connected clients as no longer ready.</para>
        <para>All clients will no longer be sent state synchronization updates. The player's clients can call ClientManager.Ready() again to re-enter the ready state. This is useful when switching scenes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SetClientNotReady(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Sets the client of the connection to be not-ready.</para>
        <para>Clients that are not ready do not receive spawned objects or state synchronization updates. They client can be made ready again by calling SetClientReady().</para>
      </summary>
      <param name="conn">The connection of the client to make not ready.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SetClientReady(UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>Sets the client to be ready.</para>
        <para>When a client has signaled that it is ready, this method tells the server that the client is ready to receive spawned objects and state synchronization updates. This is usually called in a handler for the SYSTEM_READY message. If there is not specific action a game needs to take for this message, relying on the default ready handler function is probably fine, so this call wont be needed.</para>
      </summary>
      <param name="conn">The connection of the client to make ready.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SetNetworkConnectionClass">
      <summary>
        <para>This sets the class used when creating new network connections.</para>
        <para>The class must be derived from NetworkConnection.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Shutdown">
      <summary>This shuts down the server and disconnects all clients.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.Spawn(UnityEngine.GameObject)">
      <summary>
        <para>Spawn the given game object on all clients which are ready.</para>
        <para>This will cause a new object to be instantiated from the registered prefab, or from a custom spawn function.</para>
      </summary>
      <param name="obj">Game object with NetworkIdentity to spawn.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SpawnObjects">
      <summary>
        <para>This causes NetworkIdentity objects in a scene to be spawned on a server.</para>
        <para>NetworkIdentity objects in a scene are disabled by default. Calling SpawnObjects() causes these scene objects to be enabled and spawned. It is like calling NetworkServer.Spawn() for each of them.</para>
      </summary>
      <returns>Success if objects where spawned.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SpawnWithClientAuthority(UnityEngine.GameObject,UnityEngine.GameObject)">
      <summary>
        <para>This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client.</para>
        <para>This is the same as calling AssignClientAuthority on the spawned object.</para>
      </summary>
      <param name="obj">The object to spawn.</param>
      <param name="player">The player object to set Client Authority to.</param>
      <returns>True if the object was spawned.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SpawnWithClientAuthority(UnityEngine.GameObject,UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client.</para>
        <para>This is the same as calling AssignClientAuthority on the spawned object.</para>
      </summary>
      <param name="obj">The object to spawn.</param>
      <param name="conn">The connection to set Client Authority to.</param>
      <returns>True if the object was spawned.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.SpawnWithClientAuthority(UnityEngine.GameObject,UnityEngine.Networking.NetworkHash128,UnityEngine.Networking.NetworkConnection)">
      <summary>
        <para>This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client.</para>
        <para>This is the same as calling AssignClientAuthority on the spawned object.</para>
      </summary>
      <param name="obj">The object to spawn.</param>
      <param name="assetId">The assetId of the object to spawn. Used for custom spawn handlers.</param>
      <param name="conn">The connection to set Client Authority to.</param>
      <returns>True if the object was spawned.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.UnregisterHandler(System.Int16)">
      <summary>Unregisters a handler for a particular message type.</summary>
      <param name="msgType">The message type to remove the handler for.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkServer.UnSpawn(UnityEngine.GameObject)">
      <summary>
        <para>This takes an object that has been spawned and un-spawns it.</para>
        <para>The object will be removed from clients that it was spawned on, or the custom spawn handler function on the client will be called for the object.Unlike when calling NetworkServer.Destroy(), on the server the object will NOT be destroyed. This allows the server to re-use the object, even spawn it again later.</para>
      </summary>
      <param name="obj">The spawned object to be unspawned.</param>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.characterContoller">
      <summary>Cached CharacterController.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.clientMoveCallback2D">
      <summary>
        <para>A callback that can be used to validate on the server, the movement of client authoritative objects.</para>
        <para>This version of the callback works with objects that use 2D physics. The callback function may return false to reject the movement request completely. It may also modify the movement parameters - which are passed by reference.The example below set the callback in OnStartServer, and will disconnect a client that moves an object into an invalid position after a number of failures.</para>
        <para>This kind of server-side movement validation should be used in conjunction with client side movement validation. The callback should only detect a failure if a client is by-passing client side movement checks - by cheating.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.clientMoveCallback3D">
      <summary>
        <para>A callback that can be used to validate on the server, the movement of client authoritative objects.</para>
        <para>This version of the callback works with objects that use 3D physics. The callback function may return false to reject the movement request completely. It may also modify the movement parameters - which are passed by reference.The example below set the callback in OnStartServer, and will disconnect a client that moves an object into an invalid position after a number of failures.</para>
        <para>This kind of server-side movement validation should be used in conjunction with client side movement validation. The callback should only detect a failure if a client is by-passing client side movement checks - by cheating.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.grounded">
      <summary>
        <para>Tells the NetworkTransform that it is on a surface (this is the default).</para>
        <para>Object that are NOT grounded will not interpolate their vertical velocity. This avoid the problem of interpolation fighting with gravity on non-authoritative objects. This only works for RigidBody2D physics objects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.interpolateMovement">
      <summary>
        <para>Enables interpolation of the synchronized movement.</para>
        <para>The larger this number is, the faster the object will interpolate to the target position.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.interpolateRotation">
      <summary>
        <para>Enables interpolation of the synchronized rotation.</para>
        <para>If this is not set, object will snap to the new rotation. The larger this number is, the faster the object will interpolate to the target facing direction.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.lastSyncTime">
      <summary>The most recent time when a movement synchronization packet arrived for this object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.movementTheshold">
      <summary>The distance that an object can move without sending a movement synchronization update.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.rigidbody2D">
      <summary>Cached Rigidbody2D.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.rigidbody3D">
      <summary>Cached Rigidbody.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.rotationSyncCompression">
      <summary>How much to compress rotation sync updates.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.sendInterval">
      <summary>
        <para>The sendInterval controls how often state updates are sent for this object.</para>
        <para>Unlike most NetworkBehaviour scripts, for NetworkTransform this is implemented at a per-object level rather than at the per-script level. This allows more flexibility as this component is used in various situation.If sendInterval is non-zero, then transform state updates are send at most once every sendInterval seconds. However, if an object is stationary, no updates are sent.If sendInterval is zero, then no automatic updates are sent. In this case, calling SetDirtyBits() on the NetworkTransform will cause an updates to be sent. This could be used for objects like bullets that have a predictable trajectory.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.snapThreshold">
      <summary>If a movement update puts an object further from its current position that this value, it will snap to the position instead of moving smoothly.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.syncRotationAxis">
      <summary>Which axis should rotation by synchronized for.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.targetSyncPosition">
      <summary>The target position interpolating towards.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.targetSyncRotation2D">
      <summary>The target rotation interpolating towards.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.targetSyncRotation3D">
      <summary>The target position interpolating towards.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.targetSyncVelocity">
      <summary>The velocity send for synchronization.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransform.transformSyncMode">
      <summary>What method to use to sync the object's position.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.childIndex">
      <summary>A unique Identifier for this NetworkTransformChild component on this root object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.clientMoveCallback3D">
      <summary>A callback function to allow server side validation of the movement of the child object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.interpolateMovement">
      <summary>
        <para>The rate to interpolate towards the target position.</para>
        <para>A value of 1 will snap to the position, and lower positive values will interpolate more slowly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.interpolateRotation">
      <summary>
        <para>The rate to interpolate to the target rotation.</para>
        <para>A value of 1 will snap to the position, and lower positive values will interpolate more slowly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.lastSyncTime">
      <summary>The most recent time when a movement synchronization packet arrived for this object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.rotationSyncCompression">
      <summary>How much to compress rotation sync updates.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.sendInterval">
      <summary>The sendInterval controls how often state updates are sent for this object.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.syncRotationAxis">
      <summary>Which axis should rotation by synchronized for.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.target">
      <summary>The child transform to be synchronized.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.targetSyncPosition">
      <summary>The target position interpolating towards.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformChild.targetSyncRotation3D">
      <summary>The target rotation interpolating towards.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkTransformVisualizer.visualizerPrefab">
      <summary>The prefab to use for the visualization object.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHost(UnityEngine.Networking.HostTopology,System.Int32,System.String)">
      <summary>
        <para>Will create a host (open socket) with given topology and optionally port and IP.</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <param name="port">Bind to specific port, if 0 is selected the port will chosen by OS.</param>
      <param name="ip">Bind to specific IP address.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHost(UnityEngine.Networking.HostTopology,System.Int32)">
      <summary>
        <para>Will create a host (open socket) with given topology and optionally port and IP.</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <param name="port">Bind to specific port, if 0 is selected the port will chosen by OS.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHost(UnityEngine.Networking.HostTopology)">
      <summary>
        <para>Will create a host (open socket) with given topology and optionally port and IP.</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHostWithSimulator(UnityEngine.Networking.HostTopology,System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
        <para>Create a host (open socket) and configure them to simulate internet latency (works on editor and development build only).</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available. The simulated latency will vary according to exponential distribution.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <param name="minTimeout">Minimum simulated delay.</param>
      <param name="maxTimeout">Maximum simulated delay.</param>
      <param name="port">Bind to specific port, if 0 is selected the port will chosen by OS.</param>
      <param name="ip">Bind to specific IP address.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHostWithSimulator(UnityEngine.Networking.HostTopology,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Create a host (open socket) and configure them to simulate internet latency (works on editor and development build only).</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available. The simulated latency will vary according to exponential distribution.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <param name="minTimeout">Minimum simulated delay.</param>
      <param name="maxTimeout">Maximum simulated delay.</param>
      <param name="port">Bind to specific port, if 0 is selected the port will chosen by OS.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddHostWithSimulator(UnityEngine.Networking.HostTopology,System.Int32,System.Int32)">
      <summary>
        <para>Create a host (open socket) and configure them to simulate internet latency (works on editor and development build only).</para>
        <para>An optional specific host IP address can be provided. This is usually only useful on servers where multiple internet accessible IP addresses might be available. The simulated latency will vary according to exponential distribution.</para>
      </summary>
      <param name="topology">The host topology for this host.</param>
      <param name="minTimeout">Minimum simulated delay.</param>
      <param name="maxTimeout">Maximum simulated delay.</param>
      <returns>Returns host ID just created.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.AddWebsocketHost(UnityEngine.Networking.HostTopology,System.Int32)">
      <summary>Created web socket host. This function is supported only for Editor (Win, Linux, Mac) and StandalonePlayers (Win, Linux, Mac) Topology is used to define how many client can connect, and how many messages should be preallocated in send and receive pool, all other parameters are ignored.</summary>
      <param name="topology">Topology.</param>
      <param name="port">Listening tcp port.</param>
      <returns>Web socket host id.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Connect(System.Int32,System.String,System.Int32,System.Int32,System.Byte@)">
      <summary>
        <para>Try to establish connection to other peer.</para>
        <para>Receive() with event type kConnectEvent(kDisconnectEvent) will be signal that this connection established(cannot be established). Error parameter will return possible error. Function itself will return unique identifier (for the host) of connection.</para>
      </summary>
      <param name="hostId">Host (actually socket) id for this connection.</param>
      <param name="address">Ip4 address.</param>
      <param name="port">Port.</param>
      <param name="exeptionConnectionId">0 in the case of a default connection.</param>
      <param name="error">Possible error, kOK if it is good.</param>
      <returns>ConnectionId on success (otherwise zero).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ConnectAsNetworkHost(System.Int32,System.String,System.Int32,UnityEngine.Networking.Types.NetworkID,UnityEngine.Networking.Types.SourceID,UnityEngine.Networking.Types.NodeID,System.Byte@)">
      <summary>
        <para>Create dedicated connection to relay server.</para>
        <para>Client calls this function to set itself as an owner of the network group on the relay server. This client should call <see cref="M:UnityEngine.Networking.NetworkTransport.ReceiveRelayEventFromHost(System.Int32,System.Byte@)" /> periodically to be notified about connection/disconnection events to/from Relay server.</para>
      </summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="address">Ip4.</param>
      <param name="port">Port.</param>
      <param name="network">Guid of relay network.</param>
      <param name="source">Guid of user.</param>
      <param name="node">Slot id for this user.</param>
      <param name="error">Possible error (<see cref="T:UnityEngine.Networking.NetworkError" />.Ok if success).</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ConnectEndPoint(System.Int32,System.Net.EndPoint,System.Int32,System.Byte@)">
      <summary>
        <para>Try to establish connection to other peer, where the peer is specified using a C# System.EndPoint.</para>
        <para>This is primarily useful on platforms (such as Xbox One) that require passing in special structures representing the remote host (as compared to the usual IP/port combination).This is also useful for libraries relying on using an IPEndPoint object.</para>
      </summary>
      <param name="hostId">Host (actually socket) id for this connection.</param>
      <param name="xboxOneEndPoint">A valid System.EndPoint.</param>
      <param name="exceptionConnectionId">0 in the case of a default connection.</param>
      <param name="error">Return kOk on success, otherwise a one-byte error code.</param>
      <returns>ConnectionId on success (otherwise zero).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ConnectToNetworkPeer(System.Int32,System.String,System.Int32,System.Int32,System.Int32,UnityEngine.Networking.Types.NetworkID,UnityEngine.Networking.Types.SourceID,UnityEngine.Networking.Types.NodeID,System.Int32,System.Single,System.Byte@)">
      <summary>
        <para>Create connection to other peer in the relay group.</para>
        <para>Similar to <see cref="M:UnityEngine.Networking.NetworkTransport.Connect(System.Int32,System.String,System.Int32,System.Int32,System.Byte@)" /> but via relay server.</para>
      </summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="address">IP.</param>
      <param name="port">Port.</param>
      <param name="exceptionConnectionId">Id of exception, default in case 0.</param>
      <param name="relaySlotId">Id of remote peer in relay.</param>
      <param name="network">Guid of relay network.</param>
      <param name="source">Guid of user who want to establish connect (serve as tmp password).</param>
      <param name="node">Slot id reserved for user.</param>
      <param name="bytesPerSec">Average bandwidth (bandwidth will be throttled on this level).</param>
      <param name="bucketSizeFactor">Allowed peak bandwidth (peak bandwidth = factor*bytesPerSec, recommended value is 2.0) If data has not been sent for a long time, it is allowed to send more data, with factor 2 it is allowed send 2*bytesPerSec bytes per sec.</param>
      <param name="error">Possible error.</param>
      <returns>ConnectionId on success (otherwise zero).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ConnectToNetworkPeer(System.Int32,System.String,System.Int32,System.Int32,System.Int32,UnityEngine.Networking.Types.NetworkID,UnityEngine.Networking.Types.SourceID,UnityEngine.Networking.Types.NodeID,System.Byte@)">
      <summary>
        <para>Create connection to other peer in the relay group.</para>
        <para>Similar to <see cref="M:UnityEngine.Networking.NetworkTransport.Connect(System.Int32,System.String,System.Int32,System.Int32,System.Byte@)" /> but via relay server.</para>
      </summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="address">IP.</param>
      <param name="port">Port.</param>
      <param name="exceptionConnectionId">Id of exception, default in case 0.</param>
      <param name="relaySlotId">Id of remote peer in relay.</param>
      <param name="network">Guid of relay network.</param>
      <param name="source">Guid of user who want to establish connect (serve as tmp password).</param>
      <param name="node">Slot id reserved for user.</param>
      <param name="error">Possible error.</param>
      <returns>ConnectionId on success (otherwise zero).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ConnectWithSimulator(System.Int32,System.String,System.Int32,System.Int32,System.Byte@,UnityEngine.Networking.ConnectionSimulatorConfig)">
      <summary>
        <para>Connect with simulated latency.</para>
        <para>Will establish connection between peers and configure it to simulate internet latency (works on editor and development build only).</para>
      </summary>
      <param name="hostId">Host id.</param>
      <param name="address">Peer ip.</param>
      <param name="port">Peer port.</param>
      <param name="exeptionConnectionId">Special connection id or 0 for default.</param>
      <param name="error">Returned error.</param>
      <param name="conf">Simulation configuration definec latency for this connection.</param>
      <returns>ConnectionId on success (otherwise zero).</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Disconnect(System.Int32,System.Int32,System.Byte@)">
      <summary>Send disconnect signal to peer and close connection. user should call Receive() to be notified that connection is closed. This signal will send only once (best effort delivery) iif this packet will dropped by some reason, peer will close connection by timeout.</summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="connectionId">Id of closing connection.</param>
      <param name="error">kOK if it was successful.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.DisconnectNetworkHost(System.Int32,System.Byte@)">
      <summary>Aplyed only for client which has been already owner of the same group of relay server. it will disconnect this owner from the group, group will be distracted or (if it supported) one of the member of this group should became new owner (owner migration).</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="error">kOk in case success.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.FinishSendMulticast(System.Int32,System.Byte@)">
      <summary>Function will finalize sending message to group of connection. (only one multicast message per time is allowed for host).</summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="error">Possible error (kOK in case success).</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetAssetId(UnityEngine.GameObject)">
      <summary>The UNet spawning system uses assetIds to identify how spawn remote objects. This function allows you to get the assetId for the prefab associated with an object.</summary>
      <param name="go">Target game object to get asset Id for.</param>
      <returns>The assetId of the game object's prefab.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetBroadcastConnectionInfo(System.Int32,System.String@,System.Int32@,System.Byte@)">
      <summary>If Receive() function returns BroadcastEvent, immedeately this function will return connection info of broadcast sender. This info can be used for connection to broadcast sender.</summary>
      <param name="hostId">Id of broadcast receiver (returns with Receve() function).</param>
      <param name="address">Ip address of broadcast sender.</param>
      <param name="port">Port of broadcast sender.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetBroadcastConnectionMessage(System.Int32,System.Byte[],System.Int32,System.Int32@,System.Byte@)">
      <summary>If Receive() function returns BroadcastEvent, immedeately this function will return complimentary message of broadcast sender.</summary>
      <param name="hostId">Id of broadcast receiver (returns with Receve() function).</param>
      <param name="buffer">Message buffer provided by caller.</param>
      <param name="bufferSize">Buffer size.</param>
      <param name="receivedSize">Received size (if received size &gt; bufferSize, corresponding error will be set).</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetConnectionInfo(System.Int32,System.Int32,System.String@,System.Int32@,UnityEngine.Networking.Types.NetworkID@,UnityEngine.Networking.Types.NodeID@,System.Byte@)">
      <summary>Return connection parameters of connected connection, this parameters can be sent to other user which can establish direct connection to this peer. If peer connected via relay, relay related parameters will be not invalid.</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="address">Ip4.</param>
      <param name="port">Port.</param>
      <param name="network">Relay network guid.</param>
      <param name="dstNode">Destination slot id.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetCurrentIncomingMessageAmount">
      <summary>Return value of messages waiting for reading.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetCurrentOutgoingMessageAmount">
      <summary>Return total message amount waiting for sending.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetCurrentRtt(System.Int32,System.Int32,System.Byte@)">
      <summary>Return round trip time for connection.</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetNetIOTimeuS">
      <summary>Function returns time spent on network io operations in micro seconds.</summary>
      <returns>Time in micro seconds.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetNetworkLostPacketNum(System.Int32,System.Int32,System.Byte@)">
      <summary>Return total number of packets has been lost from start.</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetNetworkTimestamp">
      <summary>Get UNET timestamp which can be added to message for further definitions of packet delaying.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetPacketReceivedRate(System.Int32,System.Int32,System.Byte@)">
      <summary>Return current receive rate in bytes per sec.</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetPacketSentRate(System.Int32,System.Int32,System.Byte@)">
      <summary>Reurn outgoing rate in bytes per second.</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Connection id.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.GetRemoteDelayTimeMS(System.Int32,System.Int32,System.Int32,System.Byte@)">
      <summary>Return time delay for timestamp received from message (previously created by GetNetworkTimestamp()).</summary>
      <param name="hostId">Id of udp socket used to.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="remoteTime">Timestamp delivered from peer.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Init">
      <summary>First function which should be called before any other NetworkTransport function.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.IsBroadcastDiscoveryRunning">
      <summary>Check if broadcastdiscovery sender works.</summary>
      <returns>True if it works.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Receive(System.Int32@,System.Int32@,System.Int32@,System.Byte[],System.Int32,System.Int32@,System.Byte@)">
      <summary>Delivered different network events to user. kConnectionEvent will notify about new connection established, kDisconnectEvent will report about disconnection happened, kDataEvent will report about new information delivered. Use must represent buffer for delivered data.</summary>
      <param name="hostId">Id of udp socket where event happened.</param>
      <param name="connectionId">Connection id for event.</param>
      <param name="channelId">Channel id for data event.</param>
      <param name="buffer">Prepared incoming buffer.</param>
      <param name="bufferSize">Prepared buffer size.</param>
      <param name="receivedSize">Actually received length.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ReceiveFromHost(System.Int32,System.Int32@,System.Int32@,System.Byte[],System.Int32,System.Int32@,System.Byte@)">
      <summary>Similar to Receive() but will ask only provided host. It for example allows to mix server/client in the same game.</summary>
      <param name="hostId">Id of udp socket used to check for event.</param>
      <param name="connectionId">Connection id for event.</param>
      <param name="channelId">Channel id for data event.</param>
      <param name="buffer">Prepared incoming buffer.</param>
      <param name="bufferSize">Prepared buffer size.</param>
      <param name="receivedSize">Actually received length.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.ReceiveRelayEventFromHost(System.Int32,System.Byte@)">
      <summary>Function delivered relay group event for group owner.</summary>
      <param name="hostId">Id of udp socket used to check for event.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.RemoveHost(System.Int32)">
      <summary>Close opened socket, close all connection belonging this socket.</summary>
      <param name="hostId">If of opened udp socket.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Send(System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Byte@)">
      <summary>Send data to peer.</summary>
      <param name="hostId">Id of udp socket using for send.</param>
      <param name="connectionId">Id of connection.</param>
      <param name="channelId">If for channel.</param>
      <param name="buffer">Binary buffer containing data for sending.</param>
      <param name="size">Buffer size.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.SendMulticast(System.Int32,System.Int32,System.Byte@)">
      <summary>Function adds another connection to multy peer sends.</summary>
      <param name="hostId">Id of udp socket used for sending.</param>
      <param name="connectionId">Connection id.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.SetBroadcastCredentials(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte@)">
      <summary>Set credentials for received broadcast message. If one of credentials is wrong, received brodcast discovery message will drop.</summary>
      <param name="hostId">Id of the host whihc will receive broadcast discovery message.</param>
      <param name="key">Credential.</param>
      <param name="version">Credential.</param>
      <param name="subversion">Credential.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.SetPacketStat(System.Int32,System.Int32,System.Int32)">
      <summary>Used to inform the profiler of network packet statistics.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.Shutdown">
      <summary>Shutdown the transport layer, after calling this function no any other function can be called.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.StartBroadcastDiscovery(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Byte@)">
      <summary>Function starts send broadcasting message in all local subnets.</summary>
      <param name="hostId">Host id which should be reported via broadcast (broadcast receivers will connect to this host).</param>
      <param name="broadcastPort">Port using for broadcast message (usuall port of broadcast receivers).</param>
      <param name="key">Part of credentials, if key of receiver will not be equal to key of sender broadcast message will drop.</param>
      <param name="version">Part of credentials.</param>
      <param name="subversion">Part of credentials.</param>
      <param name="buffer">Complimentary message. This message will delivered to receiver with Broadcast event.</param>
      <param name="size">Size of message.</param>
      <param name="timeout">How often broadcast message shoule be sent (ms).</param>
      <param name="error">Error.</param>
      <returns>Return true if broadcasting request has been submitted.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.StartSendMulticast(System.Int32,System.Int32,System.Byte[],System.Int32,System.Byte@)">
      <summary>Start process sending message per group of connected connection.</summary>
      <param name="hostId">Id of udp socket used to establish connection.</param>
      <param name="channelId">First connection id from group connection.</param>
      <param name="buffer">Data buffer.</param>
      <param name="size">Data buffer length.</param>
      <param name="error">Possible error.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkTransport.StopBroadcastDiscovery">
      <summary>Stop sending broadcast discovery message.</summary>
    </member>
    <member name="P:UnityEngine.Networking.NetworkWriter.Position">
      <summary>The current position of the internal buffer.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.#ctor">
      <summary>Creates a new NetworkWriter object.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.#ctor(System.Byte[])">
      <summary>Creates a new NetworkWriter object.</summary>
      <param name="buffer">A buffer to write into. This is not copied.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.AsArray">
      <summary>Returns the internal array of bytes the writer is using. This is NOT a copy.</summary>
      <returns>Internal buffer.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.FinishMessage">
      <summary>This fills out the size header of a message begun with StartMessage(), so that it can be send using Send() functions.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.SeekZero">
      <summary>Seeks to the start of the internal buffer.</summary>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.StartMessage(System.Int16)">
      <summary>This begins a new message, which should be completed with FinishMessage() once the payload has been written.</summary>
      <param name="msgType">Message type.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.ToArray">
      <summary>Returns a copy of internal array of bytes the writer is using, it copies only the bytes used.</summary>
      <returns>Copy of data used by the writer.</returns>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.Write(UnityEngine.GameObject)">
      <summary>This writes the a reference to a GameObject with a NetworkIdentity component to the stream. The object should have been spawned for clients to know about it.</summary>
      <param name="value">The GameObject to write.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.WriteBytesAndSize(System.Byte[],System.Int32)">
      <summary>This writes a 16-bit count and a array of bytes of that length to the stream.</summary>
      <param name="buffer">Array of bytes to write.</param>
      <param name="count">Number of bytes from the array to write.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.WriteBytesFull(System.Byte[])">
      <summary>
        <para>This writes a 16-bit count and an array of bytes of that size to the stream.</para>
        <para>Note that this will be the full allocated size of the array. So if the array is partially filled with data to send - then you should be using WriteBytesAndSize instead.</para>
      </summary>
      <param name="buffer">Bytes to write.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.WritePackedUInt32(System.UInt32)">
      <summary>This writes the 32-bit value to the stream using variable-length-encoding.</summary>
      <param name="value">Value to write.</param>
    </member>
    <member name="M:UnityEngine.Networking.NetworkWriter.WritePackedUInt64(System.UInt64)">
      <summary>This writes the 64-bit value to the stream using variable-length-encoding.</summary>
      <param name="value">Value to write.</param>
    </member>
    <member name="F:UnityEngine.Networking.PlayerController.MaxPlayersPerClient">
      <summary>The maximum number of local players that a client connection can have.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerController.gameObject">
      <summary>The game object for this player.</summary>
    </member>
    <member name="P:UnityEngine.Networking.PlayerController.IsValid">
      <summary>Checks if this PlayerController has an actual player attached to it.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerController.playerControllerId">
      <summary>The local player ID number of this player.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerController.unetView">
      <summary>The NetworkIdentity component of the player.</summary>
    </member>
    <member name="M:UnityEngine.Networking.PlayerController.ToString">
      <summary>String representation of the player objects state.</summary>
      <returns>String with the object state.</returns>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.Add``1(``0)">
      <summary>Same as List:Add() but the item is added on clients.</summary>
      <param name="item">Item to add.</param>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.Clear">
      <summary>Same as List:Clear() but the list is cleared on clients.</summary>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.DeserializeItem``1(UnityEngine.Networking.NetworkReader)">
      <summary>This method is used when deserializing SyncList items from a stream.</summary>
      <param name="reader">Stream to read from.</param>
      <returns>New instance of the SyncList value type.</returns>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.Dirty(System.Int32)">
      <summary>Marks an item in the list as dirty, so it will be updated on clients.</summary>
      <param name="index">Index of item to dirty.</param>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.SyncList&lt;T0&gt;.HandleMsg``1(System.Byte,System.Int32,``0)">
      <summary>Internal function used for remote list operations.</summary>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.InitializeBehaviour(UnityEngine.Networking.NetworkBehaviour,System.Int32)">
      <summary>Internal function.</summary>
      <param name="beh">The behaviour the list belongs to.</param>
      <param name="cmdHash">Identifies this list.</param>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.Insert``1(System.Int32,``0)">
      <summary>Same as List::Insert() but also inserts into list on clients.</summary>
      <param name="index">Where to insert the item.</param>
      <param name="item">Item to insert.</param>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.Remove``1(``0)">
      <summary>Same as List:Remove except removes on clients also.</summary>
      <param name="item">Item to remove.</param>
      <returns>Success if removed.</returns>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.RemoveAt(System.Int32)">
      <summary>Same as List:Remove except it removes the index on clients also.</summary>
      <param name="index">Index to remove.</param>
    </member>
    <member name="M:UnityEngine.Networking.SyncList``1.SerializeItem``1(UnityEngine.Networking.NetworkWriter,``0)">
      <summary>This is used to write a value object from a SyncList to a stream.</summary>
      <param name="writer">Stream to write to.</param>
      <param name="item">Item to write.</param>
    </member>
    <member name="F:UnityEngine.Networking.ChannelOption.MaxPendingBuffers">
      <summary>
        <para>The option to set the numbet of pending buffers for a channel.</para>
        <para>These buffers are allocated dynamically as required when writes to the transport layer fail. Each buffer will be the size of maxPacketSize for the channel - usually around 1400 bytes. The default is 16 buffers.This only applies to reliable channels. If a reliable channel runs out of pnding buffers, data will be lost.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Developer">
      <summary>Show log messages with priority Developer and higher, this it the most verbose setting.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Debug">
      <summary>Show log messages with priority Debug and higher.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Info">
      <summary>Show log messages with priority Info and higher. This is the default setting.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Warn">
      <summary>Show log messages with priority Warning and higher.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Error">
      <summary>Show log messages with priority Error and higher.</summary>
    </member>
    <member name="F:UnityEngine.Networking.LogFilter.FilterLevel.Fatal">
      <summary>Show log messages with priority Fatal and higher. this is the least verbose setting.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.Ok">
      <summary>Everything good so far.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.WrongHost">
      <summary>Host doesn't exist.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.WrongConnection">
      <summary>Connection doesn't exist.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.WrongChannel">
      <summary>Channel doesn't exist.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.NoResources">
      <summary>No internal resources ro acomplish request.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.BadMessage">
      <summary>Obsolete.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.Timeout">
      <summary>Timeout happened.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.MessageToLong">
      <summary>Sending message too long to fit internal buffers, or user doesn't present buffer with length enouf to contain receiving message.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.WrongOperation">
      <summary>Operation is not supported.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.VersionMismatch">
      <summary>Different version of protocol on ends of connection.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.CRCMismatch">
      <summary>Two ends of connection have different agreement about channels, channels qos and network parameters.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkError.DNSFailure">
      <summary>The address supplied to connect to was invalid or could not be resolved.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkEventType.DataEvent">
      <summary>New data come in.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkEventType.ConnectEvent">
      <summary>New connection has been connected.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkEventType.DisconnectEvent">
      <summary>Connection has been disconnected.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkEventType.Nothing">
      <summary>Nothing happened.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkEventType.BroadcastEvent">
      <summary>Broadcast discovery event received. To obtain sender connection info and possible complimentary message from him call GetBroadcastConnectionInfo() and GetBroadcastConnectionMessage() functions.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.CheckMethod.Physics3D">
      <summary>Use 3D physics to determine proximity.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkProximityChecker.CheckMethod.Physics2D">
      <summary>Use 2D physics to determine proximity.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.None">
      <summary>Do not sync.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisX">
      <summary>Only x axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisY">
      <summary>Only the y axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisZ">
      <summary>Only the z axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisXY">
      <summary>The x and y axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisXZ">
      <summary>The x and z axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisYZ">
      <summary>The y and z axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.AxisSyncMode.AxisXYZ">
      <summary>The x, y and z axis.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.CompressionSyncMode.None">
      <summary>Do not compress.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.CompressionSyncMode.Low">
      <summary>A low amount of compression that preserves accuracy.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.CompressionSyncMode.High">
      <summary>High Compression - sacrificing accuracy.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.TransformSyncMode.SyncNone">
      <summary>Dont synchronize.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.TransformSyncMode.SyncTransform">
      <summary>Sync using the game object's base transform.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.TransformSyncMode.SyncRigidbody2D">
      <summary>Sync using the <see cref="T:UnityEngine.Rigidbody2D" /> component.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.TransformSyncMode.SyncRigidbody3D">
      <summary>Sync using the <see cref="T:UnityEngine.Rigidbody" /> component.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkTransform.TransformSyncMode.SyncCharacterController">
      <summary>Sync using the <see cref="T:UnityEngine.CharacterController" /> component.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerSpawnMethod.Random">
      <summary>
        <para>Spawn players at a randomly chosen starting position.</para>
        <para>A NetworkStartPosition will be randomly chosen by the NetworkManager from the set of NetworkStartPositions in the current scene.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerSpawnMethod.RoundRobin">
      <summary>
        <para>Spawn players at the next start position.</para>
        <para>The NetworkManager will spawn players at each NetworkStartPosition in the scene on a round-robin basis.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.Unreliable">
      <summary>Just sending message, no grants.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.UnreliableFragmented">
      <summary>The same as unreliable, but big message (up to 32 fragment per message) can be sent.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.UnreliableSequenced">
      <summary>The same as unrelaible but all unorder messages will be dropped. Example: VoIP.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.Reliable">
      <summary>Channel will be configured as relaiable, each message sent in this channel will be delivered or connection will be disconnected.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.ReliableFragmented">
      <summary>Same as reliable, but big messages are allowed (up to 32 fragment with fragmentsize each for message).</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.ReliableSequenced">
      <summary>The same as reliable, but with granting message order.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.StateUpdate">
      <summary>Unreliable, only last message in send buffer will be sent, only most recent message in reading buffer will be delivered.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.ReliableStateUpdate">
      <summary>The same as StateUpdate, but reliable.</summary>
    </member>
    <member name="F:UnityEngine.Networking.QosType.AllCostDelivery">
      <summary>Reliable message will resend almost with each frame, without waiting delivery notification. usefull for important urgent short messages, like a shoot.</summary>
    </member>
    <member name="F:UnityEngine.Networking.ReactorModel.SelectReactor">
      <summary>Network thread will sleep up to threadawake timeout, or up to receive event on socket will happened. Awaked thread will try to read up to maxpoolsize packets from socket and will try update connections ready to send (with fixing awaketimeout rate).</summary>
    </member>
    <member name="F:UnityEngine.Networking.ReactorModel.FixRateReactor">
      <summary>Network thread will sleep up to threadawake timeout, after that it will try receive up to maxpoolsize amount of messages and then will try perform send operation for connection whihc ready to send.</summary>
    </member>
    <member name="F:UnityEngine.Networking.ReactorModel.">
      <summary>Network layer should be updated from main thread by using NetworkUpdate function.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_ADD">
      <summary>Item was added to the list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_CLEAR">
      <summary>The list was cleared.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_INSERT">
      <summary>An item was inserted into the list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_REMOVE">
      <summary>An item was removed from the list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_REMOVEAT">
      <summary>An item was removed at an index from the list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_SET">
      <summary>An item was set to a new value in the list.</summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncList_1.Operation.OP_DIRTY">
      <summary>An item in the list was manually marked dirty.</summary>
    </member>
    <member name="F:UnityEngine.Networking.Version.Current">
      <summary>The current UNET version.</summary>
    </member>
    <member name="F:UnityEngine.Networking.ClientRpcAttribute.channel">
      <summary>The channel ID which this RPC transmission will use.</summary>
    </member>
    <member name="F:UnityEngine.Networking.CommandAttribute.channel">
      <summary>The QoS channel to use to send this command on, see <see cref="T:UnityEngine.Networking.QosType" />.</summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSettingsAttribute.channel">
      <summary>
        <para>The QoS channel to use for updates for this script.</para>
        <para>Updates for SyncVar variables will be sent on the specified QoS channel. The default channel for scripts is zero.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.NetworkSettingsAttribute.sendInterval">
      <summary>
        <para>The sendInterval control how frequently updates are sent for this script.</para>
        <para>If sendInterval is zero, updates will be sent at the end of the frame when dirty bits are set for that script. Note that setting the value of a SyncVar will automatically set dirty bits.If sendInterval is non-zero, updates are deferred until sendInterval seconds have passed since the last update for that script. So it can be used as a throttle in cases where the Sync value is changing constantly on the server, but you don't want it to be updated every frame.The default sendInterval for scripts is 0.1f seconds.The send interval can also be customized by implementing the virtual function GetNetworkSendInterval() on NetworkBehaviour.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncEventAttribute.channel">
      <summary>
        <para>The UNET QoS channel that this event should be sent on.</para>
        <para>This defaults to zero - the default reliable channel. This can be used to make events that are not essential for game play (such as effects) unreliable.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Networking.SyncVarAttribute.hook">
      <summary>The hook attribute can be used to specify a function to be called when the sync var changes value on the client.</summary>
    </member>
    <member name="P:UnityEngine.Rendering.CommandBuffer.name">
      <summary>
        <para>Name of this command buffer.</para>
        <para>This can be used for debugging, so that command buffer activity in Profiler or Frame Debugger can be seen easier. The name does not affect rendering at all.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.CommandBuffer.sizeInBytes">
      <summary>Size of this command buffer in bytes (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.#ctor">
      <summary>
        <para>Create a new empty command buffer.</para>
        <para>You might want to set <see cref="P:UnityEngine.Rendering.CommandBuffer.name" /> for the buffer, so it is easier to see its activity in Profiler or Frame Debugger.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <param name="pass">Shader pass to use (default is -1, meaning "all passes").</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)" /> - it is mostly for copying from one (render)texture into another, potentially using a custom shader.Source texture or render target will be passed to the material as "_MainTex" property.Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <param name="pass">Shader pass to use (default is -1, meaning "all passes").</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Clear">
      <summary>
        <para>Clear all commands in the buffer.</para>
        <para>Removes all previously added commands from the buffer and makes it empty.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      <summary>Adds a "clear render target" command.</summary>
      <param name="clearDepth">Should clear depth buffer?</param>
      <param name="clearColor">Should clear color buffer?</param>
      <param name="backgroundColor">Color to clear with.</param>
      <param name="depth">Depth to clear with (default is 1.0).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color)">
      <summary>Adds a "clear render target" command.</summary>
      <param name="clearDepth">Should clear depth buffer?</param>
      <param name="clearColor">Should clear color buffer?</param>
      <param name="backgroundColor">Color to clear with.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)" />
      <seealso cref="T:UnityEngine.MaterialPropertyBlock" />
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)" />
      <seealso cref="T:UnityEngine.MaterialPropertyBlock" />
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)" />
      <seealso cref="T:UnityEngine.MaterialPropertyBlock" />
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
      <param name="instanceCount">Instance count to render.</param>
      <param name="properties">Additional material properties to apply just before rendering. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
      <param name="instanceCount">Instance count to render.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="T:UnityEngine.ComputeBuffer" />. Typical use case is generating arbitrary amount of data from a <see cref="T:UnityEngine.ComputeShader" /> and then rendering that, without requiring a readback to the CPU.This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect / OpenGL ES 3.1 glDrawArraysIndirect function (on OpenGL ES 3.1 the last argument is reserved and therefore not used).In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Offset where in the buffer the draw arguments are.</param>
      <param name="properties">Additional material properties to apply just before rendering. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="T:UnityEngine.ComputeBuffer" />. Typical use case is generating arbitrary amount of data from a <see cref="T:UnityEngine.ComputeShader" /> and then rendering that, without requiring a readback to the CPU.This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect / OpenGL ES 3.1 glDrawArraysIndirect function (on OpenGL ES 3.1 the last argument is reserved and therefore not used).In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Offset where in the buffer the draw arguments are.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="T:UnityEngine.ComputeBuffer" />. Typical use case is generating arbitrary amount of data from a <see cref="T:UnityEngine.ComputeShader" /> and then rendering that, without requiring a readback to the CPU.This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect / OpenGL ES 3.1 glDrawArraysIndirect function (on OpenGL ES 3.1 the last argument is reserved and therefore not used).In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)">
      <summary>Add a "draw renderer" command.</summary>
      <param name="renderer">Renderer to draw.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32)">
      <summary>Add a "draw renderer" command.</summary>
      <param name="renderer">Renderer to draw.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24).</param>
      <param name="filter">Texture filtering mode (default is Point).</param>
      <param name="format">Format of the render texture (default is ARGB32).</param>
      <param name="readWrite">Color space.</param>
      <param name="antiAliasing">Anti-aliasing (default is no anti-aliasing).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24).</param>
      <param name="filter">Texture filtering mode (default is Point).</param>
      <param name="format">Format of the render texture (default is ARGB32).</param>
      <param name="readWrite">Color space.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24).</param>
      <param name="filter">Texture filtering mode (default is Point).</param>
      <param name="format">Format of the render texture (default is ARGB32).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24).</param>
      <param name="filter">Texture filtering mode (default is Point).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to create the integer name.Release the temporary render texture using <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.After getting a temporary render texture, you can set it as active (<see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />) or blit to/from it (<see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="width">Width in pixels, or -1 for "camera pixel width".</param>
      <param name="height">Height in pixels, or -1 for "camera pixel height".</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.IssuePluginEvent(System.IntPtr,System.Int32)">
      <summary>Send a user-defined event to a native code plugin.</summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="eventID">User defined id to send to the callback.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)">
      <summary>
        <para>Add a "release a temporary render texture" command.</para>
        <para>Releases a temporary render texture with given name. Presumably you have called ::GetTemporaryRT to create it before.Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Add a "set global shader color property" command.</para>
        <para>When the command buffer will be executed, a global shader color property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Add a "set global shader color property" command.</para>
        <para>When the command buffer will be executed, a global shader color property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloat(System.String,System.Single)">
      <summary>
        <para>Add a "set global shader float property" command.</para>
        <para>When the command buffer will be executed, a global shader float property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloat(System.Int32,System.Single)">
      <summary>
        <para>Add a "set global shader float property" command.</para>
        <para>When the command buffer will be executed, a global shader float property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a "set global shader matrix property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a "set global shader matrix property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalTexture(System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set global shader texture property" command.</para>
        <para>When the command buffer will be executed, a global shader texture property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalTexture(System.Int32,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set global shader texture property" command.</para>
        <para>When the command buffer will be executed, a global shader texture property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Add a "set global shader vector property" command.</para>
        <para>When the command buffer will be executed, a global shader vector property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Add a "set global shader vector property" command.</para>
        <para>When the command buffer will be executed, a global shader vector property will be set at this point. The effect is as if <see cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)" /> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier[],UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, or one of built-in temporary textures (<see cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />). All that is expressed by a <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" /> struct, which has implicit conversion operators to save on typing.You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture.See Also: <see cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />, <see cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)" />, <see cref="T:UnityEngine.Rendering.RenderTargetIdentifier" />.</para>
      </summary>
      <param name="colors">Render targets to set as color buffers (MRT).</param>
      <param name="depth">Render target to set as a depth buffer.</param>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeBlendInfo.probe">
      <summary>Reflection Probe used in blending.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeBlendInfo.weight">
      <summary>Specifies the weight used in the interpolation between two probes, value varies from 0.0 to 1.0.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.RenderTargetIdentifier.#ctor(UnityEngine.Rendering.BuiltinRenderTextureType)">
      <summary>Creates a render target identifier.</summary>
      <param name="type">Built-in temporary render texture type.</param>
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />
    </member>
    <member name="M:UnityEngine.Rendering.RenderTargetIdentifier.#ctor(System.String)">
      <summary>Creates a render target identifier.</summary>
      <param name="name">Temporary render texture name.</param>
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />
    </member>
    <member name="M:UnityEngine.Rendering.RenderTargetIdentifier.#ctor(System.Int32)">
      <summary>Creates a render target identifier.</summary>
      <param name="nameID">Temporary render texture name (as integer, see <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />).</param>
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />
    </member>
    <member name="M:UnityEngine.Rendering.RenderTargetIdentifier.#ctor(UnityEngine.RenderTexture)">
      <summary>Creates a render target identifier.</summary>
      <param name="rt">RenderTexture object to use.</param>
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="T:UnityEngine.Rendering.BuiltinRenderTextureType" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.FilterMode,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)" />
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.AddAmbientLight(UnityEngine.Color)">
      <summary>
        <para>Add ambient lighting to probe data.</para>
        <para>If SH probe is used to calculate lighting, this function has the effect of adding ambient light into probe data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.AddDirectionalLight(UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Add directional light to probe data.</para>
        <para>If SH probe is used to calculate lighting, this function has the effect of adding directional light into probe data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.Clear">
      <summary>Clears SH probe to zero.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.operator !=(UnityEngine.Rendering.SphericalHarmonicsL2,UnityEngine.Rendering.SphericalHarmonicsL2)">
      <summary>Returns true if SH probes are different.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.operator *(UnityEngine.Rendering.SphericalHarmonicsL2,System.Single)">
      <summary>Scales SH by a given factor.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.operator *(System.Single,UnityEngine.Rendering.SphericalHarmonicsL2)">
      <summary>Scales SH by a given factor.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.operator +(UnityEngine.Rendering.SphericalHarmonicsL2,UnityEngine.Rendering.SphericalHarmonicsL2)">
      <summary>Adds two SH probes.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.operator ==(UnityEngine.Rendering.SphericalHarmonicsL2,UnityEngine.Rendering.SphericalHarmonicsL2)">
      <summary>Returns true if SH probes are equal.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Skybox">
      <summary>Skybox-based or custom ambient lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Trilight">
      <summary>
        <para>Trilight ambient lighting.</para>
        <para>Ambient is defined by three colors: "sky", "equator" and "ground".See Also: <see cref="P:UnityEngine.RenderSettings.ambientSkyColor" />, <see cref="P:UnityEngine.RenderSettings.ambientEquatorColor" />, <see cref="P:UnityEngine.RenderSettings.ambientGroundColor" />, <see cref="P:UnityEngine.RenderSettings.ambientMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Flat">
      <summary>
        <para>Flat ambient lighting.</para>
        <para>Ambient is defined by a single color.See Also: <see cref="P:UnityEngine.RenderSettings.ambientEquatorColor" />, <see cref="P:UnityEngine.RenderSettings.ambientMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Custom">
      <summary>Ambient lighting is defined by a custom cubemap.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.Zero">
      <summary>Blend factor is (0, 0, 0, 0).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.One">
      <summary>Blend factor is (1, 1, 1, 1).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.DstColor">
      <summary>Blend factor is (Rd, Gd, Bd, Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcColor">
      <summary>Blend factor is (Rs, Gs, Bs, As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusDstColor">
      <summary>Blend factor is (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcAlpha">
      <summary>Blend factor is (As, As, As, As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusSrcColor">
      <summary>Blend factor is (1 - Rs, 1 - Gs, 1 - Bs, 1 - As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.DstAlpha">
      <summary>Blend factor is (Ad, Ad, Ad, Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusDstAlpha">
      <summary>Blend factor is (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcAlphaSaturate">
      <summary>Blend factor is (f, f, f, 1); where f = min(As, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha">
      <summary>Blend factor is (1 - As, 1 - As, 1 - As, 1 - As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Add">
      <summary>
        <para>Add (s + d).</para>
        <para>Add source and destination together, with specified blend modes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Subtract">
      <summary>
        <para>Subtract.</para>
        <para>Subtract the source from the destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ReverseSubtract">
      <summary>
        <para>Reverse subtract.</para>
        <para>Subtract the destination from the source.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Min">
      <summary>
        <para>Min.</para>
        <para>Select the smaller value from source and destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Max">
      <summary>
        <para>Max.</para>
        <para>Select the larger value of in source and destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalClear">
      <summary>
        <para>Logical Clear (0).</para>
        <para>Clears all bits in the target to 0. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalSet">
      <summary>
        <para>Logical SET (1) (D3D11.1 only).</para>
        <para>Performs logical SET (1) operation, effectively setting all bits in the render target. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalCopy">
      <summary>
        <para>Logical Copy (s) (D3D11.1 only).</para>
        <para>This operation copies the source bits to target, effectively disabling blending. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalCopyInverted">
      <summary>
        <para>Logical inverted Copy (!s) (D3D11.1 only).</para>
        <para>This operation inverts the source bits before blitting to target.This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNoop">
      <summary>
        <para>Logical No-op (d) (D3D11.1 only).</para>
        <para>Performs logical no-op (dest) operation, effectively leaving the render target unchanged. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalInvert">
      <summary>
        <para>Logical Inverse (!d) (D3D11.1 only).</para>
        <para>This operation inverts the bits in the destination, ignoring source. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAnd">
      <summary>
        <para>Logical AND (s &amp; d) (D3D11.1 only).</para>
        <para>Performs logical AND (src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNand">
      <summary>
        <para>Logical NAND !(s &amp; d). D3D11.1 only.</para>
        <para>Performs logical NAND !(src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOr">
      <summary>
        <para>Logical OR (s | d) (D3D11.1 only).</para>
        <para>Performs logical OR (src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNor">
      <summary>
        <para>Logical NOR !(s | d) (D3D11.1 only).</para>
        <para>Performs logical NOR !(src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalXor">
      <summary>
        <para>Logical XOR (s XOR d) (D3D11.1 only).</para>
        <para>Performs logical XOR (src XOR dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalEquivalence">
      <summary>
        <para>Logical Equivalence !(s XOR d) (D3D11.1 only).</para>
        <para>This operation performs !(s XOR d). This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAndReverse">
      <summary>
        <para>Logical reverse AND (s &amp; !d) (D3D11.1 only).</para>
        <para>Performs logical reverse AND (src &amp; !dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAndInverted">
      <summary>
        <para>Logical inverted AND (!s &amp; d) (D3D11.1 only).</para>
        <para>Performs logical inverted AND (!src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOrReverse">
      <summary>
        <para>Logical reverse OR (s | !d) (D3D11.1 only).</para>
        <para>Performs logical reverse OR (src | !dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOrInverted">
      <summary>
        <para>Logical inverted OR (!s | d) (D3D11.1 only).</para>
        <para>Performs logical inverted OR (!src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Multiply">
      <summary>
        <para>Multiply (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Screen">
      <summary>
        <para>Screen (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Overlay">
      <summary>
        <para>Overlay (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Darken">
      <summary>
        <para>Darken (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Lighten">
      <summary>
        <para>Lighten (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ColorDodge">
      <summary>
        <para>Color dodge (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ColorBurn">
      <summary>
        <para>Color burn (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HardLight">
      <summary>
        <para>Hard light (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.SoftLight">
      <summary>
        <para>Soft light (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Difference">
      <summary>
        <para>Difference (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Exclusion">
      <summary>
        <para>Exclusion (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLHue">
      <summary>
        <para>HSL Hue (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLSaturation">
      <summary>
        <para>HSL saturation (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLColor">
      <summary>
        <para>HSL color (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLLuminosity">
      <summary>
        <para>HSL luminosity (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.CurrentActive">
      <summary>Currently active render target.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.CameraTarget">
      <summary>Target texture of currently rendering camera.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.Depth">
      <summary>Camera's depth texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.DepthNormals">
      <summary>Camera's depth+normals texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassNormalsSpec">
      <summary>
        <para>Deferred lighting (normals+specular) G-buffer.</para>
        <para>World space normals in RGB channels; specular exponent in A channel.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassLight">
      <summary>
        <para>Deferred lighting light buffer.</para>
        <para>Contains lighting information in legacy (prepass) deferred lighting.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassLightSpec">
      <summary>
        <para>Deferred lighting HDR specular light buffer (Xbox 360 only).</para>
        <para>Contains specular lighting information in legacy (prepass) deferred lighting. This is only used on Xbox 360, and only when camera is HDR.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer0">
      <summary>
        <para>Deferred shading G-buffer #0 (typically diffuse color).</para>
        <para>Built-in deferred shaders put diffuse albedo color into RGB channels of this texture. But your own custom shaders could be outputting anything there of course.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer1">
      <summary>
        <para>Deferred shading G-buffer #1 (typically specular + roughness).</para>
        <para>Built-in deferred shaders put specular color into RGB channels, and roughness into A channel of this texture. But your own custom shaders could be outputting anything there of course.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer2">
      <summary>
        <para>Deferred shading G-buffer #2 (typically normals).</para>
        <para>Built-in deferred shaders put world-space normals into RGB channels of this texture. But your own custom shaders could be outputting anything there of course.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer3">
      <summary>
        <para>Deferred shading G-buffer #3 (typically emission/lighting).</para>
        <para>Built-in deferred shaders put ambient &amp; emission into RGB channels of this texture. And then the lights are also added there during lighting pass. But your own custom shaders could be outputting anything there of course.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.Reflections">
      <summary>
        <para>Reflections gathered from default reflection and reflections probes.</para>
        <para>Used by screen space reflections as a fallback, when it's not possible to get reflections from the screen.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeDepthTexture">
      <summary>Before camera's depth texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterDepthTexture">
      <summary>After camera's depth texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeDepthNormalsTexture">
      <summary>Before camera's depth+normals texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterDepthNormalsTexture">
      <summary>After camera's depth+normals texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeGBuffer">
      <summary>
        <para>Before deferred rendering G-buffer is rendered.</para>
        <para>The G-buffer render target(s) will be set and cleared already, but nothing rendered into them yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterGBuffer">
      <summary>
        <para>After deferred rendering G-buffer is rendered.</para>
        <para>Will be called immediately after all objects are rendered into G-buffer. The G-buffer render target(s) will be active, however they will not be set up as shader properties yet.Generally the <see cref="F:UnityEngine.Rendering.CameraEvent.BeforeLighting" /> event is probably a better place to start doing custom G-buffer modifications.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeLighting">
      <summary>
        <para>Before lighting pass in deferred rendering.</para>
        <para>G-buffer will already be rendered and setup for access as shader parameters.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterLighting">
      <summary>
        <para>After lighting pass in deferred rendering.</para>
        <para>Light buffer will be the active render target at this point.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeFinalPass">
      <summary>Before final geometry pass in deferred lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterFinalPass">
      <summary>After final geometry pass in deferred lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeForwardOpaque">
      <summary>Before opaque objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterForwardOpaque">
      <summary>After opaque objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeImageEffectsOpaque">
      <summary>Before image effects that happen between opaque &amp; transparent objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterImageEffectsOpaque">
      <summary>After image effects that happen between opaque &amp; transparent objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeSkybox">
      <summary>Before skybox is drawn.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterSkybox">
      <summary>After skybox is drawn.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeForwardAlpha">
      <summary>Before transparent objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterForwardAlpha">
      <summary>After transparent objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeImageEffects">
      <summary>Before image effects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterImageEffects">
      <summary>After image effects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterEverything">
      <summary>After camera has done rendering everything.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeReflections">
      <summary>Before reflections pass in deferred rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterReflections">
      <summary>After reflections pass in deferred rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Alpha">
      <summary>Write alpha component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Blue">
      <summary>Write blue component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Green">
      <summary>Write green component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Red">
      <summary>Write red component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.All">
      <summary>Write all components (R, G, B and Alpha).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Disabled">
      <summary>Depth or stencil test is disabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Never">
      <summary>Never pass depth or stencil test.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Less">
      <summary>Pass depth or stencil test when new value is less than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Equal">
      <summary>Pass depth or stencil test when values are equal.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.LessEqual">
      <summary>Pass depth or stencil test when new value is less or equal than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Greater">
      <summary>Pass depth or stencil test when new value is greater than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.NotEqual">
      <summary>Pass depth or stencil test when values are different.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.GreaterEqual">
      <summary>Pass depth or stencil test when new value is greater or equal than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Always">
      <summary>Always pass depth or stencil test.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Off">
      <summary>Disable culling.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Front">
      <summary>Cull front-facing geometry.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Back">
      <summary>Cull back-facing geometry.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.DefaultReflectionMode.Skybox">
      <summary>
        <para>Skybox-based default reflection.</para>
        <para>Default specular reflection cubemap is calculated from the current skybox.See Also: <see cref="P:UnityEngine.RenderSettings.defaultReflectionMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.DefaultReflectionMode.Custom">
      <summary>
        <para>Custom default reflection.</para>
        <para>You can specify cubemap that will be used as a default specular reflection.See Also: <see cref="P:UnityEngine.RenderSettings.customReflection" />, <see cref="P:UnityEngine.RenderSettings.defaultReflectionMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGL2">
      <summary>OpenGL 2.x graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Direct3D9">
      <summary>Direct3D 9 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Direct3D11">
      <summary>Direct3D 11 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStation3">
      <summary>PlayStation 3 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Null">
      <summary>
        <para>No graphics API.</para>
        <para>This typically happens when a "null" graphics API is explicitly requested from command line arguments, for example when running game servers or editor in batch mode.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceType" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Xbox360">
      <summary>Xbox 360 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLES2">
      <summary>OpenGL ES 2.0 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLES3">
      <summary>OpenGL ES 3.0 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStationVita">
      <summary>PlayStation Vita graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStation4">
      <summary>PlayStation 4 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.XboxOne">
      <summary>Xbox One graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStationMobile">
      <summary>PlayStation Mobile (PSM) graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Metal">
      <summary>iOS Metal graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLCore">
      <summary>OpenGL (Core profile - GL3 or later) graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Direct3D12">
      <summary>Direct3D 12 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Nintendo3DS">
      <summary>Nintendo 3DS graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.BeforeShadowMap">
      <summary>
        <para>Before shadowmap is rendered.</para>
        <para>Shadowmap render target will be set and cleared, but shadow casters not rendered yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.AfterShadowMap">
      <summary>
        <para>After shadowmap is rendered.</para>
        <para>All shadow casters are already rendered, and current render target is still the shadowmap.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.BeforeScreenspaceMask">
      <summary>
        <para>Before directional light screenspace shadow mask is computed.</para>
        <para>Directional lights when using non-mobile shadows "gather" shadowmap into a screenspace buffer and do PCF filtering during this step. Later on actual object rendering just samples this screenspace buffer.This light event will execute command buffers when the screenspace mask render target is set and cleared, but the shadow mask is not computed yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.AfterScreenspaceMask">
      <summary>
        <para>After directional light screenspace shadow mask is computed.</para>
        <para>Directional lights when using non-mobile shadows "gather" shadowmap into a screenspace buffer and do PCF filtering during this step. Later on actual object rendering just samples this screenspace buffer.This light event will execute command buffers when the screenspace mask is computed, and the active render target is still the screenspace mask.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.Default">
      <summary>Default opaque sorting mode.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.FrontToBack">
      <summary>Do rough front-to-back sorting of opaque objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.NoDistanceSort">
      <summary>Do not sort opaque objects by distance.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Normal">
      <summary>Regular shader pass that does not interact with lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Vertex">
      <summary>Legacy vertex-lit shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.VertexLM">
      <summary>Legacy vertex-lit shader pass, with mobile lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.VertexLMRGBM">
      <summary>Legacy vertex-lit shader pass, with desktop (RGBM) lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ForwardBase">
      <summary>Forward rendering base pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ForwardAdd">
      <summary>Forward rendering additive pixel light pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.LightPrePassBase">
      <summary>Legacy deferred lighting (light pre-pass) base pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.LightPrePassFinal">
      <summary>Legacy deferred lighting (light pre-pass) final pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ShadowCaster">
      <summary>Shadow caster &amp; depth texure shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Deferred">
      <summary>Deferred Shading shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Meta">
      <summary>
        <para>Shader pass used to generate the albedo and emissive values used as input to lightmapping.</para>
        <para>Baked and realtime GI use this pass to get information about the shader emission and albedo properties.Surface shaders generate this pass automatically, in a similar way to other lighting related passes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Uncompressed">
      <summary>Baked Reflection cubemap will be left uncompressed.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Compressed">
      <summary>Baked Reflection cubemap will be compressed.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Auto">
      <summary>
        <para>Baked Reflection cubemap will be compressed if compression format is suitable.</para>
        <para>Some texture compression formats produce bad wrapping artifacts when used on cubemaps, for example PVRTC. On platforms that use these formats, baked reflection cubemaps will be left uncompressed.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeClearFlags.Skybox">
      <summary>
        <para>Clear with the skybox.</para>
        <para>If a skybox is not set up, the Reflection Probe will clear with a <see cref="P:UnityEngine.ReflectionProbe.backgroundColor" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeClearFlags.SolidColor">
      <summary>Clear with a background color.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Baked">
      <summary>Reflection probe is baked in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Realtime">
      <summary>Reflection probe is updating in realtime.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Custom">
      <summary>Reflection probe uses a custom texture specified by the user.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.OnAwake">
      <summary>Causes the probe to update only on the first frame it becomes visible. The probe will no longer update automatically, however you may subsequently use RenderProbe to refresh the probeSee Also: <see cref="M:UnityEngine.ReflectionProbe.RenderProbe(UnityEngine.RenderTexture)" />.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.EveryFrame">
      <summary>Causes Unity to update the probe's cubemap every frame. Note that updating a probe is very costly. Setting this option on too many probes could have a significant negative effect on frame rate. Use time-slicing to help improve performance.See Also: <see cref="T:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode" />.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.ViaScripting">
      <summary>Using this option indicates that the probe will never be automatically updated by Unity. This is useful if you wish to completely control the probe refresh behavior via scripting.See Also: <see cref="M:UnityEngine.ReflectionProbe.RenderProbe(UnityEngine.RenderTexture)" />.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.AllFacesAtOnce">
      <summary>Instructs Unity to use time-slicing by first rendering all faces at once, then spreading the remaining work over the next 8 frames. Using this option, updating the probe will take 9 frames.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.IndividualFaces">
      <summary>Instructs Unity to spread the rendering of each face over several frames. Using this option, updating the cubemap will take 14 frames. This option greatly reduces the impact on frame rate, however it may produce incorrect results, especially in scenes where lighting conditions change over these 14 frames.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.NoTimeSlicing">
      <summary>Unity will render the probe entirely in one frame.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeType.Cube">
      <summary>Surrounding of the reflection probe is rendered into cubemap.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeType.Card">
      <summary>Surrounding of the reflection probe is rendered onto a quad.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.Off">
      <summary>Reflection probes are disabled, skybox will be used for reflection.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.BlendProbes">
      <summary>Reflection probes are enabled. Blending occurs only between probes, useful in indoor environments. The renderer will use default reflection if there are no reflection probes nearby, but no blending between default reflection and probe will occur.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.BlendProbesAndSkybox">
      <summary>Reflection probes are enabled. Blending occurs between probes or probes and default reflection, useful for outdoor environments.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.Simple">
      <summary>Reflection probes are enabled, but no blending will occur between probes when there are two overlapping volumes.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferLoadAction.Load">
      <summary>Make RenderBuffer to Load its contents when setting as RenderTarget.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferLoadAction.DontCare">
      <summary>RenderBuffer will try to skip loading its contents on setting as Render Target.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.Store">
      <summary>Make RenderBuffer to Store its contents.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.DontCare">
      <summary>RenderBuffer will try to skip storing its contents.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.Off">
      <summary>No shadows are cast from this object.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.On">
      <summary>
        <para>Shadows are cast from this object.</para>
        <para>Shadow rendering will use the same culling mode as specified in the object's shader. Typically this means that single-sided objects (like a Plane or a Quad) do not cast shadows if the light is behind them. Use <see cref="F:UnityEngine.Rendering.ShadowCastingMode.TwoSided" /> to treat objects as two-sided for shadow rendering.See Also: <see cref="P:UnityEngine.Renderer.shadowCastingMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.TwoSided">
      <summary>
        <para>Shadows are cast from this object, treating it as two-sided.</para>
        <para>Shadow rendering will turn off backface culling, even if object's shader has backface culling on. This means that single-sided objects (like a Plane or a Quad) will cast shadows, even if the light is behind them.See Also: <see cref="P:UnityEngine.Renderer.shadowCastingMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.ShadowsOnly">
      <summary>
        <para>Object casts shadows, but is otherwise invisible in the scene.</para>
        <para>This is useful for certain effects or optimization purposes; essentially this makes an object that only casts shadows, but is otherwise invisible.See Also: <see cref="P:UnityEngine.Renderer.shadowCastingMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Keep">
      <summary>Keeps the current stencil value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Zero">
      <summary>Sets the stencil buffer value to zero.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Replace">
      <summary>Replace the stencil buffer value with reference value (specified in the shader).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.IncrementSaturate">
      <summary>Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.DecrementSaturate">
      <summary>Decrements the current stencil buffer value. Clamps to 0.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Invert">
      <summary>Bitwise inverts the current stencil buffer value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.IncrementWrap">
      <summary>Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.DecrementWrap">
      <summary>Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.</summary>
    </member>
    <member name="P:UnityEngine.Serialization.FormerlySerializedAsAttribute.oldName">
      <summary>The name of the field before the rename.</summary>
    </member>
    <member name="M:UnityEngine.SocialPlatforms.GameCenter.GameCenterPlatform.ResetAllAchievements">
      <summary>
        <para>Reset all the achievements for the local user.</para>
        <para>Only affects the currently running game. Javascript code example:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SocialPlatforms.GameCenter.GameCenterPlatform.ShowDefaultAchievementCompletionBanner(System.Boolean)">
      <summary>
        <para>Show the default iOS banner when achievements are completed.</para>
        <para>This only works on iOS 5.0+ and does nothing on older versions. Javascript code example:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SocialPlatforms.GameCenter.GameCenterPlatform.ShowLeaderboardUI(System.String,UnityEngine.SocialPlatforms.TimeScope)">
      <summary>Show the leaderboard UI with a specific leaderboard shown initially with a specific time scope selected.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.Range.count">
      <summary>The total amount of scores retreived.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.Range.from">
      <summary>The rank of the first score which is returned.</summary>
    </member>
    <member name="M:UnityEngine.SocialPlatforms.Range.#ctor(System.Int32,System.Int32)">
      <summary>Constructor for a score range, the range starts from a specific value and contains a maxium score count.</summary>
      <param name="fromValue">The minimum allowed value.</param>
      <param name="valueCount">The number of possible values.</param>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.UserState.Online">
      <summary>The user is online.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.UserState.OnlineAndAway">
      <summary>The user is online but away from his computer.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.UserState.OnlineAndBusy">
      <summary>The user is only but set his status to busy.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.UserState.Offline">
      <summary>The user is offline.</summary>
    </member>
    <member name="F:UnityEngine.SocialPlatforms.UserState.Playing">
      <summary>The user is playing a game.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetInnerUV(UnityEngine.Sprite)">
      <summary>
        <para>Inner UV's of the <see cref="T:UnityEngine.Sprite" />.</para>
        <para>If borders are used they will be taken into consideration.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetMinSize(UnityEngine.Sprite)">
      <summary>Minimum width and height of the <see cref="T:UnityEngine.Sprite" />.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetOuterUV(UnityEngine.Sprite)">
      <summary>Outer UV's of the <see cref="T:UnityEngine.Sprite" />.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetPadding(UnityEngine.Sprite)">
      <summary>
        <para>Return the padding on the sprite.</para>
        <para>If the sprite has been packed it is possible that edges have been cliped from the source sprite. This will give the edge clipped size in pixels for each edge (x=left, y=bottom, z=right, w=top).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Tizen.Window.windowHandle">
      <summary>Get pointer to the native window handle.</summary>
    </member>
    <member name="M:UnityEngine.VR.InputTracking.GetLocalPosition(UnityEngine.VR.VRNode)">
      <summary>The current position of the requested VRNode.</summary>
      <param name="node">Node index.</param>
      <returns>Position of node local to its tracking space.</returns>
    </member>
    <member name="M:UnityEngine.VR.InputTracking.GetLocalRotation(UnityEngine.VR.VRNode)">
      <summary>The current rotation of the requested VRNode.</summary>
      <param name="node">Node index.</param>
      <returns>Rotation of node local to its tracking space.</returns>
    </member>
    <member name="M:UnityEngine.VR.InputTracking.Recenter">
      <summary>Center tracking on the current pose.</summary>
    </member>
    <member name="P:UnityEngine.VR.VRDevice.family">
      <summary>
        <para>The name of the family of the loaded VR device.</para>
        <para>There can be many different devices for a given family.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.VR.VRDevice.isPresent">
      <summary>Successfully detected a VR device in working order.</summary>
    </member>
    <member name="P:UnityEngine.VR.VRDevice.model">
      <summary>Specific model of loaded VR device.</summary>
    </member>
    <member name="M:UnityEngine.VR.VRDevice.GetNativePtr">
      <summary>
        <para>Native pointer to the VR device structure, if available.</para>
        <para>This can be used to obtain more features for a given VR device.</para>
      </summary>
      <returns>Native pointer to VR device if available, else 0.</returns>
    </member>
    <member name="P:UnityEngine.VR.VRSettings.enabled">
      <summary>
        <para>Globally enables or disables VR for the application.</para>
        <para>When enabled, VR output is automatically mirrored to the main display. The main window is still controlled by Screen and related APIs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.VR.VRSettings.loadedDevice">
      <summary>
        <para>Type of VR device that is currently in use.</para>
        <para>You can set this to the desired VR device and it will be loaded. Note that if a VR device was already loaded, a restart may be forced.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.VR.VRSettings.renderScale">
      <summary>
        <para>Controls the texel:pixel ratio before lens correction, trading performance for sharpness.</para>
        <para>Eye textures are allocated to match the largest value encountered at runtime. If the value increases beyond this, eye textures are re-allocated. If the value decreases, viewport scaling is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.VR.VRSettings.showDeviceView">
      <summary>
        <para>Mirror what is shown on the device to the main display, if possible.</para>
        <para>Only the left eye is mirrored.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VR.VRDeviceType.None">
      <summary>No VR Device.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRDeviceType.Stereo">
      <summary>Stereo 3D via D3D11 or OpenGL.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRDeviceType.Split">
      <summary>Split screen stereo 3D (the left and right cameras are rendered side by side).</summary>
    </member>
    <member name="F:UnityEngine.VR.VRDeviceType.Oculus">
      <summary>Oculus family of VR devices.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRDeviceType.Morpheus">
      <summary>
        <para>Sony's Project Morpheus VR device for Playstation 4.</para>
        <para>This device type is only valid when running on the Playstation 4.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VR.VRNode.LeftEye">
      <summary>Left Eye node.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRNode.RightEye">
      <summary>Right Eye node.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRNode.CenterEye">
      <summary>Node between left and right eyes.</summary>
    </member>
    <member name="F:UnityEngine.VR.VRNode.Head">
      <summary>Head node.</summary>
    </member>
    <member name="M:UnityEngine.Windows.Crypto.ComputeMD5Hash(System.Byte[])">
      <summary>Computes MD5 hash value for the specified byte array.</summary>
      <param name="buffer">The input to compute the hash code for.</param>
    </member>
    <member name="M:UnityEngine.Windows.Crypto.ComputeSHA1Hash(System.Byte[])">
      <summary>Computes SHA1 hash value for the specified byte array.</summary>
      <param name="buffer">The input to compute the hash code for.</param>
    </member>
    <member name="M:UnityEngine.Windows.Directory.CreateDirectory(System.String)">
      <summary>Creates directory in the specified path.</summary>
      <param name="path">The directory path to create.</param>
    </member>
    <member name="M:UnityEngine.Windows.Directory.Delete(System.String)">
      <summary>Deletes a directory from a specified path.</summary>
      <param name="path">The name of the directory to remove.</param>
    </member>
    <member name="M:UnityEngine.Windows.Directory.Exists(System.String)">
      <summary>Determines whether the given path refers to an existing directory.</summary>
      <param name="path">The path to test.</param>
    </member>
    <member name="M:UnityEngine.Windows.File.Delete(System.String)">
      <summary>Deletes the specified file.</summary>
      <param name="path">The name of the file to be deleted.</param>
    </member>
    <member name="M:UnityEngine.Windows.File.Exists(System.String)">
      <summary>Determines whether the specified file exists.</summary>
      <param name="path">The file to check.</param>
    </member>
    <member name="M:UnityEngine.Windows.File.ReadAllBytes(System.String)">
      <summary>Opens a binary file, reads the contents of the file into a byte array, and then closes the file.</summary>
      <param name="path">The file to open for reading.</param>
    </member>
    <member name="M:UnityEngine.Windows.File.WriteAllBytes(System.String,System.Byte[])">
      <summary>Creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is overwritten.</summary>
      <param name="path">The file to write to.</param>
      <param name="bytes">The bytes to write to the file.</param>
    </member>
    <member name="F:UnityEngine.WindowsPhone.Media.MediaState.Stopped">
      <summary>Media playback is stopped.</summary>
    </member>
    <member name="F:UnityEngine.WindowsPhone.Media.MediaState.Playing">
      <summary>Media is currently playing.</summary>
    </member>
    <member name="F:UnityEngine.WindowsPhone.Media.MediaState.Paused">
      <summary>Media playback is paused.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Application.InvokeOnAppThread(UnityEngine.WSA.AppCallbackItem,System.Boolean)">
      <summary>Executes callback item on application thread.</summary>
      <param name="item">Item to execute.</param>
      <param name="waitUntilDone">Wait until item is executed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Application.InvokeOnUIThread(UnityEngine.WSA.AppCallbackItem,System.Boolean)">
      <summary>Executes callback item on UI thread.</summary>
      <param name="item">Item to execute.</param>
      <param name="waitUntilDone">Wait until item is executed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Application.RunningOnAppThread">
      <summary>Returns true if you're running on application thread.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Application.RunningOnUIThread">
      <summary>Returns true if you're running on UI thread.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Cursor.SetCustomCursor(System.UInt32)">
      <summary>
        <para>Set a custom cursor.</para>
        <para>This creates new CoreCursor(CoreCursorType::Custom, id) and assigns it to CoreIndependentInputSource.PointerCursor if independent input source is enabled, otherwise it's assigned to CoreWindow.PointerCursor. The resource id for cursor is created inside Win32 .RC file.</para>
      </summary>
      <param name="id">The cursor resource id.</param>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchFile(UnityEngine.WSA.Folder,System.String,System.Boolean)">
      <summary>
        <para>Launches the default app associated with specified file.</para>
        <para>Note: if the application associated with file is the same as the one performing the launch, Windows won't open a new application, instead it will simply invoke OnActivated event in App.xaml.[cs/cpp] file.</para>
      </summary>
      <param name="folder">Folder type where the file is located.</param>
      <param name="relativeFilePath">Relative file path inside the specified folder.</param>
      <param name="showWarning">Shows user a warning that application will be switched.</param>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchFileWithPicker(System.String)">
      <summary>Opens a dialog for picking the file.</summary>
      <param name="fileExtension">File extension.</param>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchUri(System.String,System.Boolean)">
      <summary>Starts the default app associated with the URI scheme name for the specified URI, using the specified options.</summary>
      <param name="uri">The URI.</param>
      <param name="showWarning">Displays a warning that the URI is potentially unsafe.</param>
    </member>
    <member name="M:UnityEngine.WSA.SecondaryTileData.#ctor(System.String,System.String)">
      <summary>Constructor for SecondaryTileData, sets default values for all members.</summary>
      <param name="id">Unique identifier for secondary tile.</param>
      <param name="displayName">A display name for a tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete(UnityEngine.Vector2)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="pos">The coordinates for a request to unpin tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete(UnityEngine.Rect)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="area">The area on the screen above which the request to unpin tile will be displayed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.PeriodicBadgeUpdate(System.String,System.Single)">
      <summary>
        <para>Starts periodic update of a badge on a tile.</para>
        <para>A remote uri will be checked periodically to retrieve an update for a badge.</para>
      </summary>
      <param name="uri">A remote location from where to retrieve tile update</param>
      <param name="interval">A time interval in minutes, will be rounded to a value, supported by the system</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.PeriodicUpdate(System.String,System.Single)">
      <summary>
        <para>Starts periodic update of a tile.</para>
        <para>A remote uri will be checked periodically to retrieve an update for a tile.</para>
      </summary>
      <param name="uri">a remote location fromwhere to retrieve tile update</param>
      <param name="interval">a time interval in minutes, will be rounded to a value, supported by the system</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.RemoveBadge">
      <summary>Remove badge from tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.StopPeriodicBadgeUpdate">
      <summary>Stops previously started periodic update of a tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.StopPeriodicUpdate">
      <summary>Stops previously started periodic update of a tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Update(System.String)">
      <summary>
        <para>Send a notification for tile (update tiles look).</para>
        <para>A tile is updated by providing and XML document with new look. The second version is a convenience method to make tile display image, text or both. At least one of medium and text argumets must be provided, and these two are used to determine whether this is image-only, text-only or image-and-text tile. Uris ms-appx:/// and ms-appdata://<c>local</c> can be used to access local application resources. If uri points to network resource, internet access capability must be enabled in applications manifest.</para>
      </summary>
      <param name="xml">A string containing XML document for new tile look.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Update(System.String,System.String,System.String,System.String)">
      <summary>
        <para>Send a notification for tile (update tiles look).</para>
        <para>A tile is updated by providing and XML document with new look. The second version is a convenience method to make tile display image, text or both. At least one of medium and text argumets must be provided, and these two are used to determine whether this is image-only, text-only or image-and-text tile. Uris ms-appx:/// and ms-appdata://<c>local</c> can be used to access local application resources. If uri points to network resource, internet access capability must be enabled in applications manifest.</para>
      </summary>
      <param name="medium">An <c>uri</c> to 150x150 image, shown on medium tile.</param>
      <param name="wide">An <c>uri</c> to a 310x150 image to be shown on a wide tile (if such issupported).</param>
      <param name="large">An <c>uri</c> to a 310x310 image to be shown on a large tile (if such is supported).</param>
      <param name="text">A text to shown on a tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.UpdateBadgeImage(System.String)">
      <summary>
        <para>Sets or updates badge on a tile to an image.</para>
        <para>An image on a badge must be one of predefined glyphs: http://msdn.microsoft.com/en-us/library/windows/apps/hh779719.aspx.</para>
      </summary>
      <param name="image">Image identifier.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.UpdateBadgeNumber(System.Single)">
      <summary>
        <para>Set or update a badge on a tile to a number.</para>
        <para>Number must be supported by the system, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh779719.aspx.</para>
      </summary>
      <param name="number">Number to be shown on a badge.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData,UnityEngine.Vector2)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <param name="pos">The coordinates for a request to create new tile.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData,UnityEngine.Rect)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <param name="area">The area on the screen above which the request to create new tile will be displayed.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String,UnityEngine.Vector2)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
      <param name="pos">The coordinates for a request to unpin tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String,UnityEngine.Rect)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
      <param name="area">The area on the screen above which the request to unpin tile will be displayed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Exists(System.String)">
      <summary>
        <para>Whether secondary tile is pinned to start screen.</para>
        <para>When hasUserConsent is <c>true</c>, this property determines, whether tile is present on start screen. Always true for the main tile.</para>
      </summary>
      <param name="tileId">An identifier for secondary tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetSecondaries">
      <summary>
        <para>Gets all secondary tiles.</para>
        <para>Secondary tile exists if it's pinned to start screen or a request to pin it is not yet complete.</para>
      </summary>
      <returns>An array of Tile objects.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetSecondary(System.String)">
      <summary>Returns the secondary tile, identified by tile id.</summary>
      <param name="tileId">A tile identifier.</param>
      <returns>A Tile object or null if secondary tile does not exist (not pinned to start screen and user request is complete).</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetTemplate(UnityEngine.WSA.TileTemplate)">
      <summary>
        <para>Get template XML for tile notification.</para>
        <para>This can be used to retrieve a template for one of the predefined styles for tiles.</para>
      </summary>
      <param name="templ">A template identifier.</param>
      <returns>String, which is an empty XML document to be filled and used for tile notification.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Hide">
      <summary>Hide displayed toast notification.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Show">
      <summary>Show toast notification.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Create(System.String)">
      <summary>
        <para>Create toast notification.</para>
        <para>Toast notification is created by providing XML document with it's data. A second variant is a convenience method to show simple toast with text, optionally with image on it.</para>
      </summary>
      <param name="xml">XML document with tile data.</param>
      <returns>A toast object for further work with created notification or null, if creation of toast failed.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Create(System.String,System.String)">
      <summary>
        <para>Create toast notification.</para>
        <para>Toast notification is created by providing XML document with it's data. A second variant is a convenience method to show simple toast with text, optionally with image on it.</para>
      </summary>
      <param name="image">Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.</param>
      <param name="text">A text to display on a toast notification.</param>
      <returns>A toast object for further work with created notification or null, if creation of toast failed.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Toast.GetTemplate(UnityEngine.WSA.ToastTemplate)">
      <summary>
        <para>Get template XML for toast notification.</para>
        <para>This can be used to retrieve a template for one of the predefined styles for toasts.</para>
      </summary>
      <param name="templ">A template identifier.</param>
      <returns>string, which is an empty XML document to be filled and used for toast notification.</returns>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.CodeActivated">
      <summary>The window was activated.</summary>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.Deactivated">
      <summary>The window was deactivated.</summary>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.PointerActivated">
      <summary>The window was activated by pointer interaction.</summary>
    </member>
    <member name="P:UnityEngine.AccelerationEvent.acceleration">
      <summary>Value of acceleration.</summary>
    </member>
    <member name="P:UnityEngine.AccelerationEvent.deltaTime">
      <summary>Amount of time passed since last accelerometer measurement.</summary>
    </member>
    <member name="P:UnityEngine.AnchoredJoint2D.anchor">
      <summary>The joint's anchor point on the object that has the joint component.</summary>
    </member>
    <member name="P:UnityEngine.AnchoredJoint2D.connectedAnchor">
      <summary>The joint's anchor point on the second object (ie, the one which doesn't have the joint component).</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchEnabled">
      <summary>Property indicating whether the system provides secondary touch input.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchHeight">
      <summary>Property indicating the height of the secondary touchpad.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchWidth">
      <summary>Property indicating the width of the secondary touchpad.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.touchCountSecondary">
      <summary>Number of secondary touches. Guaranteed not to change throughout the frame. (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.AndroidInput.GetSecondaryTouch(System.Int32)">
      <summary>Returns object representing status of a specific touch on a secondary touchpad (Does not allocate temporary variables).</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaClass.#ctor(System.String)">
      <summary>
        <para>Construct an AndroidJavaClass from the class name.</para>
        <para>This essentially means locate the class type and allocate a <c>java.lang.Class</c> object of that particular type.</para>
      </summary>
      <param name="className">Specifies the Java class name (e.g. <c>java.lang.String</c>).</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.#ctor(System.String,System.Object[])">
      <summary>
        <para>Construct an AndroidJavaObject based on the name of the class.</para>
        <para>This essentially means locate the class type, allocate an object and run the specified constructor.</para>
      </summary>
      <param name="className">Specifies the Java class name (e.g. "<c>java.lang.String</c>" or "<c>java/lang/String</c>").</param>
      <param name="args">An array of parameters passed to the constructor.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Call(System.String,System.Object[])">
      <summary>
        <para>Calls a Java method on an object (non-static).</para>
        <para>To call a method with return type 'void', use the regular version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Call``1(System.String,System.Object[])">
      <summary>
        <para>Call a Java method on an object.</para>
        <para>To call a Java method with a non-void return type, use the generic version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.CallStatic(System.String,System.Object[])">
      <summary>
        <para>Call a static Java method on a class.</para>
        <para>To call a static method with return type 'void', use the regular version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.CallStatic``1(System.String,System.Object[])">
      <summary>
        <para>Call a static Java method on a class.</para>
        <para>To call a static method with a non-void return type, use the generic version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Dispose">
      <summary>
        <para>IDisposable callback.</para>
        <para>Used in conjunction with using() { }See Also: <see href="system.idisposable" cref="IDisposable Interface (MSDN)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Get``1(System.String)">
      <summary>
        <para>Get the value of a field in an object (non-static).</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. <c>int counter;</c> would have fieldName = "counter").</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.GetRawClass">
      <summary>Retrieve the <c>raw</c> jclass pointer to the Java class.</summary>
      <seealso cref="M:UnityEngine.AndroidJavaObject.GetRawObject" />
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.GetRawObject">
      <summary>Retrieve the <c>raw</c> jobject pointer to the Java object.</summary>
      <seealso cref="M:UnityEngine.AndroidJavaObject.GetRawClass" />
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.GetStatic``1(System.String)">
      <summary>
        <para>Get the value of a static field in an object type.</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. &lt;i&gt;int counter;&lt;/i&gt; would have fieldName = "counter").</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Set``1(System.String,``0)">
      <summary>
        <para>Set the value of a field in an object (non-static).</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. <c>int counter;</c> would have fieldName = "counter").</param>
      <param name="val">The value to assign to the field. It has to match the field type.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.SetStatic``1(System.String,``0)">
      <summary>
        <para>Set the value of a static field in an object type.</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. <c>int counter;</c> would have fieldName = "counter").</param>
      <param name="val">The value to assign to the field. It has to match the field type.</param>
    </member>
    <member name="F:UnityEngine.AndroidJavaProxy.javaInterface">
      <summary>Java interface implemented by the proxy.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.Invoke(System.String,System.Object[])">
      <summary>Called by the java vm whenever a method is invoked on the java proxy interface. You can override this to run special code on method invokation, or you can leave the implementation as is, and leave the default behavior which is to look for c# methods matching the signature of the java method.</summary>
      <param name="methodName">Name of the invoked java method.</param>
      <param name="args">Arguments passed from the java vm - converted into AndroidJavaObject, AndroidJavaClass or a primitive.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.Invoke(System.String,UnityEngine.AndroidJavaObject[])">
      <summary>Called by the java vm whenever a method is invoked on the java proxy interface. You can override this to run special code on method invokation, or you can leave the implementation as is, and leave the default behavior which is to look for c# methods matching the signature of the java method.</summary>
      <param name="methodName">Name of the invoked java method.</param>
      <param name="javaArgs">Arguments passed from the java vm - all objects are represented by AndroidJavaObject, int for instance is represented by a java.lang.Integer object.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.AllocObject(System.IntPtr)">
      <summary>Allocates a new Java object without invoking any of the constructors for the object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.AttachCurrentThread">
      <summary>
        <para>Attaches the current thread to a Java (Dalvik) VM.</para>
        <para>A thread must be attached to the VM before any other JNI calls can be made.Returns 0 on success; returns a negative number on failure.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallBooleanMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallByteMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallCharMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallDoubleMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallFloatMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallIntMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallLongMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallShortMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticBooleanMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticByteMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticCharMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticDoubleMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticFloatMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticIntMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticLongMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticShortMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticStringMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This is a convenience function that calls CallStaticObjectMethod() with the same parameters, but creates a managed string from the result.See Also: <see cref="M:UnityEngine.AndroidJNI.CallStaticObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticVoidMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStringMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This is a convenience function that calls CallObjectMethod() with the same parameters, but creates a managed string from the result.See Also: AndroidJNI.CallObjectMethod.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallVoidMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DeleteGlobalRef(System.IntPtr)">
      <summary>Deletes the global reference pointed to by <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DeleteLocalRef(System.IntPtr)">
      <summary>Deletes the local reference pointed to by <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DetachCurrentThread">
      <summary>
        <para>Detaches the current thread from a Java (Dalvik) VM.</para>
        <para>A thread must be detached from the VM before exiting.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.EnsureLocalCapacity(System.Int32)">
      <summary>Ensures that at least a given number of local references can be created in the current thread.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionClear">
      <summary>Clears any exception that is currently being thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionDescribe">
      <summary>Prints an exception and a backtrace of the stack to the <c>logcat</c></summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionOccurred">
      <summary>Determines if an exception is being thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FatalError(System.String)">
      <summary>Raises a fatal error and does not expect the VM to recover. This function does not return.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FindClass(System.String)">
      <summary>This function loads a locally-defined class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromBooleanArray(System.IntPtr)">
      <summary>Convert a Java array of <c>boolean</c> to a managed array of System.Boolean.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetBooleanArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromByteArray(System.IntPtr)">
      <summary>Convert a Java array of <c>byte</c> to a managed array of System.Byte.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetByteArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromCharArray(System.IntPtr)">
      <summary>Convert a Java array of <c>char</c> to a managed array of System.Char.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetCharArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromDoubleArray(System.IntPtr)">
      <summary>Convert a Java array of <c>double</c> to a managed array of System.Double.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetDoubleArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromFloatArray(System.IntPtr)">
      <summary>Convert a Java array of <c>float</c> to a managed array of System.Single.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromIntArray(System.IntPtr)">
      <summary>Convert a Java array of <c>int</c> to a managed array of System.Int32.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetIntArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromLongArray(System.IntPtr)">
      <summary>Convert a Java array of <c>long</c> to a managed array of System.Int64.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromObjectArray(System.IntPtr)">
      <summary>Convert a Java array of <c>java.lang.Object</c> to a managed array of System.IntPtr, representing Java objects.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromReflectedField(System.IntPtr)">
      <summary>Converts a <c>java.lang.reflect.Field</c> to a field ID.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromReflectedMethod(System.IntPtr)">
      <summary>Converts a <c>java.lang.reflect.Method</c> or <c>java.lang.reflect.Constructor</c> object to a method ID.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromShortArray(System.IntPtr)">
      <summary>Convert a Java array of <c>short</c> to a managed array of System.Int16.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetShortArrayElement(System.IntPtr,System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      <summary>Returns the number of elements in the array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetBooleanArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetBooleanArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetBooleanField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetByteArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetByteArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetByteField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetCharArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetCharArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetCharField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetDoubleArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetDoubleArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetDoubleField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFieldID(System.IntPtr,System.String,System.String)">
      <summary>Returns the field ID for an instance (nonstatic) field of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetFloatArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFloatField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetIntArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetIntArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetIntField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetLongArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetLongArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetLongField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetMethodID(System.IntPtr,System.String,System.String)">
      <summary>Returns the method ID for an instance (nonstatic) method of a class or interface.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectArrayElement(System.IntPtr,System.Int32)">
      <summary>Returns an element of an <c>Object</c> array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectClass(System.IntPtr)">
      <summary>Returns the class of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetShortArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetShortArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetShortField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticBooleanField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticByteField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticCharField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticDoubleField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticFieldID(System.IntPtr,System.String,System.String)">
      <summary>Returns the field ID for a static field of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticFloatField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticIntField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticLongField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticMethodID(System.IntPtr,System.String,System.String)">
      <summary>Returns the method ID for a static method of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticObjectField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticShortField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticStringField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of a static field of an object.</para>
        <para>This is a convenience function that calls GetStaticObjectField() with the same parameters, but creates a managed string from the result.See Also: <see cref="M:UnityEngine.AndroidJNI.GetStaticObjectField(System.IntPtr,System.IntPtr)" /> See Also: <c>Java Native Interface Specification (Oracle)</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of an instance (nonstatic) field of an object.</para>
        <para>This is a convenience function that calls GetObjectField() with the same parameters, but creates a managed string from the result.See Also: <see cref="M:UnityEngine.AndroidJNI.GetObjectField(System.IntPtr,System.IntPtr)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringUTFChars(System.IntPtr)">
      <summary>
        <para>Returns a managed string object representing the string in modified UTF-8 encoding.</para>
        <para>This method is a modification of the original <c>GetStringUTFChars</c>, which returns a pointer to an array of bytes.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringUTFLength(System.IntPtr)">
      <summary>Returns the length in bytes of the modified UTF-8 representation of a string.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetSuperclass(System.IntPtr)">
      <summary>
        <para>If <c>clazz</c> represents any class other than the class <c>Object</c>, then this function returns the object that represents the superclass of the class specified by <c>clazz</c>.</para>
        <para>If <c>clazz</c> specifies the class <c>Object</c>, or <c>clazz</c> represents an interface, this function returns <c>NULL</c>.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetVersion">
      <summary>Returns the version of the native method interface.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsAssignableFrom(System.IntPtr,System.IntPtr)">
      <summary>Determines whether an object of <c>clazz1</c> can be safely cast to <c>clazz2</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsInstanceOf(System.IntPtr,System.IntPtr)">
      <summary>Tests whether an object is an instance of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsSameObject(System.IntPtr,System.IntPtr)">
      <summary>Tests whether two references refer to the same Java object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewBooleanArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewByteArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewCharArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewDoubleArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewFloatArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewGlobalRef(System.IntPtr)">
      <summary>Creates a new global reference to the object referred to by the <c>obj</c> argument.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewIntArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewLocalRef(System.IntPtr)">
      <summary>Creates a new local reference that refers to the same object as <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewLongArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewObject(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Constructs a new Java object. The method ID indicates which constructor method to invoke. This ID must be obtained by calling GetMethodID() with &lt;init&gt; as the method name and void (V) as the return type.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewObjectArray(System.Int32,System.IntPtr,System.IntPtr)">
      <summary>Constructs a new array holding objects in class <c>clazz</c>. All elements are initially set to <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewShortArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewStringUTF(System.String)">
      <summary>Constructs a new <c>java.lang.String</c> object from an array of characters in modified UTF-8 encoding.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.PopLocalFrame(System.IntPtr)">
      <summary>Pops off the current local reference frame, frees all the local references, and returns a local reference in the previous local reference frame for the given <c>result</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.PushLocalFrame(System.Int32)">
      <summary>Creates a new local reference frame, in which at least a given number of local references can be created.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetBooleanArrayElement(System.IntPtr,System.Int32,System.Byte)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetBooleanArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetBooleanField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetByteArrayElement(System.IntPtr,System.Int32,System.SByte)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetByteArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetByteField(System.IntPtr,System.IntPtr,System.Byte)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetCharArrayElement(System.IntPtr,System.Int32,System.Char)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetCharArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetCharField(System.IntPtr,System.IntPtr,System.Char)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetDoubleArrayElement(System.IntPtr,System.Int32,System.Double)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetDoubleArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetDoubleField(System.IntPtr,System.IntPtr,System.Double)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetFloatArrayElement(System.IntPtr,System.Int32,System.Single)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetFloatArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetFloatField(System.IntPtr,System.IntPtr,System.Single)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetIntArrayElement(System.IntPtr,System.Int32,System.Int32)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetIntArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetIntField(System.IntPtr,System.IntPtr,System.Int32)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetLongArrayElement(System.IntPtr,System.Int32,System.Int64)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetLongArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetLongField(System.IntPtr,System.IntPtr,System.Int64)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetObjectArrayElement(System.IntPtr,System.Int32,System.IntPtr)">
      <summary>Sets an element of an <c>Object</c> array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetShortArrayElement(System.IntPtr,System.Int32,System.Int16)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetShortArrayRegion(), called with region size set to 1.See Also: <see href="jniTOC" cref="Java Native Interface Specification (Oracle)" /></para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetShortField(System.IntPtr,System.IntPtr,System.Int16)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticBooleanField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticByteField(System.IntPtr,System.IntPtr,System.Byte)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticCharField(System.IntPtr,System.IntPtr,System.Char)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticDoubleField(System.IntPtr,System.IntPtr,System.Double)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticFloatField(System.IntPtr,System.IntPtr,System.Single)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticIntField(System.IntPtr,System.IntPtr,System.Int32)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticLongField(System.IntPtr,System.IntPtr,System.Int64)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticShortField(System.IntPtr,System.IntPtr,System.Int16)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticStringField(System.IntPtr,System.IntPtr,System.String)">
      <summary>
        <para>This function ets the value of a static field of an object.</para>
        <para>This is a convenience function that calls SetStaticObjectField() with the same parameters, but performs the necessary marshalling of the string value.See Also: <see cref="M:UnityEngine.AndroidJNI.SetStaticObjectField(System.IntPtr,System.IntPtr,System.IntPtr)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStringField(System.IntPtr,System.IntPtr,System.String)">
      <summary>
        <para>This function sets the value of an instance (nonstatic) field of an object.</para>
        <para>This is a convenience function that calls SetObjectField() with the same parameters, but performs the necessary marshalling of the string value.See Also: <see cref="M:UnityEngine.AndroidJNI.SetObjectField(System.IntPtr,System.IntPtr,System.IntPtr)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.Throw(System.IntPtr)">
      <summary>Causes a <c>java.lang.Throwable</c> object to be thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ThrowNew(System.IntPtr,System.String)">
      <summary>Constructs an exception object from the specified class with the <c>message</c> specified by message and causes that exception to be thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToBooleanArray(System.Boolean[])">
      <summary>Convert a managed array of System.Boolean to a Java array of <c>boolean</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewBooleanArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetBooleanArrayElement(System.IntPtr,System.Int32,System.Byte)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToByteArray(System.Byte[])">
      <summary>Convert a managed array of System.Byte to a Java array of <c>byte</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewByteArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetByteArrayElement(System.IntPtr,System.Int32,System.SByte)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToCharArray(System.Char[])">
      <summary>Convert a managed array of System.Char to a Java array of <c>char</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewCharArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetCharArrayElement(System.IntPtr,System.Int32,System.Char)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToDoubleArray(System.Double[])">
      <summary>Convert a managed array of System.Double to a Java array of <c>double</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewDoubleArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetDoubleArrayElement(System.IntPtr,System.Int32,System.Double)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToFloatArray(System.Single[])">
      <summary>Convert a managed array of System.Single to a Java array of <c>float</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewFloatArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetFloatArrayElement(System.IntPtr,System.Int32,System.Single)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToIntArray(System.Int32[])">
      <summary>Convert a managed array of System.Int32 to a Java array of <c>int</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewIntArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetIntArrayElement(System.IntPtr,System.Int32,System.Int32)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToLongArray(System.Int64[])">
      <summary>Convert a managed array of System.Int64 to a Java array of <c>long</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewLongArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetLongArrayElement(System.IntPtr,System.Int32,System.Int64)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToObjectArray(System.IntPtr[])">
      <summary>Convert a managed array of System.IntPtr, representing Java objects, to a Java array of <c>java.lang.Object</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewObjectArray(System.Int32,System.IntPtr,System.IntPtr)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetObjectArrayElement(System.IntPtr,System.Int32,System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToReflectedField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>Converts a field ID derived from cls to a <c>java.lang.reflect.Field</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToReflectedMethod(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>Converts a method ID derived from clazz to a <c>java.lang.reflect.Method</c> or <c>java.lang.reflect.Constructor</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToShortArray(System.Int16[])">
      <summary>Convert a managed array of System.Int16 to a Java array of <c>short</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewShortArray(System.Int32)" />
      <seealso cref="M:UnityEngine.AndroidJNI.SetShortArrayElement(System.IntPtr,System.Int32,System.Int16)" />
    </member>
    <member name="P:UnityEngine.AndroidJNIHelper.debug">
      <summary>Set <c>debug</c> to true to log calls through the AndroidJNIHelper.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.ConvertFromJNIArray(System.IntPtr)">
      <summary>Creates a managed array from a Java array.</summary>
      <param name="array">Java array object to be converted into a managed array.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.ConvertToJNIArray(System.Array)" />
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.ConvertToJNIArray(System.Array)">
      <summary>Creates a Java array from a managed array.</summary>
      <param name="array">Managed array to be converted into a Java array object.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.ConvertFromJNIArray(System.IntPtr)" />
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJavaProxy(UnityEngine.AndroidJavaProxy)">
      <summary>Creates a java proxy object which connects to the supplied proxy implementation.</summary>
      <param name="proxy">An implementatinon of a java interface in c#.</param>
      <seealso cref="T:UnityEngine.AndroidJavaProxy" />
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJavaRunnable(UnityEngine.AndroidJavaRunnable)">
      <summary>Creates a UnityJavaRunnable object (implements java.lang.Runnable).</summary>
      <seealso cref="T:UnityEngine.AndroidJavaRunnable" />
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJNIArgArray(System.Object[])">
      <summary>Creates the parameter array to be used as argument list when invoking Java code through CallMethod() in AndroidJNI.</summary>
      <param name="args">An array of objects that should be converted to Call parameters.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.DeleteJNIArgArray(System.Object[],UnityEngine.jvalue[])">
      <summary>Deletes any local jni references previously allocated by CreateJNIArgArray().</summary>
      <param name="args">The array of arguments used as a parameter to CreateJNIArgArray().</param>
      <param name="jniArgs">The array returned by CreateJNIArgArray().</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      <summary>
        <para>Scans a particular Java class for a constructor method matching a signature.</para>
        <para>The signature comparison is done to allow for sub-/base-classes of the class types. If no signature is provided the first constuctor found will be returned.See Also: <see cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)" />.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="signature">Constructor method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.Object[])">
      <summary>
        <para>Get a JNI method ID for a constructor based on calling arguments.</para>
        <para>Scans a particular Java class for a constructor method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="args">Array with parameters to be passed to the constructor when invoked.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)">
      <summary>
        <para>Scans a particular Java class for a field matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first field with the correct name will be returned.See Also: <see cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)" />.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="signature">Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <param name="isStatic">Set to <c>true</c> for static fields; <c>false</c> for instance (nonstatic) fields.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String)">
      <summary>
        <para>Scans a particular Java class for a field matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first field with the correct name will be returned.See Also: <see cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)" />.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="signature">Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.Boolean)">
      <summary>
        <para>Get a JNI field ID based on type detection. Generic parameter represents the field type.</para>
        <para>Scans a particular Java class for a field matching a signature of the field type. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="isStatic">Set to <c>true</c> for static fields; <c>false</c> for instance (nonstatic) fields.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)">
      <summary>
        <para>Scans a particular Java class for a method matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first method with the correct name will be returned.See Also: <see cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)" />.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="signature">Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String)">
      <summary>
        <para>Scans a particular Java class for a method matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first method with the correct name will be returned.See Also: <see cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)" />, <see cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)" />.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="signature">Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.Object[],System.Boolean)">
      <summary>
        <para>Get a JNI method ID based on calling arguments.</para>
        <para>Generic parameter represents the method return type, and the regular method assumes 'void' return type. Scans a particular Java class for a method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="args">Array with parameters to be passed to the method when invoked.</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.Object[],System.Boolean)">
      <summary>
        <para>Get a JNI method ID based on calling arguments.</para>
        <para>Generic parameter represents the method return type, and the regular method assumes 'void' return type. Scans a particular Java class for a method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="args">Array with parameters to be passed to the method when invoked.</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      <summary>Creates the JNI signature string for particular object type.</summary>
      <param name="obj">Object for which a signature is to be produced.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object[])">
      <summary>Creates the JNI signature string for an object parameter list.</summary>
      <param name="args">Array of object for which a signature is to be produced.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object[])">
      <summary>
        <para>Creates the JNI signature string for an object parameter list.</para>
        <para>The generic parameter represents the method return type.</para>
      </summary>
      <param name="args">Array of object for which a signature is to be produced.</param>
    </member>
    <member name="P:UnityEngine.Animation.animatePhysics">
      <summary>
        <para>When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies.</para>
        <para>An animated platform can apply velocity and friction to rigid bodies sitting on top of it. In order to use this, animatePhysics must be enabled and animated object must be a kinematic rigid body.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animation.clip">
      <summary>The default animation.</summary>
    </member>
    <member name="P:UnityEngine.Animation.cullingType">
      <summary>Controls culling of this Animation component.</summary>
    </member>
    <member name="P:UnityEngine.Animation.isPlaying">
      <summary>Are we playing any animations?</summary>
    </member>
    <member name="P:UnityEngine.Animation.localBounds">
      <summary>
        <para>AABB of this Animation animation component in local space.</para>
        <para>By default it is computed based on animation states (i.e. attached animation clips), unless user overrides it by setting value to localBounds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animation.playAutomatically">
      <summary>Should the default animation clip (the <see cref="P:UnityEngine.Animation.clip" /> property) automatically start playing on startup?</summary>
    </member>
    <member name="P:UnityEngine.Animation.wrapMode">
      <summary>How should time beyond the playback range of the clip be treated?</summary>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String)">
      <summary>Adds a <c>clip</c> to the animation with name <c>newName</c>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Adds <c>clip</c> to the only play between <c>firstFrame</c> and <c>lastFrame</c>. The new clip will also be added to the animation with name <c>newName</c>.</para>
        <para>If a clip with that name already exists it will be replaced with the new clip.</para>
      </summary>
      <param name="addLoopFrame">Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.</param>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String,System.Int32,System.Int32)">
      <summary>
        <para>Adds <c>clip</c> to the only play between <c>firstFrame</c> and <c>lastFrame</c>. The new clip will also be added to the animation with name <c>newName</c>.</para>
        <para>If a clip with that name already exists it will be replaced with the new clip.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String,System.Single,System.Single)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String,System.Single)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String,System.Single,UnityEngine.PlayMode)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in.If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String,System.Single)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in.If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in.If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single,UnityEngine.QueueMode,UnityEngine.PlayMode)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other.The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single,UnityEngine.QueueMode)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other.The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other.The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other.The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.GetClipCount">
      <summary>Get the number of clips currently assigned to this animation.</summary>
    </member>
    <member name="M:UnityEngine.Animation.IsPlaying(System.String)">
      <summary>Is the animation named <c>name</c> playing?</summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false.The optional <c>playMode</c> lets you choose how this animation will affect others already playing.If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning.When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop.Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false.The optional <c>playMode</c> lets you choose how this animation will affect others already playing.If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning.When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop.Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(System.String,UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false.The optional <c>playMode</c> lets you choose how this animation will affect others already playing.If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning.When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop.Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(System.String)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false.The optional <c>playMode</c> lets you choose how this animation will affect others already playing.If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning.When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop.Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String,UnityEngine.QueueMode,UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other.The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String,UnityEngine.QueueMode)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other.The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other.The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation.The following <see cref="T:UnityEngine.QueueMode" /> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state.After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.RemoveClip(UnityEngine.AnimationClip)">
      <summary>
        <para>Remove clip from the animation list.</para>
        <para>This willl remove the clip and any animation states based on it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.RemoveClip(System.String)">
      <summary>
        <para>Remove clip from the animation list.</para>
        <para>This willl remove the animation state that match the name.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Rewind(System.String)">
      <summary>Rewinds the animation named <c>name</c>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Rewind">
      <summary>Rewinds all animations.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Sample">
      <summary>
        <para>Samples animations at the current state.</para>
        <para>This is useful when you explicitly want to set up some animation state, and sample it once.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Stop">
      <summary>
        <para>Stops all playing animations that were started with this Animation.</para>
        <para>Stopping an animation also Rewinds it to the Start.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Stop(System.String)">
      <summary>
        <para>Stops an animation named <c>name</c>.</para>
        <para>Stopping an animation also Rewinds it to the Start.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.events">
      <summary>
        <para>Animation Events for this animation clip.</para>
        <para>Note that events modified will only persist until play mode is exited of player is quit. If you want to add an event to a clip persistently, use AnimationUtility.SetAnimationEvents from the Unity editor.See Also: <see cref="T:UnityEditor.AnimationUtility" /> classes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.frameRate">
      <summary>
        <para>Frame rate at which keyframes are sampled. (Read Only)</para>
        <para>This is the frame rate that was used in the animation program you used to create the animation or model.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.humanMotion">
      <summary>Returns true if the animation contains curve that drives a humanoid rig.</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.legacy">
      <summary>Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator ).</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.length">
      <summary>Animation length in seconds. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.localBounds">
      <summary>
        <para>AABB of this Animation Clip in local space of Animation component that it is attached too.</para>
        <para>It is precomputed on import for imported models/animations based on the meshes that this animation clip affects. This bounding box is specific to the mesh(es) that this clip is attached to during import, i.e. this means that it is calculated based on the file that is part of and on the "Model" file if you're using Model@Animation notation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.wrapMode">
      <summary>Sets the default wrap mode used in the animation state.</summary>
    </member>
    <member name="M:UnityEngine.AnimationClip.#ctor">
      <summary>Creates a new animation clip.</summary>
    </member>
    <member name="M:UnityEngine.AnimationClip.AddEvent(UnityEngine.AnimationEvent)">
      <summary>
        <para>Adds an animation event to the clip.</para>
        <para>Note that events added with AddEvent will only persist until play mode is exited of player is quit. If you want to add an event to a clip persistently, use AnimationUtility.SetAnimationEvents from the Unity editor.See Also: <see cref="T:UnityEngine.AnimationEvent" />, <see cref="T:UnityEditor.AnimationUtility" /> classes.</para>
      </summary>
      <param name="evt">AnimationEvent to add.</param>
    </member>
    <member name="M:UnityEngine.AnimationClip.ClearCurves">
      <summary>Clears all curves from the clip.</summary>
      <seealso cref="M:UnityEngine.AnimationClip.SetCurve(System.String,System.Type,System.String,UnityEngine.AnimationCurve)" />
      <seealso cref="T:UnityEngine.AnimationCurve" />
    </member>
    <member name="M:UnityEngine.AnimationClip.EnsureQuaternionContinuity">
      <summary>
        <para>In order to insure better interpolation of quaternions, call this function after you are finished setting animation curves.</para>
        <para>The functions realigns quaternion keys to ensure shortest interpolation path.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationClip.SampleAnimation(UnityEngine.GameObject,System.Single)">
      <summary>
        <para>Samples an animation at a given time for any animated properties.</para>
        <para>It is recommended to use the <see cref="T:UnityEngine.Animation" /> interface instead for performance reasons. This will sample <c>animation</c> at the given <c>time</c>. Any component properties that are animated in the clip will be replaced with the sampled value. Most of the time you want to use <see cref="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)" /> instead. SampleAnimation is useful when you need to jump between frames in an unordered way or based on some special input.See Also: <see cref="T:UnityEngine.Animation" />.</para>
      </summary>
      <param name="go">The animated game object.</param>
      <param name="time">The time to sample an animation.</param>
    </member>
    <member name="M:UnityEngine.AnimationClip.SetCurve(System.String,System.Type,System.String,UnityEngine.AnimationCurve)">
      <summary>
        <para>Assigns the curve to animate a specific property.</para>
        <para>If <c>curve</c> is null the curve will be removed. If a curve already exists for that property, it will be replaced.Common names are: <c>"localPosition.x"</c>, <c>"localPosition.y"</c>, <c>"localPosition.z"</c>, <c>"localRotation.x"</c>, <c>"localRotation.y"</c>, <c>"localRotation.z"</c>, <c>"localRotation.w"</c><c>"localScale.x"</c>, <c>"localScale.y"</c>, <c>"localScale.z"</c>.</para>
        <para>
          <see cref="T:UnityEngine.Material" /> properties can be animated using the property name exported in the shader. Common property names are: <c>"_MainTex"</c>, <c>"_BumpMap"</c>, <c>"_Color"</c>, <c>"_SpecColor"</c>, <c>"_Emission"</c>. How to animate different material property types:Float properties:<c>"PropertyName"</c>Vector4 properties:<c>"PropertyName.x"</c>, <c>"PropertyName.y"</c>, <c>"PropertyName.z"</c>, <c>"PropertyName.w"</c>Color properties:<c>"PropertyName.r</c>", <c>"PropertyName.g"</c>, <c>"PropertyName.b"</c>, <c>"PropertyName.a"</c>UV Rotation properties:<c>"PropertyName.rotation"</c>UV Offset and scale:<c>"PropertyName.offset.x"</c>, <c>"PropertyName.offset.y"</c>, <c>"PropertyName.scale.x"</c>, <c>"PropertyName.scale.y"</c>To index into multiple materials on the same renderer you can prefix the attribute like this: <c>"[1]._MainTex.offset.y"</c>See Also: <see cref="M:UnityEngine.AnimationClip.ClearCurves" /> function, <see cref="T:UnityEngine.AnimationCurve" /> class.</para>
        <para>Property names can be looked up by setting Asset Serialization to Force Text mode in the Editor settings. The text files that are then written by the editor will include the names of the properties. For example, the yaml file written for a Scene object will include the Camera settings. Looking at this yaml file will show:<c>m_BackGroundColor: {r: .192156866, g: .301960796, b: .474509805, a: .0196078438}</c><c>m_NormalizedViewPortRect:</c><c> serializedVersion: 2</c><c> x: 0</c><c> y: 0</c><c> width: 1</c><c> height: 1</c><c>near clip plane: .300000012</c><c>far clip plane: 1000</c><c>field of view: 60</c><c>orthographic: 0</c><c>orthographic size: 5</c><c>m_Depth: -1</c> This shows that the name for the FOV parameter is "field of view". If you wanted to create an animation clip to animate the camera field of view, you would pass "field of view" as the propertyName.</para>
      </summary>
      <param name="relativePath">Path to the game object this curve applies to. <c>relativePath</c> is formatted similar to a pathname, e.g. "root<c>relativePath</c>leftArm". If <c>relativePath</c> is empty it refers to the game object the animation clip is attached to.</param>
      <param name="type">The class type of the component that is animated.</param>
      <param name="propertyName">The name or path to the property being animated.</param>
      <param name="curve">The animation curve.</param>
    </member>
    <member name="F:UnityEngine.AnimationClipPair.originalClip">
      <summary>The original clip from the controller.</summary>
    </member>
    <member name="F:UnityEngine.AnimationClipPair.overrideClip">
      <summary>
        <para>The override animation clip.</para>
        <para>Can be null if no override is define.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.keys">
      <summary>
        <para>All keys defined in the animation curve.</para>
        <para>This lets you clear, add or remove any keys from the array. If keys are not sorted by time, they will be automatically sorted on assignment.Note that the array is "by value", i.e. getting keys returns a copy of all keys and setting keys copies them into the curve.See Also: <see cref="T:UnityEngine.Keyframe" /> struct, <see cref="M:UnityEngine.AnimationCurve.AddKey(System.Single,System.Single)" />, <see cref="M:UnityEngine.AnimationCurve.RemoveKey(System.Int32)" /> functions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.length">
      <summary>The number of keys in the curve. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.postWrapMode">
      <summary>The behaviour of the animation after the last keyframe.</summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.preWrapMode">
      <summary>The behaviour of the animation before the first keyframe.</summary>
    </member>
    <member name="M:UnityEngine.AnimationCurve.#ctor(UnityEngine.Keyframe[])">
      <summary>
        <para>Creates an animation curve from arbitrary number of keyframes.</para>
        <para>This creates a curve from variable number of <see cref="T:UnityEngine.Keyframe" /> parameters. If you want to create curve from an array of keyframes, create an empty curve and assign <see cref="P:UnityEngine.AnimationCurve.keys" /> property.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationCurve.#ctor">
      <summary>Creates an empty animation curve.</summary>
    </member>
    <member name="M:UnityEngine.AnimationCurve.AddKey(System.Single,System.Single)">
      <summary>
        <para>Add a new key to the curve.</para>
        <para>Smooth tangents are automatically computed for the key. Returns the index of the added key. If no key could be added because there is already another keyframe at the same time -1 will be returned.See Also: <see cref="P:UnityEngine.AnimationCurve.keys" /> variable.</para>
      </summary>
      <param name="time">The time at which to add the key (horizontal axis in the curve graph).</param>
      <param name="value">The value for the key (vertical axis in the curve graph).</param>
      <returns>The index of the added key, or -1 if the key could not be added.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.AddKey(UnityEngine.Keyframe)">
      <summary>
        <para>Add a new key to the curve.</para>
        <para>Returns the index of the added key. If no key could be added because there is already another keyframe at the same time -1 will be returned.See Also: <see cref="P:UnityEngine.AnimationCurve.keys" /> variable, <see cref="T:UnityEngine.Keyframe" /> struct.</para>
      </summary>
      <param name="key">The key to add to the curve.</param>
      <returns>The index of the added key, or -1 if the key could not be added.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.Evaluate(System.Single)">
      <summary>Evaluate the curve at <c>time</c>.</summary>
      <param name="time">The time within the curve you want to evaluate (the horizontal axis in the curve graph).</param>
      <returns>The value of the curve, at the point in time specified.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.MoveKey(System.Int32,UnityEngine.Keyframe)">
      <summary>
        <para>Removes the keyframe at <c>index</c> and inserts key.</para>
        <para>If a keyframe already exists at <c>key.time</c> the time of the old keyframe's position /key[index].time/ will be used instead. This is the desired behaviour for dragging keyframes in a curve editor. Returns the index of the keyframe after moving it.</para>
      </summary>
      <param name="index">The index of the key to move.</param>
      <param name="key">The key (with its new time) to insert.</param>
      <returns>The index of the keyframe after moving it.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.RemoveKey(System.Int32)">
      <summary>Removes a key.</summary>
      <param name="index">The index of the key to remove.</param>
    </member>
    <member name="M:UnityEngine.AnimationCurve.SmoothTangents(System.Int32,System.Single)">
      <summary>
        <para>Smooth the in and out tangents of the keyframe at <c>index</c>.</para>
        <para>A weight of 0 evens out tangents.</para>
      </summary>
      <param name="index">The index of the keyframe to be smoothed.</param>
      <param name="weight">The smoothing weight to apply to the keyframe's tangents.</param>
    </member>
    <member name="M:UnityEngine.AnimationCurve.EaseInOut(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates an ease-in and out curve starting at <c>timeStart</c>, <c>valueStart</c> and ending at <c>timeEnd</c>, <c>valueEnd</c>.</summary>
      <param name="timeStart">The start time for the ease curve.</param>
      <param name="valueStart">The start value for the ease curve.</param>
      <param name="timeEnd">The end time for the ease curve.</param>
      <param name="valueEnd">The end value for the ease curve.</param>
      <returns>The ease-in and out curve generated from the specified values.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.Linear(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>A straight Line starting at <c>timeStart</c>, <c>valueStart</c> and ending at <c>timeEnd</c>, <c>valueEnd</c>.</para>
        <para>This is something of an oxymoron as the generated "curve" is actually a straight line, however it is still called a "curve" and represented by an AnimationCurve object.</para>
      </summary>
      <param name="timeStart">The start time for the linear curve.</param>
      <param name="valueStart">The start value for the linear curve.</param>
      <param name="timeEnd">The end time for the linear curve.</param>
      <param name="valueEnd">The end value for the linear curve.</param>
      <returns>The (straight) curve created from the values specified.</returns>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animationState">
      <summary>
        <para>The animation state that fired this event (Read Only).</para>
        <para>Returns null when the method is called outside of an animation event callback. Note: This member will only be set when called from an Animation component(legacy).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animatorClipInfo">
      <summary>The animator clip info related to this event (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animatorStateInfo">
      <summary>The animator state info related to this event (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.floatParameter">
      <summary>Float parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.functionName">
      <summary>
        <para>The name of the function that will be called.</para>
        <para>This is the same as calling gameObject.SendMessage(animationEvent.functionName, animationEvent).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.intParameter">
      <summary>Int parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.isFiredByAnimator">
      <summary>Returns true if this Animation event has been fired by an Animator component.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.isFiredByLegacy">
      <summary>Returns true if this Animation event has been fired by an Animation component.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.messageOptions">
      <summary>
        <para>Function call options.</para>
        <para>If options are set to SendMessageOptions.RequireReceiver (default), an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.objectReferenceParameter">
      <summary>Object reference parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.stringParameter">
      <summary>String parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.time">
      <summary>The time at which the event will be fired off.</summary>
    </member>
    <member name="M:UnityEngine.AnimationEvent.#ctor">
      <summary>Creates a new animation event.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.blendMode">
      <summary>Which blend mode should be used?</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.clip">
      <summary>The clip that is being played by this animation state.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.enabled">
      <summary>
        <para>Enables / disables the animation.</para>
        <para>For the animation to take any effect the weight also needs to be set to a value higher than zero. If the animation is disabled, time will be paused until the animation is enabled again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.length">
      <summary>The length of the animation clip in seconds.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.name">
      <summary>The name of the animation.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.normalizedSpeed">
      <summary>
        <para>The normalized playback speed.</para>
        <para>This is most commonly used to synchronize playback speed when blending between two animations. In most cases it is easier and better to use Animation Layer syncing instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.normalizedTime">
      <summary>
        <para>The normalized time of the animation.</para>
        <para>A value of 1 is the end of the animation. A value of 0.5 is the middle of the animation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.speed">
      <summary>
        <para>The playback speed of the animation. 1 is normal playback speed.</para>
        <para>A negative playback speed will play the animation backwards.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.time">
      <summary>
        <para>The current time of the animation.</para>
        <para>If the time is larger than length it will be wrapped according to wrapMode. The value can be larger than the animations length. In this case playback mode will remap the time before sampling. This value usually goes from 0 to infinity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.weight">
      <summary>
        <para>The weight of animation.</para>
        <para>This calculates the blend weights for one curve.Weights are distributed so that the top layer gets everything. If it doesn't use the full weight then the next layer gets to distribute the remaining weights and so on. Once all weights are used by the top layers, no weights will be available for lower layers anymore Unity uses fair weighting, which means if a lower layer wants 80% and 50% have already been used up, the layer will NOT use up all weights. instead it will take up 80% of the 50%.Example: a upper body which is affected by wave, walk and idle a lower body which is affected by only walk and idle.</para>
        <para>- Blend weights can change per animated value because of mixing. Even without mixing, sometimes a curve is just not defined. Still you want the blend weights to add up to 1. Most of the time weights are similar between curves.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.wrapMode">
      <summary>
        <para>Wrapping mode of the animation.</para>
        <para>By default wrapMode is initialized to the value set in the Animation component's wrap mode.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.</para>
        <para>For example you might have a handwaving animation. You might want to play the hand waving animation on a idle character or on a walking character. Either you have to create 2 hand waving animations one for idle, one for walking. By using mixing the hand waving animation will have full control of the shoulder. But the lower body will not be affected by it, and continue playing the idle or walk animation. Thus you only need one hand waving animation.If <c>recursive</c> is true all children of the <c>mix</c> transform will also be animated. If you don't call AddMixingTransform, all animation curves will be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform)">
      <summary>
        <para>Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.</para>
        <para>For example you might have a handwaving animation. You might want to play the hand waving animation on a idle character or on a walking character. Either you have to create 2 hand waving animations one for idle, one for walking. By using mixing the hand waving animation will have full control of the shoulder. But the lower body will not be affected by it, and continue playing the idle or walk animation. Thus you only need one hand waving animation.If <c>recursive</c> is true all children of the <c>mix</c> transform will also be animated. If you don't call AddMixingTransform, all animation curves will be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationState.RemoveMixingTransform(UnityEngine.Transform)">
      <summary>
        <para>Removes a transform which should be animated.</para>
        <para>You can only pass transforms that have been added through <see cref="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform,System.Boolean)" /> function. If transform has been added as <c>recursive</c>, then it will be removed as <c>recursive</c>. Once you remove all mixing transforms added to animation state all curves become animated again.</para>
      </summary>
      <seealso cref="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform,System.Boolean)" />
    </member>
    <member name="P:UnityEngine.Animator.angularVelocity">
      <summary>Gets the avatar angular velocity for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.applyRootMotion">
      <summary>
        <para>Should root motion be applied?</para>
        <para>Root motion is the effect where an object's entire mesh moves away from its starting point but that motion is created by the animation itself rather than by changing the Transform position. Note that <c>applyRootMotion</c> has no effect when the script implements a <see href="MonoBehaviour.OnAnimatorMove" cref="MonoBehaviour.OnAnimatorMove" /> function.Changing the value of applyRootMotion at runtime will re-initialize the animator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.avatar">
      <summary>
        <para>Gets/Sets the current Avatar.</para>
        <para>Changing the avatar at runtime is not fully supported. Use it at your own risk.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.bodyPosition">
      <summary>
        <para>The position of the body center of mass.</para>
        <para>The position is in worldspace. Value can only be set in OnAnimatorMove().</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.bodyRotation">
      <summary>
        <para>The rotation of the body center of mass.</para>
        <para>The rotation is in worldspace. Value can only be set in OnAnimatorMove().</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.cullingMode">
      <summary>Controls culling of this Animator component.</summary>
    </member>
    <member name="P:UnityEngine.Animator.deltaPosition">
      <summary>Gets the avatar delta position for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.deltaRotation">
      <summary>Gets the avatar delta rotation for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.feetPivotActive">
      <summary>Blends pivot point between body center of mass and feet pivot. At 0%, the blending point is body center of mass. At 100%, the blending point is feet pivot.</summary>
    </member>
    <member name="P:UnityEngine.Animator.gravityWeight">
      <summary>The current gravity weight based on current animations that are played.</summary>
    </member>
    <member name="P:UnityEngine.Animator.hasRootMotion">
      <summary>Returns true if the current rig has root motion.</summary>
    </member>
    <member name="P:UnityEngine.Animator.hasTransformHierarchy">
      <summary>
        <para>Returns true if the object has a transform hierarchy.</para>
        <para>Based on the Optmize Game Object toggle of Model Importer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.humanScale">
      <summary>
        <para>Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).</para>
        <para>The scale is relative to Unity's Default Avatar.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.isHuman">
      <summary>Returns true if the current rig is <c>humanoid</c>, false if it is <c>generic</c>.</summary>
    </member>
    <member name="P:UnityEngine.Animator.isInitialized">
      <summary>
        <para>Returns whether the animator is initialized successfully.</para>
        <para>See <see cref="M:UnityEngine.Animator.Rebind" /> to manually initialize the animator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.isMatchingTarget">
      <summary>If automatic matching is active.</summary>
    </member>
    <member name="P:UnityEngine.Animator.isOptimizable">
      <summary>Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy.</summary>
    </member>
    <member name="P:UnityEngine.Animator.layerCount">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable-layerCount" cref="IAnimatorControllerPlayable.layerCount" />.</summary>
    </member>
    <member name="P:UnityEngine.Animator.layersAffectMassCenter">
      <summary>Additional layers affects the center of mass.</summary>
    </member>
    <member name="P:UnityEngine.Animator.leftFeetBottomHeight">
      <summary>Get left foot bottom height.</summary>
    </member>
    <member name="P:UnityEngine.Animator.linearVelocityBlending">
      <summary>When linearVelocityBlending is set to true, the root motion velocity and angular velocity will be blended linearly.</summary>
    </member>
    <member name="P:UnityEngine.Animator.parameterCount">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable-parameterCount" cref="IAnimatorControllerPlayable.parameterCount" />.</summary>
    </member>
    <member name="P:UnityEngine.Animator.parameters">
      <summary>Read only acces to the AnimatorControllerParameters used by the animator.</summary>
    </member>
    <member name="P:UnityEngine.Animator.pivotPosition">
      <summary>
        <para>Get the current position of the pivot.</para>
        <para>The pivot is the most stable point between the avatar's left and right foot.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.pivotWeight">
      <summary>
        <para>Gets the pivot weight.</para>
        <para>The pivot is the most stable point between the avatar's left and right foot For a value of 0, the left foot is the most stable point For a value of 1, the right foot is the most stable point.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.playbackTime">
      <summary>
        <para>Sets the playback position in the recording buffer.</para>
        <para>When in playback mode (see <see cref="M:UnityEngine.Animator.StartPlayback" />), this value is used for controlling the current playback position in the buffer (in seconds). The value can range between <see cref="P:UnityEngine.Animator.recorderStartTime" /> and <see cref="P:UnityEngine.Animator.recorderStopTime" /> See Also: <see cref="M:UnityEngine.Animator.StartPlayback" />, <see cref="M:UnityEngine.Animator.StopPlayback" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderMode">
      <summary>Gets the mode of the Animator recorder.</summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderStartTime">
      <summary>
        <para>Start time of the first frame of the buffer relative to the frame at which <see cref="M:UnityEngine.Animator.StartRecording(System.Int32)" /> was called.</para>
        <para>For example, if we started recording at frame 10, and the buffer is 5 frames long. If the buffer is not initialized (<see cref="M:UnityEngine.Animator.StartRecording(System.Int32)" /> is not called), the value of this property will be -1.See Also: <see cref="P:UnityEngine.Animator.recorderStopTime" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderStopTime">
      <summary>
        <para>End time of the recorded clip relative to when <see cref="M:UnityEngine.Animator.StartRecording(System.Int32)" /> was called.</para>
        <para>For example, if we started recording at second 10, and ended recording at second 15, then this will have a value of 5. If the buffer is not initialized (<see cref="M:UnityEngine.Animator.StartRecording(System.Int32)" /> is not called), the value of this property will be -1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.rightFeetBottomHeight">
      <summary>Get right foot bottom height.</summary>
    </member>
    <member name="P:UnityEngine.Animator.rootPosition">
      <summary>The root position, the position of the game object.</summary>
    </member>
    <member name="P:UnityEngine.Animator.rootRotation">
      <summary>The root rotation, the rotation of the game object.</summary>
    </member>
    <member name="P:UnityEngine.Animator.runtimeAnimatorController">
      <summary>
        <para>The runtime representation of AnimatorController that controls the Animator.</para>
        <para>Swapping <see cref="P:UnityEngine.Animator.runtimeAnimatorController" /> with an <see cref="T:UnityEngine.AnimatorOverrideController" /> based on the same <see cref="T:UnityEditor.Animations.AnimatorController" /> at runtime doesn't reset state machine's current state.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.speed">
      <summary>
        <para>The playback speed of the Animator. 1 is normal playback speed.</para>
        <para>Negative playback speed is only supported when recorder is enabled. See <see cref="P:UnityEngine.Animator.recorderMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.stabilizeFeet">
      <summary>Automatic stabilization of feet during transition and blending.</summary>
    </member>
    <member name="P:UnityEngine.Animator.targetPosition">
      <summary>
        <para>Returns the position of the target specified by SetTarget(AvatarTarget targetIndex, float targetNormalizedTime)).</para>
        <para>The position is only valid when a frame has being evaluated after the <see cref="M:UnityEngine.Animator.SetTarget(UnityEngine.AvatarTarget,System.Single)" /> call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.targetRotation">
      <summary>
        <para>Returns the rotation of the target specified by SetTarget(AvatarTarget targetIndex, float targetNormalizedTime)).</para>
        <para>The rotation is only valid when a frame has being evaluated after the <see cref="M:UnityEngine.Animator.SetTarget(UnityEngine.AvatarTarget,System.Single)" /> call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.updateMode">
      <summary>Specifies the update mode of the Animator.</summary>
    </member>
    <member name="P:UnityEngine.Animator.velocity">
      <summary>Gets the avatar velocity for the last evaluated frame.</summary>
    </member>
    <member name="M:UnityEngine.Animator.ApplyBuiltinRootMotion">
      <summary>
        <para>Apply the default Root Motion.</para>
        <para>Applies the default root motion. Use this in OnAnimatorMove or in <see href="StateMachineBehaviour.OnStateMove" cref="StateMachineBehaviour.OnStateMove" /> on frames where you don't want to handle the root motion manually.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFade" cref="IAnimatorControllerPlayable.CrossFade" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFade" cref="IAnimatorControllerPlayable.CrossFade" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.Int32,System.Single,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFade" cref="IAnimatorControllerPlayable.CrossFade" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.Int32,System.Single,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFade" cref="IAnimatorControllerPlayable.CrossFade" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.String,System.Single,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFadeInFixedTime" cref="IAnimatorControllerPlayable.CrossFadeInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.String,System.Single,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFadeInFixedTime" cref="IAnimatorControllerPlayable.CrossFadeInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFadeInFixedTime" cref="IAnimatorControllerPlayable.CrossFadeInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.CrossFadeInFixedTime" cref="IAnimatorControllerPlayable.CrossFadeInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetAnimatorTransitionInfo(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetAnimatorTransitionInfo" cref="IAnimatorControllerPlayable.GetAnimatorTransitionInfo" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBehaviour``1">
      <summary>Return the first StateMachineBehaviour that match type <c>T</c> or derived from <c>T</c>. Return null if none are found.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBehaviours``1">
      <summary>Returns all StateMachineBehaviour that match type <c>T</c> or are derived from <c>T</c>. Returns null if none are found.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBoneTransform(UnityEngine.HumanBodyBones)">
      <summary>Returns transform mapped to this human bone id.</summary>
      <param name="humanBoneId">The human bone that is queried, see enum HumanBodyBones for a list of possible values.</param>
    </member>
    <member name="M:UnityEngine.Animator.GetBool(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetBool" cref="IAnimatorControllerPlayable.GetBool" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBool(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetBool" cref="IAnimatorControllerPlayable.GetBool" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorClipInfo(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetCurrentAnimatorClipInfo" cref="IAnimatorControllerPlayable.GetCurrentAnimatorClipInfo" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorStateInfo(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetCurrentAnimatorStateInfo" cref="IAnimatorControllerPlayable.GetCurrentAnimatorStateInfo" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetFloat(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetFloat" cref="IAnimatorControllerPlayable.GetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetFloat(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetFloat" cref="IAnimatorControllerPlayable.GetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKHintPosition(UnityEngine.AvatarIKHint)">
      <summary>Gets the position of an IK hint.</summary>
      <param name="hint">The AvatarIKHint that is queried.</param>
      <returns>Return the current position of this IK hint in world space.</returns>
    </member>
    <member name="M:UnityEngine.Animator.GetIKHintPositionWeight(UnityEngine.AvatarIKHint)">
      <summary>Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint).</summary>
      <param name="hint">The AvatarIKHint that is queried.</param>
      <returns>Return translative weight.</returns>
    </member>
    <member name="M:UnityEngine.Animator.GetIKPosition(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the position of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function gets the current position of the specified goal in world space.See Also: <see cref="M:UnityEngine.Animator.GetIKPositionWeight(UnityEngine.AvatarIKGoal)" />, <see cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
      <returns>Return the current position of this IK goal in world space.</returns>
    </member>
    <member name="M:UnityEngine.Animator.GetIKPositionWeight(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).The point calculated by the IK is also influenced by a weight value in the range 0..1 that determines how far between the start and the goal to aim. This function returns the current weight value for the position of the goal.See Also: <see cref="M:UnityEngine.Animator.GetIKPosition(UnityEngine.AvatarIKGoal)" />, <see cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
    </member>
    <member name="M:UnityEngine.Animator.GetIKRotation(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the rotation of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function gets the current rotation of the specified goal in world space.See Also: <see cref="M:UnityEngine.Animator.GetIKRotationWeight(UnityEngine.AvatarIKGoal)" />, <see cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is is queried.</param>
    </member>
    <member name="M:UnityEngine.Animator.GetIKRotationWeight(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).The rotation calculated by the IK is also influenced by a weight value in the range 0..1 that determines how far between the start and the goal to aim. This function returns the current weight value for the rotation of the goal.See Also: <see cref="M:UnityEngine.Animator.GetIKRotation(UnityEngine.AvatarIKGoal)" />, <see cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
    </member>
    <member name="M:UnityEngine.Animator.GetInteger(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetInteger" cref="IAnimatorControllerPlayable.GetInteger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetInteger(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetInteger" cref="IAnimatorControllerPlayable.GetInteger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerIndex(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetLayerIndex" cref="IAnimatorControllerPlayable.GetLayerIndex" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerName(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetLayerName" cref="IAnimatorControllerPlayable.GetLayerName" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerWeight(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetLayerWeight" cref="IAnimatorControllerPlayable.GetLayerWeight" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorClipInfo(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetNextAnimatorClipInfo" cref="IAnimatorControllerPlayable.GetNextAnimatorClipInfo" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorStateInfo(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.GetNextAnimatorStateInfo" cref="IAnimatorControllerPlayable.GetNextAnimatorStateInfo" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetParameter(System.Int32)">
      <summary>See AnimatorController.GetParameter.</summary>
    </member>
    <member name="M:UnityEngine.Animator.HasState(System.Int32,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.HasState" cref="IAnimatorControllerPlayable.HasState" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.InterruptMatchTarget(System.Boolean)">
      <summary>
        <para>Interrupts the automatic target matching.</para>
        <para>CompleteMatch will make the gameobject match the target completely at the next frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.InterruptMatchTarget">
      <summary>
        <para>Interrupts the automatic target matching.</para>
        <para>CompleteMatch will make the gameobject match the target completely at the next frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.IsInTransition(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.IsInTransition" cref="IAnimatorControllerPlayable.IsInTransition" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.IsParameterControlledByCurve(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.IsParameterControlledByCurve" cref="IAnimatorControllerPlayable.IsParameterControlledByCurve" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.IsParameterControlledByCurve(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.IsParameterControlledByCurve" cref="IAnimatorControllerPlayable.IsParameterControlledByCurve" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.MatchTarget(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.AvatarTarget,UnityEngine.MatchTargetWeightMask,System.Single,System.Single)">
      <summary>
        <para>Automatically adjust the gameobject position and rotation so that the AvatarTarget reaches the matchPosition when the current state is at the specified progress.</para>
        <para>Target matching only works on the base layer (index 0). You can only queue one match target at a time and you must wait for the first one to finish, otherwise your target matching will be discarded. If you call a MatchTarget with a start time lower than the clip's current normalize time and the clip can loop, MatchTarget will adjust the time to match the next clip loop. ex: start time= 0.2 current normalize time = 0.3, start time will be 1.2.</para>
      </summary>
      <param name="matchPosition">The position we want the body part to reach.</param>
      <param name="matchRotation">The rotation in which we want the body part to be.</param>
      <param name="targetBodyPart">The body part that is involved in the match.</param>
      <param name="weightMask">Structure that contains weights for matching position and rotation.</param>
      <param name="startNormalizedTime">Start time within the animation clip (0 - beginning of clip, 1 - end of clip).</param>
      <param name="targetNormalizedTime">End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop.</param>
    </member>
    <member name="M:UnityEngine.Animator.MatchTarget(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.AvatarTarget,UnityEngine.MatchTargetWeightMask,System.Single)">
      <summary>
        <para>Automatically adjust the gameobject position and rotation so that the AvatarTarget reaches the matchPosition when the current state is at the specified progress.</para>
        <para>Target matching only works on the base layer (index 0). You can only queue one match target at a time and you must wait for the first one to finish, otherwise your target matching will be discarded. If you call a MatchTarget with a start time lower than the clip's current normalize time and the clip can loop, MatchTarget will adjust the time to match the next clip loop. ex: start time= 0.2 current normalize time = 0.3, start time will be 1.2.</para>
      </summary>
      <param name="matchPosition">The position we want the body part to reach.</param>
      <param name="matchRotation">The rotation in which we want the body part to be.</param>
      <param name="targetBodyPart">The body part that is involved in the match.</param>
      <param name="weightMask">Structure that contains weights for matching position and rotation.</param>
      <param name="startNormalizedTime">Start time within the animation clip (0 - beginning of clip, 1 - end of clip).</param>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.String,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.String,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.Int32,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.Int32,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.String,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.String,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.Int32,System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.Int32,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Rebind">
      <summary>
        <para>Rebind all the animated properties and mesh data with the Animator.</para>
        <para>This function can be used when you manually change your GameObject hierarchy by script, like combining meshes or swap a complete transform hierarchy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.ResetTrigger(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.ResetTrigger" cref="IAnimatorControllerPlayable.ResetTrigger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.ResetTrigger(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.ResetTrigger" cref="IAnimatorControllerPlayable.ResetTrigger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetBoneLocalRotation(UnityEngine.HumanBodyBones,UnityEngine.Quaternion)">
      <summary>
        <para>Sets local rotation of a human bone during a IK pass.</para>
        <para>Can be used to create rotation IK goals for any human bone. Ex: Control lower and upper body independantly by setting Hips and Spine local rotation during an IK pass.</para>
      </summary>
      <param name="humanBoneId">The human bone Id.</param>
      <param name="rotation">The local rotation.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetBool(System.String,System.Boolean)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetBool" cref="IAnimatorControllerPlayable.SetBool" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetBool(System.Int32,System.Boolean)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetBool" cref="IAnimatorControllerPlayable.SetBool" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.String,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetFloat" cref="IAnimatorControllerPlayable.SetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.String,System.Single,System.Single,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetFloat" cref="IAnimatorControllerPlayable.SetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetFloat" cref="IAnimatorControllerPlayable.SetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.Int32,System.Single,System.Single,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetFloat" cref="IAnimatorControllerPlayable.SetFloat" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetIKHintPosition(UnityEngine.AvatarIKHint,UnityEngine.Vector3)">
      <summary>Sets the position of an IK hint.</summary>
      <param name="hint">The AvatarIKHint that is set.</param>
      <param name="hintPosition">The position in world space.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetIKHintPositionWeight(UnityEngine.AvatarIKHint,System.Single)">
      <summary>Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint).</summary>
      <param name="hint">The AvatarIKHint that is set.</param>
      <param name="value">The translative weight.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      <summary>
        <para>Sets the position of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function sets the position of the ultimate goal in world space; the actual point in space where the body part ends up is also influenced by a weight parameter that specifies how far between the start and the goal the IK should aim (a value in the range 0..1).This function should always be called in MonoBehavior.OnAnimatorIK, if.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="goalPosition">The position in world space.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)" />
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)" />
    </member>
    <member name="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)">
      <summary>
        <para>Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function sets a weight value in the range 0..1 to determine how far between the start and goal positions the IK will aim. The position itself is set separately using <see cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="value">The translative weight.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)" />
      <seealso cref="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)" />
    </member>
    <member name="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      <summary>
        <para>Sets the rotation of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function sets the rotation of the ultimate goal in world space; the actual rotation where the body part ends up is also influenced by a weight parameter that specifies how far between the start and the goal the IK should aim (a value in the range 0..1).</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="goalRotation">The rotation in world space.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)" />
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)">
      <summary>
        <para>Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation).This function sets a weight value in the range 0..1 to determine how far between the start and goal rotations the IK will aim. The goal itself is set separately using <see cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)" />.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="value">The rotational weight.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)" />
      <seealso cref="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)" />
    </member>
    <member name="M:UnityEngine.Animator.SetInteger(System.String,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetInteger" cref="IAnimatorControllerPlayable.SetInteger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetInteger(System.Int32,System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetInteger" cref="IAnimatorControllerPlayable.SetInteger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetLayerWeight(System.Int32,System.Single)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetLayerWeight" cref="IAnimatorControllerPlayable.SetLayerWeight" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtPosition(UnityEngine.Vector3)">
      <summary>Sets the look at position.</summary>
      <param name="lookAtPosition">The position to lookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
      <param name="eyesWeight">(0-1) determines how much the eyes are involved in the LookAt.</param>
      <param name="clampWeight">(0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
      <param name="eyesWeight">(0-1) determines how much the eyes are involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetTarget(UnityEngine.AvatarTarget,System.Single)">
      <summary>
        <para>Sets an AvatarTarget and a targetNormalizedTime for the current state.</para>
        <para>Once the frame is evaluated, the position and the rotation can be queried using targetPosition and targetRotation.</para>
      </summary>
      <param name="targetIndex">The avatar body part that is queried.</param>
      <param name="targetNormalizedTime">The current state Time that is queried.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetTrigger(System.String)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetTrigger" cref="IAnimatorControllerPlayable.SetTrigger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetTrigger(System.Int32)">
      <summary>See <see href="Experimental.Director.IAnimatorControllerPlayable.SetTrigger" cref="IAnimatorControllerPlayable.SetTrigger" />.</summary>
    </member>
    <member name="M:UnityEngine.Animator.StartPlayback">
      <summary>
        <para>Sets the animator in playback mode.</para>
        <para>In this mode, the animator is not updated from game logic and is controlled instead by setting time value. Note that time will not automatically progress here, you have to manipulate it explicitly from <see cref="P:UnityEngine.Animator.playbackTime" />. PlaybackRecordedFrame should be used to playback recorded data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.StartRecording(System.Int32)">
      <summary>
        <para>Sets the animator in recording mode, and allocates a circular buffer of size <c>frameCount</c>.</para>
        <para>After this call, the recorder starts collecting up to <c>frameCount</c> frames in the buffer. Note it is not possible to start playback until a call to <see cref="M:UnityEngine.Animator.StopRecording" /> is made.</para>
      </summary>
      <param name="frameCount">The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls <see cref="M:UnityEngine.Animator.StopRecording" />. The maximum value for frameCount is 10000.</param>
      <seealso cref="M:UnityEngine.Animator.StopRecording" />
      <seealso cref="P:UnityEngine.Animator.recorderStartTime" />
      <seealso cref="P:UnityEngine.Animator.recorderStopTime" />
      <seealso cref="M:UnityEngine.Animator.StartPlayback" />
      <seealso cref="M:UnityEngine.Animator.StopPlayback" />
      <seealso cref="P:UnityEngine.Animator.playbackTime" />
    </member>
    <member name="M:UnityEngine.Animator.StopPlayback">
      <summary>Stops the animator playback mode. When playback stops, the avatar resumes getting control from game logic.</summary>
      <seealso cref="M:UnityEngine.Animator.StartRecording(System.Int32)" />
      <seealso cref="M:UnityEngine.Animator.StopRecording" />
      <seealso cref="P:UnityEngine.Animator.recorderStartTime" />
      <seealso cref="P:UnityEngine.Animator.recorderStopTime" />
      <seealso cref="M:UnityEngine.Animator.StartPlayback" />
      <seealso cref="P:UnityEngine.Animator.playbackTime" />
    </member>
    <member name="M:UnityEngine.Animator.StopRecording">
      <summary>
        <para>Stops animator record mode.</para>
        <para>A call to <see cref="M:UnityEngine.Animator.StopRecording" /> will lock the recording buffer's contents in its current state. The data get saved for subsequent playback with <see cref="M:UnityEngine.Animator.StartPlayback" />.</para>
      </summary>
      <seealso cref="M:UnityEngine.Animator.StartRecording(System.Int32)" />
      <seealso cref="P:UnityEngine.Animator.recorderStartTime" />
      <seealso cref="P:UnityEngine.Animator.recorderStopTime" />
      <seealso cref="M:UnityEngine.Animator.StartPlayback" />
      <seealso cref="M:UnityEngine.Animator.StopPlayback" />
      <seealso cref="P:UnityEngine.Animator.playbackTime" />
    </member>
    <member name="M:UnityEngine.Animator.Update(System.Single)">
      <summary>
        <para>Evaluates the animator based on deltaTime.</para>
        <para>Updating the animator with this function migth not work well with the physics engine or any other system that is normaly evaluated by the Game loop.</para>
      </summary>
      <param name="deltaTime">The time delta.</param>
    </member>
    <member name="M:UnityEngine.Animator.StringToHash(System.String)">
      <summary>
        <para>Generates an parameter id from a string.</para>
        <para>Ids are used for optimized setters and getters on parameters.</para>
      </summary>
      <param name="name">The string to convert to Id.</param>
    </member>
    <member name="P:UnityEngine.AnimatorClipInfo.clip">
      <summary>Returns the animation clip played by the Animator.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorClipInfo.weight">
      <summary>Returns the blending weight used by the Animator to blend this clip.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultBool">
      <summary>
        <para>The default bool value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Bool.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultFloat">
      <summary>
        <para>The default bool value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Float.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultInt">
      <summary>
        <para>The default bool value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Int.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.name">
      <summary>The name of the parameter.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.nameHash">
      <summary>Returns the hash of the parameter based on its name.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.type">
      <summary>The type of the parameter.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorOverrideController.clips">
      <summary>Returns the list of orignal clip from the controller and their override clip.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorOverrideController.runtimeAnimatorController">
      <summary>The Controller that the AnimatorOverrideController overrides.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.fullPathHash">
      <summary>
        <para>The full path hash for this state.</para>
        <para>The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.length">
      <summary>
        <para>Current duration of the state.</para>
        <para>In seconds Can vary when the State contains a Blend Tree.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.loop">
      <summary>
        <para>Is the state looping.</para>
        <para>All animations in the state must be looping.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.normalizedTime">
      <summary>
        <para>Normalized time of the State.</para>
        <para>The integer part is the number of time a state has been looped. The fractional part is the % (0-1) of progress in the current loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.shortNameHash">
      <summary>The hash is generated using Animator::StringToHash. The string to pass doest not include the parent layer's name.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.speed">
      <summary>
        <para>The playback speed of the animation. 1 is the normal playback speed.</para>
        <para>A negative playback speed will play the animation from the end.see <see cref="P:UnityEditor.Animations.AnimatorState.speed" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.speedMultiplier">
      <summary>
        <para>The speed multiplier for this state.</para>
        <para>A negative speed multiplier will play the animation backwards. If no speed parameter as been set for this <see cref="T:UnityEditor.Animations.AnimatorState" />, the default value will be 1.see <see cref="P:UnityEditor.Animations.AnimatorState.speedParameter" />, <see cref="P:UnityEditor.Animations.AnimatorState.speedParameterActive" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.tagHash">
      <summary>
        <para>The Tag of the State.</para>
        <para>The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorStateInfo.IsName(System.String)">
      <summary>
        <para>Does <c>name</c> match the name of the active state in the statemachine?</para>
        <para>The name should be in the form <c>Layer.Name</c>, for example "Base.Idle".</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorStateInfo.IsTag(System.String)">
      <summary>Does <c>tag</c> match the tag of the active state in the statemachine.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.anyState">
      <summary>Returns true if the transition is from an AnyState node, or from Animator.CrossFade().</summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.fullPathHash">
      <summary>
        <para>The unique name of the Transition.</para>
        <para>Format is "FULLPATH.CURRENT_STATE -&gt; FULLPATH.NEXT_STATE" The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.nameHash">
      <summary>
        <para>The simplified name of the Transition.</para>
        <para>Format is "CURRENT_STATE -&gt; NEXT_STATE" The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.normalizedTime">
      <summary>
        <para>Normalized time of the Transition.</para>
        <para>0.0f to 1.0f.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.userNameHash">
      <summary>
        <para>The user-specidied name of the Transition.</para>
        <para>The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorTransitionInfo.IsName(System.String)">
      <summary>
        <para>Does <c>name</c> match the name of the active Transition.</para>
        <para>Format is "CURRENT_STATE -&gt; NEXT_STATE".</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorTransitionInfo.IsUserName(System.String)">
      <summary>Does <c>userName</c> match the name of the active Transition.</summary>
    </member>
    <member name="M:UnityEngine.AnimatorUtility.DeoptimizeTransformHierarchy(UnityEngine.GameObject)">
      <summary>
        <para>This function will recreate all transform hierarchy under GameObject.</para>
        <para>A call to this function at runtime will re-initialize the animator.See Also: <see cref="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])" />, <see cref="P:UnityEngine.Animator.hasTransformHierarchy" />.</para>
      </summary>
      <param name="go">GameObject to Deoptimize.</param>
    </member>
    <member name="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])">
      <summary>
        <para>This function will remove all transform hierarchy under GameObject, the animator will write directly transform matrices into the skin mesh matrices saving alot of CPU cycles.</para>
        <para>You can optionally provide a list of transform name, this function will create a flattened hierarchy of these transform under GameObject.A call to this function at runtime will re-initialize the animator.See Also: <see cref="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])" />, <see cref="P:UnityEngine.Animator.hasTransformHierarchy" />.</para>
      </summary>
      <param name="go">GameObject to Optimize.</param>
      <param name="exposedTransforms">List of transform name to expose.</param>
    </member>
    <member name="P:UnityEngine.Application.absoluteURL">
      <summary>
        <para>The absolute path to the web player data file (Read Only).</para>
        <para>Application.absoluteURL and Application.srcValue allow you to detect if your unityWeb data file was moved to another location or is being linked to. You might want to protect against both to prevent piracy of your data files.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.backgroundLoadingPriority">
      <summary>
        <para>Priority of background loading thread.</para>
        <para>Lets you control how long it takes to load data asynchronously vs performance impact on the game while loading in the background.Asynchronous load functions that load objects (<see cref="M:UnityEngine.Resources.LoadAsync(System.String)" />, <see cref="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String)" />, AssetBundle.LoadAllAssetAsync), scenes (<see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />) do data read and deserealization on a separate background loading thread and object integration on a main thread. <c>Integration</c> depends on an object type and for textures, meshes means uploading data to the GPU, audio clips prepare data for playing. To avoid hiccups we limit <c>integration</c> time on a main thread depending on <see cref="P:UnityEngine.Application.backgroundLoadingPriority" /> value:<c>- ThreadPriority.Low - 2ms;</c><c>- ThreadPriority.BelowNormal - 4ms;</c><c>- ThreadPriority.Normal - 10ms;</c><c>- ThreadPriority.High - 50ms.</c> This is a maximum time all asynchronous operations can spend within a single frame on a main thread.Background loading thread uses <see cref="P:UnityEngine.Application.backgroundLoadingPriority" /> directly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.bundleIdentifier">
      <summary>Returns application bundle identifier at runtime.</summary>
    </member>
    <member name="P:UnityEngine.Application.cloudProjectId">
      <summary>A unique cloud project identifier. It is unique for every project (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.companyName">
      <summary>Return application company name (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.dataPath">
      <summary>
        <para>Contains the path to the game data folder (Read Only).</para>
        <para>The value depends on which platform you are running on:Unity Editor: &lt;<c>path to project folder</c>&gt;/AssetsMac player: &lt;<c>path to player app bundle</c>&gt;/ContentsiOS player: &lt;<c>path to player app bundle</c>&gt;/&lt;<c>AppName.app</c>&gt;/Data (this folder is read only, use <see cref="P:UnityEngine.Application.persistentDataPath" /> to save data).Win/Linux player: &lt;<c>path to executablename_Data folder</c>&gt; (note that most Linux installations will be case-sensitive!)Web player: The absolute url to the player data file folder (without the actual data file name)WebGL: The absolute url to the player data file folder (without the actual data file name)Android: Normally it would point directly to the APK. The exception is if you are running a split binary build in which case it points to the the OBB instead.Note that the string returned on a PC will use a forward slash as a folder separator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.genuine">
      <summary>
        <para>Returns false if application is altered in any way after it was built.</para>
        <para>Otherwise returns true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.genuineCheckAvailable">
      <summary>
        <para>Returns true if application integrity can be confirmed.</para>
        <para>Otherwise returns false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.installMode">
      <summary>Returns application install mode (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.internetReachability">
      <summary>
        <para>Returns the type of Internet reachability currently possible on the device.</para>
        <para>This property is mostly useful on handhelds to distinguish fast and cheap WiFi connection from carrier networking.Note: Do not use this property to determine the actual connectivity. E.g. the device can be connected to a hot spot, but not have the actual route to the network. Non-handhelds are considered to always be capable of <see cref="F:UnityEngine.NetworkReachability.ReachableViaLocalAreaNetwork" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isConsolePlatform">
      <summary>Is the current Runtime platform a known console platform.</summary>
    </member>
    <member name="P:UnityEngine.Application.isEditor">
      <summary>
        <para>Are we running inside the Unity editor? (Read Only)</para>
        <para>Returns true if the game is being run from the Unity editor; false if run from any deployment target.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isMobilePlatform">
      <summary>Is the current Runtime platform a known mobile platform.</summary>
    </member>
    <member name="P:UnityEngine.Application.isPlaying">
      <summary>
        <para>Returns true when in any kind of player (Read Only).</para>
        <para>Returns true in the Unity editor when in play mode.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isShowingSplashScreen">
      <summary>
        <para>Checks whether splash screen is being shown.</para>
        <para>Returns true if the application is showing splash screen at the moment.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isWebPlayer">
      <summary>
        <para>Are we running inside a web player? (Read Only)</para>
        <para>Returns true if the game is being run from the Unity web player.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.levelCount">
      <summary>The total number of levels available (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.loadedLevel">
      <summary>The level index that was last loaded (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.loadedLevelName">
      <summary>
        <para>The name of the level that was last loaded (Read Only).</para>
        <para>Note that this value is set only by <see cref="M:UnityEngine.Application.LoadLevel(System.Int32)" /> and <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />. The <c>Additive</c> versions add content to the current level.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.persistentDataPath">
      <summary>
        <para>Contains the path to a persistent data directory (Read Only).</para>
        <para>The value is a directory path where data expected to be kept between runs can be stored. When publishing on iOS and Android, persistentDataPath will point to a public directory on the device. Files in this location won't be erased with each update of the App. However, you should bear in mind that this is not foolproof against users' actions. For example, removing the SD Card would make data stored on it inaccessible. Note that when you build the app, a GUID will be generated based on the Bundle Identifier, and this GUID will be part of persistentDataPath. If you keep the same Bundle Identifier in future versions then the app will continue accessing the same location on every update.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.platform">
      <summary>
        <para>Returns the platform the game is running (Read Only).</para>
        <para>Use this property if you absolutely need to do some platform dependent work.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.productName">
      <summary>Returns application product name (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.runInBackground">
      <summary>
        <para>Should the player be running when the application is in the background?</para>
        <para>Default is false (application pauses when it is in background).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.sandboxType">
      <summary>Returns application running in sandbox (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.srcValue">
      <summary>
        <para>The path to the web player data file relative to the html file (Read Only).</para>
        <para>Actually this is whatever path is written in the html file as a <c>src</c> parameter to <c>object</c> and <c>embed</c> tags. So if it's the absolute URL, <c>srcValue</c> will have the absolute path.Application.absoluteURL and Application.srcValue allow you to detect if your unityWeb data file was moved to another location or is being linked to. You might want to protect against both to prevent piracy of your data files.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.stackTraceLogType">
      <summary>
        <para>Stack trace logging options. The default value is <see cref="F:UnityEngine.StackTraceLogType.ScriptOnly" />.</para>
        <para>Useful when you want more debugging information when a log message is printed to the log. For example, if you set <see cref="F:UnityEngine.StackTraceLogType.Full" />, both native and managed stack traces will be printed for messages.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.streamedBytes">
      <summary>
        <para>How many bytes have we downloaded from the main unity web stream (Read Only).</para>
        <para>In the webplayer this returns the number of compressed bytes downloaded so far. In standalone player or the editor this always returns zero.See Also: <see cref="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)" /> function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.streamingAssetsPath">
      <summary>
        <para>Contains the path to the StreamingAssets folder (Read Only).</para>
        <para>If you have a "StreamingAssets" folder in the Assets folder of your project, it will be copied to your player builds and be present in the path given by Application.streamingAssetsPath.Note that on some platforms it is not possible to directly access the StreamingAssets folder because there is no file system access in the web platforms, and because it is compressed into the .apk file on Android. On those platforms, a url will be returned, which can be used using the WWW class.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.systemLanguage">
      <summary>
        <para>The language the user's operating system is running in.</para>
        <para>You can use this to automatically pick a localization for your content based on the user's system language.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.targetFrameRate">
      <summary>
        <para>Instructs game to try to render at a specified frame rate.</para>
        <para>Setting <c>targetFrameRate</c> to -1 (the default) makes standalone games render as fast as they can, and web player games to render at 50-60 frames/second depending on the platform.Note that setting <c>targetFrameRate</c> does not guarantee that frame rate. There can be fluctuations due to platform specifics, or the game might not achieve the frame rate because the computer is too slow.If vsync is set in quality setting, the target framerate is ignored, and the vblank interval is used instead. The <c>vBlankCount</c> property on qualitysettings can be used to limit the framerate to half of the screens refresh rate (60 fps screen can be limited to 30 fps by setting vBlankCount to 2)<c>targetFrameRate</c> is ignored in the editor.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.temporaryCachePath">
      <summary>
        <para>Contains the path to a temporary data / cache directory (Read Only).</para>
        <para>The value is a directory path where temporary data can be stored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.unityVersion">
      <summary>The version of the Unity runtime used to play the content.</summary>
    </member>
    <member name="P:UnityEngine.Application.version">
      <summary>Returns application version number (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.webSecurityEnabled">
      <summary>
        <para>Indicates whether Unity's webplayer security model is enabled.</para>
        <para>In the web player, this will always return true. In the Unity editor, it will return true if web security emulation is enabled (Menu-&gt;Edit-&gt;Project Settings-&gt;Editor) and false if the emulation is disabled. On all other platforms, this will return false;This property can only be read. You can use <see href="EditorSettings-webSecurityEmulationEnabled" cref="EditorSettings.webSecurityEmulationEnabled" /> to set this setting in the editor environment.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.CancelQuit">
      <summary>
        <para>Cancels quitting the application. This is useful for showing a splash screen at the end of a game.</para>
        <para>This function only works in the player and does nothing in the web player or editor. IMPORTANT: This function has no effect on iPhone. Application can not prevent termination under iPhone OS.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)">
      <summary>Can the streamed level be loaded?</summary>
      <seealso cref="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.String)">
      <summary>Can the streamed level be loaded?</summary>
      <seealso cref="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.CaptureScreenshot(System.String,System.Int32)">
      <summary>
        <para>Captures a screenshot at path <c>filename</c> as a PNG file.</para>
        <para>If the file exists already, it will be overwritten. This function does nothing if used from inside the web player. On mobile platforms the filename is appended to the persistent data path.When <c>superSize</c> parameter is larger than 1, a larger resolution screenshot will be produced. For example, passing 4 will make the screenshot be 4x4 larger than it normally would. This is useful to produce screenshots for printing.</para>
      </summary>
      <param name="filename">Pathname to save the screenshot file to.</param>
      <param name="superSize">Factor by which to increase resolution.</param>
    </member>
    <member name="M:UnityEngine.Application.CaptureScreenshot(System.String)">
      <summary>
        <para>Captures a screenshot at path <c>filename</c> as a PNG file.</para>
        <para>If the file exists already, it will be overwritten. This function does nothing if used from inside the web player. On mobile platforms the filename is appended to the persistent data path.When <c>superSize</c> parameter is larger than 1, a larger resolution screenshot will be produced. For example, passing 4 will make the screenshot be 4x4 larger than it normally would. This is useful to produce screenshots for printing.</para>
      </summary>
      <param name="filename">Pathname to save the screenshot file to.</param>
    </member>
    <member name="M:UnityEngine.Application.ExternalCall(System.String,System.Object[])">
      <summary>
        <para>Calls a function in the containing web page (Web Player only).</para>
        <para>This will call JavaScript function <c>functionName</c> in the web page that contains the web player, passing given arguments to it. Supported argument types are the primitive types (string, int, float, char) and arrays of them. Any other objects are converted to string (using <c>ToString</c> method) and passed as strings.The function is called non-blocking, i.e. ExternalCall immediately returns without waiting for the function that was called to complete.The number of passed arguments can be varying:</para>
        <para>The functions to be called are just declared in the HTML page using standard syntax, for example:</para>
      </summary>
      <seealso cref="M:UnityEngine.Application.ExternalEval(System.String)" />
    </member>
    <member name="M:UnityEngine.Application.ExternalEval(System.String)">
      <summary>
        <para>Evaluates script snippet in the containing web page (Web Player only).</para>
        <para>This will execute JavaScript snippet <c>script</c> in the web page that contains the web player.</para>
      </summary>
      <seealso cref="M:UnityEngine.Application.ExternalCall(System.String,System.Object[])" />
    </member>
    <member name="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)">
      <summary>
        <para>How far has the download progressed? [0...1].</para>
        <para>In the webplayer this returns the progress of this level.See Also: <see cref="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.GetStreamProgressForLevel(System.String)">
      <summary>
        <para>How far has the download progressed? [0...1].</para>
        <para>In the webplayer this returns the progress of this level.See Also: <see cref="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.HasProLicense">
      <summary>Is Unity activated with the Pro license?</summary>
    </member>
    <member name="M:UnityEngine.Application.HasUserAuthorization(UnityEngine.UserAuthorization)">
      <summary>
        <para>Check if the user has authorized use of the webcam or microphone in the Web Player.</para>
        <para>This is used to check the result of a previous call to <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" />. Explicit user consent to use features is only needed in the Web Player. In other build targets, this function will always return true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.LoadLevel(System.Int32)">
      <summary>
        <para>Loads the level by its name or index.</para>
        <para>Before you can load a level you have to add it to the list of levels used in the game. Use <c>File-&gt;Build Settings...</c> in Unity and add the levels you need to the level list there. MonoBehaviour.OnLevelWasLoaded is called on all active game objects after the level has been loaded.</para>
        <para>When loading a new level all game objects that have been loaded before are destroyed. If you want to let an object survive when loading a new level, use Object.DontDestroyOnLoad. Calling LoadLevel will update <see cref="P:UnityEngine.Application.loadedLevel" /> and <see cref="P:UnityEngine.Application.loadedLevelName" />.Note: Actual level change happens in the beginning of the next frame at the Inititialization stage prior to the first <c>FixedUpdate</c> call (see Execution Order of Event Functions): - All game objects are being destroyed starting from root objects. OnDisable (if enabled) and OnDestroy callbacks are called for scripts. - New objects are being initialized. Awake, OnEnable, Start callbacks are called for scripts.See Also: <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />.</para>
      </summary>
      <param name="index">The level to load.</param>
    </member>
    <member name="M:UnityEngine.Application.LoadLevel(System.String)">
      <summary>
        <para>Loads the level by its name or index.</para>
        <para>Before you can load a level you have to add it to the list of levels used in the game. Use <c>File-&gt;Build Settings...</c> in Unity and add the levels you need to the level list there. MonoBehaviour.OnLevelWasLoaded is called on all active game objects after the level has been loaded.</para>
        <para>When loading a new level all game objects that have been loaded before are destroyed. If you want to let an object survive when loading a new level, use Object.DontDestroyOnLoad. Calling LoadLevel will update <see cref="P:UnityEngine.Application.loadedLevel" /> and <see cref="P:UnityEngine.Application.loadedLevelName" />.Note: Actual level change happens in the beginning of the next frame at the Inititialization stage prior to the first <c>FixedUpdate</c> call (see Execution Order of Event Functions): - All game objects are being destroyed starting from root objects. OnDisable (if enabled) and OnDestroy callbacks are called for scripts. - New objects are being initialized. Awake, OnEnable, Start callbacks are called for scripts.See Also: <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />.</para>
      </summary>
      <param name="name">The name of the level to load.</param>
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)">
      <summary>
        <para>Loads a level additively.</para>
        <para>Unlike <see cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />, LoadLevelAdditive does not destroy objects in the current level. Objects from the new level are added to the current scene. This is useful for creating continuous virtual worlds, where more content is loaded in as you walk through the environment.</para>
        <para>LoadLevelAdditive adds new objects in the beginning of the next frame at the Inititialization stage prior to the first <c>FixedUpdate</c> call (see Execution Order of Event Functions).See Also: <see cref="T:UnityEngine.AsyncOperation" />, <see cref="P:UnityEngine.Application.backgroundLoadingPriority" />, <see cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAdditive(System.String)">
      <summary>
        <para>Loads a level additively.</para>
        <para>Unlike <see cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />, LoadLevelAdditive does not destroy objects in the current level. Objects from the new level are added to the current scene. This is useful for creating continuous virtual worlds, where more content is loaded in as you walk through the environment.</para>
        <para>LoadLevelAdditive adds new objects in the beginning of the next frame at the Inititialization stage prior to the first <c>FixedUpdate</c> call (see Execution Order of Event Functions).See Also: <see cref="T:UnityEngine.AsyncOperation" />, <see cref="P:UnityEngine.Application.backgroundLoadingPriority" />, <see cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />, <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)">
      <summary>
        <para>Loads the level additively and asynchronously in the background.</para>
        <para>Unlike <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />, LoadLevelAdditiveAsync does not destroy objects in the current level. Objects from the new level are added to the current scene. This is useful for creating continuous virtual worlds, where more content is loaded in as you walk through the environment.Unity will completely load all assets and all objects in the scene in a background loading thread. This allows you to create a completely streaming world where you constantly load and unload different parts of the world based on the player position, without any hiccups in game play.<see cref="P:UnityEngine.AsyncOperation.isDone" /> variable from the resulting <see cref="T:UnityEngine.AsyncOperation" /> can be used to query if the level load has completed. The result of a LoadLevelAdditiveAsync can also be used to yield in a coroutine.When building a player Unity automatically optimizes assets in such a way that LoadLevelAdditiveAsync will load them from disk linearly to avoid seek times. Note that background loading performance in the Unity Editor is much lower than in the web player or standalone build. In the Editor you might also get more loading hiccups than in the player.</para>
      </summary>
      <seealso cref="T:UnityEngine.AsyncOperation" />
      <seealso cref="P:UnityEngine.Application.backgroundLoadingPriority" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.String)">
      <summary>
        <para>Loads the level additively and asynchronously in the background.</para>
        <para>Unlike <see cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />, LoadLevelAdditiveAsync does not destroy objects in the current level. Objects from the new level are added to the current scene. This is useful for creating continuous virtual worlds, where more content is loaded in as you walk through the environment.Unity will completely load all assets and all objects in the scene in a background loading thread. This allows you to create a completely streaming world where you constantly load and unload different parts of the world based on the player position, without any hiccups in game play.<see cref="P:UnityEngine.AsyncOperation.isDone" /> variable from the resulting <see cref="T:UnityEngine.AsyncOperation" /> can be used to query if the level load has completed. The result of a LoadLevelAdditiveAsync can also be used to yield in a coroutine.When building a player Unity automatically optimizes assets in such a way that LoadLevelAdditiveAsync will load them from disk linearly to avoid seek times. Note that background loading performance in the Unity Editor is much lower than in the web player or standalone build. In the Editor you might also get more loading hiccups than in the player.</para>
      </summary>
      <seealso cref="T:UnityEngine.AsyncOperation" />
      <seealso cref="P:UnityEngine.Application.backgroundLoadingPriority" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAsync(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAsync(System.Int32)">
      <summary>
        <para>Loads the level asynchronously in the background.</para>
        <para>Unity will completely load all assets and all objects in the scene in a background loading thread. This allows you to load new levels while still playing the current one, show a progress bar or create a completely streaming world where you constantly load and unload different parts of the world based on the player position, without any hiccups in game play.<see cref="P:UnityEngine.AsyncOperation.isDone" /> variable from the resulting <see cref="T:UnityEngine.AsyncOperation" /> can be used to query if the level load has completed. The result of a LoadLevelAsync can also be used to yield in a coroutine.When building a player Unity automatically optimizes assets in such a way that LoadLevelAsync will load them from disk linearly to avoid seek times. Note that background loading performance in the Unity Editor is much lower than in the web player or standalone build. In the Editor you might also get more loading hiccups than in the player.</para>
      </summary>
      <seealso cref="T:UnityEngine.AsyncOperation" />
      <seealso cref="P:UnityEngine.Application.backgroundLoadingPriority" />
      <seealso cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.LoadLevelAsync(System.String)">
      <summary>
        <para>Loads the level asynchronously in the background.</para>
        <para>Unity will completely load all assets and all objects in the scene in a background loading thread. This allows you to load new levels while still playing the current one, show a progress bar or create a completely streaming world where you constantly load and unload different parts of the world based on the player position, without any hiccups in game play.<see cref="P:UnityEngine.AsyncOperation.isDone" /> variable from the resulting <see cref="T:UnityEngine.AsyncOperation" /> can be used to query if the level load has completed. The result of a LoadLevelAsync can also be used to yield in a coroutine.When building a player Unity automatically optimizes assets in such a way that LoadLevelAsync will load them from disk linearly to avoid seek times. Note that background loading performance in the Unity Editor is much lower than in the web player or standalone build. In the Editor you might also get more loading hiccups than in the player.</para>
      </summary>
      <seealso cref="T:UnityEngine.AsyncOperation" />
      <seealso cref="P:UnityEngine.Application.backgroundLoadingPriority" />
      <seealso cref="M:UnityEngine.Application.LoadLevel(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditive(System.Int32)" />
      <seealso cref="M:UnityEngine.Application.LoadLevelAdditiveAsync(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Application.OpenURL(System.String)">
      <summary>
        <para>Opens the <c>url</c> in a browser.</para>
        <para>In the editor or standalone player this will open a new page in the default browser with the <c>url</c>. It will also bring the browser application to the front.When executed in the web player, the page the plugin is contained in will be redirected to the <c>url</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.Quit">
      <summary>
        <para>Quits the player application.</para>
        <para>Quit is ignored in the editor or the web player. IMPORTANT: In most cases termination of application under iOS should be left at the user discretion. Consult <see href="_index" cref="Apple Technical Page qa1561" /> for further details.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)">
      <summary>
        <para>Request authorization to use the webcam or microphone in the Web Player.</para>
        <para>For security reasons (to avoid implementing a web player spying on users), we require you to have the user explicitly allow these features in the web player. To do so, you need to call Application.RequestUserAuthorization, which shows a dialog box to the user, and wait for operation to complete before being able to use these features. Use <see cref="M:UnityEngine.Application.HasUserAuthorization(UnityEngine.UserAuthorization)" /> to query the result of the operation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.UnloadLevel(System.Int32)">
      <summary>Unloads all GameObject associated with the given scene. Note that assets are currently not unloaded, in order to free up asset memory call Resources.UnloadAllUnusedAssets.</summary>
      <param name="index">Index of the scene in the PlayerSettings to unload.</param>
      <returns>Return true if the scene is unloaded.</returns>
    </member>
    <member name="M:UnityEngine.Application.UnloadLevel(System.String)">
      <summary>Unloads all GameObject associated with the given scene. Note that assets are currently not unloaded, in order to free up asset memory call Resources.UnloadAllUnusedAssets.</summary>
      <param name="scenePath">Name of the scene to Unload.</param>
      <returns>Return true if the scene is unloaded.</returns>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.angularDrag">
      <summary>
        <para>The angular drag to apply to rigid-bodies.</para>
        <para>The <c>angularDrag</c> coefficient is applied in addition to the standard <see cref="T:UnityEngine.Rigidbody2D" /> angular drag coefficient to provide additional angular drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.drag">
      <summary>
        <para>The linear drag to apply to rigid-bodies.</para>
        <para>The <c>drag</c> coefficient is applied in addition to the standard <see cref="T:UnityEngine.Rigidbody2D" /> drag coefficient to provide additional drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceAngle">
      <summary>
        <para>The angle of the force to be applied.</para>
        <para>The actual angle will be different depending on whether the <c>useGlobalAngle</c> is true or false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceMagnitude">
      <summary>The magnitude of the force to be applied.</summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceTarget">
      <summary>The target for where the effector applies any force.</summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceVariation">
      <summary>
        <para>The variation of the magnitude of the force to be applied.</para>
        <para>A random value between 0 and <c>forceVariation</c> is used and added to the force magnitude. The <c>forceVariation</c> can be negative to randomly reduce the force magnitude.See Also: <see cref="P:UnityEngine.AreaEffector2D.forceMagnitude" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.useGlobalAngle">
      <summary>
        <para>Should the <c>forceAngle</c> use global space?</para>
        <para>When true, the <c>forceAngle</c> is specified in global-space. When false, the <c>forceAngle</c> is specified in local-space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AssetBundle.mainAsset">
      <summary>
        <para>Main asset that was supplied when building the asset bundle (Read Only).</para>
        <para>This is a convenience function that makes it easy to find the primary asset of a bundle. For example you might want to have a prefab of a character and include all textures, materials, meshes and animations files with it. But the fully rigged prefab of the character would be your mainAsset and can easily be accessed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.Contains(System.String)">
      <summary>
        <para>Check if an AssetBundle contains a specific object.</para>
        <para>Returns true if an object referred to by <c>name</c> is contained in the AssetBundle, false otherwise.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.GetAllAssetNames">
      <summary>
        <para>Return all asset names in the AssetBundle.</para>
        <para>Only works for normal AssetBundles (non-streamed scene AssetBundle), otherwise empty string array is returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.GetAllScenePaths">
      <summary>
        <para>Return all the scene asset paths (paths to *.unity assets) in the AssetBundle.</para>
        <para>Only works for streamed scene AssetBundles, otherwise empty string array is returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssets(System.Type)">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>type</c>.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssets">
      <summary>Loads all assets contained in the asset bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssets``1">
      <summary>Loads all assets contained in the asset bundle that inherit from type <c>T</c>.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync">
      <summary>Loads all assets contained in the asset bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>T</c> asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync(System.Type)">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>type</c> asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAsset(System.String)">
      <summary>
        <para>Loads asset with <c>name</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using Load. This is not supported anymore. Instead, please use LoadAsset to load the game object first and then look up the component on the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAsset(System.String,System.Type)">
      <summary>
        <para>Loads asset with <c>name</c> of a given <c>type</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using Load. This is not supported anymore. Instead, please use LoadAsset to load the game object first and then look up the component on the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAsset``1(System.String)">
      <summary>
        <para>Loads asset with <c>name</c> of type <c>T</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using Load. This is not supported anymore. Instead, please use LoadAsset to load the game object first and then look up the component on the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.See Also: <see cref="T:UnityEngine.AssetBundleRequest" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> of a given <c>T</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.See Also: <see cref="T:UnityEngine.AssetBundleRequest" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String,System.Type)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> of a given <c>type</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.See Also: <see cref="T:UnityEngine.AssetBundleRequest" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssets(System.String)">
      <summary>Loads asset and sub assets with <c>name</c> from the bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssets(System.String,System.Type)">
      <summary>Loads asset and sub assets with <c>name</c> of a given <c>type</c> from the bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssets``1(System.String)">
      <summary>Loads asset and sub assets with <c>name</c> of type <c>T</c> from the bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String)">
      <summary>Loads asset with sub assets with <c>name</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String)">
      <summary>Loads asset with sub assets with <c>name</c> of type <c>T</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String,System.Type)">
      <summary>Loads asset with sub assets with <c>name</c> of a given <c>type</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest" />
    </member>
    <member name="M:UnityEngine.AssetBundle.Unload(System.Boolean)">
      <summary>
        <para>Unloads all assets in the bundle.</para>
        <para>Unload frees all the memory associated with the objects inside the bundle.When <c>unloadAllLoadedObjects</c> is false, compressed file data for assets inside the bundle will be unloaded, but any actual objects already loaded from this bundle will be kept intact. Of course you won't be able to load any more objects from this bundle.When <c>unloadAllLoadedObjects</c> is true, all objects that were loaded from this bundle will be destroyed as well. If there are game objects in your scene referencing those assets, the references to them will become missing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.CreateFromFile(System.String)">
      <summary>
        <para>Loads an asset bundle from a disk.</para>
        <para>Only uncompressed asset bundles are supported by this function. This is the fastest way to load an asset bundle.</para>
      </summary>
      <param name="path">Path of the file on diskSee Also: <see cref="P:UnityEngine.WWW.assetBundle" />, <see cref="M:UnityEngine.WWW.LoadFromCacheOrDownload(System.String,System.Int32,System.UInt32)" />.</param>
    </member>
    <member name="M:UnityEngine.AssetBundle.CreateFromMemory(System.Byte[])">
      <summary>
        <para>Asynchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes asynchronously. This is useful when you want to download the AssetBundle using your own system instead of the WWW class, or when you have downloaded the data with encryption using WWW and need to create the AssetBundle from the unencrypted bytes. Compared to AssetBundle.CreateFromMemoryImmediate, this version will perform AssetBundle decompression on a background thread, and will not create the AssetBundle object immediately. Thus, using this function to load an uncompressed AssetBundle will cause it to have the same behaviour as CreateFromMemoryImmediate.See Also: <see cref="T:UnityEngine.AssetBundleCreateRequest" />, <see cref="M:UnityEngine.AssetBundle.CreateFromMemoryImmediate(System.Byte[])" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.CreateFromMemoryImmediate(System.Byte[])">
      <summary>
        <para>Synchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes. This is useful when you want to download the AssetBundle using your own system instead of the WWW class, or when you have downloaded the data with encryption and need to create the AssetBundle from the unencrypted bytes.Compared to AssetBundle.CreateFromMemory, this version is synchronous and will not return until it is done creating the AssetBundle object.See Also: <see cref="T:UnityEngine.AssetBundleCreateRequest" />, <see cref="M:UnityEngine.AssetBundle.CreateFromMemory(System.Byte[])" />.</para>
      </summary>
      <param name="binary">Array of bytes with the AssetBundle data.</param>
    </member>
    <member name="P:UnityEngine.AssetBundleCreateRequest.assetBundle">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="P:UnityEngine.AsyncOperation.isDone" /> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllAssetBundles">
      <summary>Get all the AssetBundles in the manifest.</summary>
      <returns>An array of asset bundle names.</returns>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllAssetBundlesWithVariant">
      <summary>Get all the AssetBundles with variant in the manifest.</summary>
      <returns>An array of asset bundle names.</returns>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllDependencies(System.String)">
      <summary>Get all the dependent AssetBundles for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAssetBundleHash(System.String)">
      <summary>Get the hash for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
      <returns>The 128-bit hash for the asset bundle.</returns>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetDirectDependencies(System.String)">
      <summary>Get the direct dependent AssetBundles for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
      <returns>Array of asset bundle names this asset bundle depends on.</returns>
    </member>
    <member name="P:UnityEngine.AssetBundleRequest.allAssets">
      <summary>
        <para>Asset objects with sub assets being loaded. (Read Only)</para>
        <para>Note that accessing asset before <see cref="P:UnityEngine.AsyncOperation.isDone" /> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AssetBundleRequest.asset">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="P:UnityEngine.AsyncOperation.isDone" /> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.allowSceneActivation">
      <summary>
        <para>Allow scenes to be activated as soon as it is ready.</para>
        <para>When used in combination with LoadLevelAsync &amp; LoadLevelAsyncAdditive it allows you to delay the actual activation of the scene. (And unloading of the previous scene).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.isDone">
      <summary>Has the operation finished? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.priority">
      <summary>
        <para>Priority lets you tweak in which order async operation calls will be performed.</para>
        <para>When multiple asynchronous operations are queued up, the operation with the higher priority will be executed first. Once an operation has been started on the background thread, changing the priority will have no effect anymore.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.progress">
      <summary>What's the operation's progress. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.delay">
      <summary>Chorus delay in ms. 0.1 to 100.0. Default = 40.0 ms.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.depth">
      <summary>Chorus modulation depth. 0.0 to 1.0. Default = 0.03.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.dryMix">
      <summary>Volume of original signal to pass to output. 0.0 to 1.0. Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.rate">
      <summary>Chorus modulation rate in hz. 0.0 to 20.0. Default = 0.8 hz.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.wetMix1">
      <summary>Volume of 1st chorus tap. 0.0 to 1.0. Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.wetMix2">
      <summary>Volume of 2nd chorus tap. This tap is 90 degrees out of phase of the first tap. 0.0 to 1.0. Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioChorusFilter.wetMix3">
      <summary>Volume of 3rd chorus tap. This tap is 90 degrees out of phase of the second tap. 0.0 to 1.0. Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.channels">
      <summary>The number of channels in the audio clip. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.frequency">
      <summary>The sample frequency of the clip in Hertz. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.length">
      <summary>The length of the audio clip in seconds. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.loadInBackground">
      <summary>Corresponding to the "Load In Background" flag in the inspector, when this flag is set, the loading will happen delayed without blocking the main thread.</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.loadState">
      <summary>Returns the current load state of the audio data associated with an AudioClip.</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.loadType">
      <summary>
        <para>The load type of the clip (read-only).</para>
        <para>The load type, which can be set up in the inspector of the AudioClip, controls how the clip is being loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioClip.preloadAudioData">
      <summary>Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.</summary>
    </member>
    <member name="P:UnityEngine.AudioClip.samples">
      <summary>The length of the audio clip in samples. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.AudioClip.GetData(System.Single[],System.Int32)">
      <summary>
        <para>Fills an array with sample data from the clip.</para>
        <para>The samples are floats ranging from -1.0f to 1.0f. The sample count is determined by the length of the float array. Use offsetSamples to start the read from a random position in the clip. If the read length from the offset is longer than the clip length, the read will wrap around and read the remaining samples from the start of the clip.Note that with compressed audio files, the sample data can only be retrieved when the <c>Load Type</c> is set to <c>Decompress on Load</c> in the audio importer. If this is not the case then the array will be returned with zeroes for all the sample values.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AudioClip.LoadAudioData">
      <summary>Loads the audio data of a clip. Clips that have "Preload Audio Data" set will load the audio data automatically.</summary>
      <returns>Returns true if loading succeeded.</returns>
    </member>
    <member name="M:UnityEngine.AudioClip.SetData(System.Single[],System.Int32)">
      <summary>
        <para>Set sample data in a clip.</para>
        <para>The samples should be floats ranging from 0.0f to 1.0f (exceeding these limits will lead to artifacts and undefined behaviour). The sample count is determined by the length of the float array. Use offsetSamples to write into a random position in the clip. If the length from the offset is longer than the clip length, the write will wrap around and write the remaining samples from the start of the clip.Note that for compressed audio, the sample data can only be set when the <c>Load Type</c> is set to <c>Decompress on Load</c> in the audio importer.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AudioClip.UnloadAudioData">
      <summary>Unloads the audio data associated with the clip. This works only for AudioClips that are based on actual sound file assets.</summary>
      <returns>Returns false if unloading failed.</returns>
    </member>
    <member name="F:UnityEngine.AudioConfiguration.dspBufferSize">
      <summary>The length of the DSP buffer in samples determining the latency of sounds by the audio output device.</summary>
    </member>
    <member name="F:UnityEngine.AudioConfiguration.numRealVoices">
      <summary>The current maximum number of simultaneously audible sounds in the game.</summary>
    </member>
    <member name="F:UnityEngine.AudioConfiguration.numVirtualVoices">
      <summary>The maximum number of managed sounds in the game. Beyond this limit sounds will simply stop playing.</summary>
    </member>
    <member name="F:UnityEngine.AudioConfiguration.sampleRate">
      <summary>The current sample rate of the audio output device used.</summary>
    </member>
    <member name="F:UnityEngine.AudioConfiguration.speakerMode">
      <summary>The current speaker mode used by the audio output device.</summary>
    </member>
    <member name="P:UnityEngine.AudioDistortionFilter.distortionLevel">
      <summary>Distortion value. 0.0 to 1.0. Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioEchoFilter.decayRatio">
      <summary>Echo decay per delay. 0 to 1. 1.0 = No decay, 0.0 = total decay (i.e. simple 1 line delay). Default = 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioEchoFilter.delay">
      <summary>Echo delay in ms. 10 to 5000. Default = 500.</summary>
    </member>
    <member name="P:UnityEngine.AudioEchoFilter.dryMix">
      <summary>Volume of original signal to pass to output. 0.0 to 1.0. Default = 1.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioEchoFilter.wetMix">
      <summary>Volume of echo signal to pass to output. 0.0 to 1.0. Default = 1.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioHighPassFilter.cutoffFrequency">
      <summary>Highpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioHighPassFilter.highpassResonanceQ">
      <summary>
        <para>Determines how much the filter's self-resonance isdampened.</para>
        <para>Higher Highpass resonance Q indicates a lower rate of energy loss i.e. the oscillations die out more slowly.Highpass resonance Q value goes from 1.0 to 10.0. Default = 1.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioListener.pause">
      <summary>
        <para>The paused state of the audio system.</para>
        <para>If set to true, all AudioSources playing will be paused. This works in the same way as pausing the game in the editor. While the pause-state is true, the AudioSettings.dspTime will be frozen and further AudioSource play requests will start off paused. If you want certain sounds to still play during the pause, you need to set the ignoreListenerPause property on the AudioSource to true for these. This is typically menu item sounds or background music for the menu. Any scheduled play requests will be frozen in time, so that if you scheduled a sound to play after 3 seconds and paused the audio system 1 second after this, the scheduled sounds will start playing 2 seconds after unpausing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioListener.volume">
      <summary>Controls the game sound volume (0.0 to 1.0).</summary>
    </member>
    <member name="P:UnityEngine.AudioListener.velocityUpdateMode">
      <summary>
        <para>This lets you set whether the Audio Listener should be updated in the fixed or dynamic update.</para>
        <para>Make sure this is set to update in the same update loop as the Audio Listener is moved in if you are experiencing problems with Doppler effect simulation. The default setting will automatically set the listener to be updated in the fixed update loop if it is attached to a rigidbody, and dynamic otherwise.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioLowPassFilter.customCutoffCurve">
      <summary>
        <para>Returns or sets the current custom frequency cutoff curve.</para>
        <para>The curve will be scaled so that it is applied over AudioSource.maxDistance from the AudioSource.Note that if there is no curve set, or AudioLowPassFilter.cutoffFrequency has been set, a single key AnimationCurve will be returned corresponding to the current cutoff frequency.Setting the curve will result in the internal AnimationCurve to be rescaled to range from 0..1 for performance reasons. This means calling AudioLowPassFilter.customCutoffCurve will return a potentially different curve to what was just set.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioLowPassFilter.cutoffFrequency">
      <summary>
        <para>Lowpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0.</para>
        <para>Note that setting this value will reset any custom cutoff curve set for this AudioLowPassFilter.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioLowPassFilter.lowpassResonanceQ">
      <summary>
        <para>Determines how much the filter's self-resonance is dampened.</para>
        <para>Higher Lowpass Resonance Q indicates a lower rate of energy loss i.e. the oscillations die out more slowly.Lowpass resonance Q value goes from 1.0 to 10.0. Default = 1.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.decayHFRatio">
      <summary>Decay HF Ratio : High-frequency to low-frequency decay time ratio. Ranges from 0.1 to 2.0. Default is 0.5.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.decayTime">
      <summary>Reverberation decay time at low-frequencies in seconds. Ranges from 0.1 to 20.0. Default is 1.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.density">
      <summary>Reverberation density (modal density) in percent. Ranges from 0.0 to 100.0. Default is 100.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.diffusion">
      <summary>Reverberation diffusion (echo density) in percent. Ranges from 0.0 to 100.0. Default is 100.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.dryLevel">
      <summary>Mix level of dry signal in output in mB. Ranges from -10000.0 to 0.0. Default is 0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.hfReference">
      <summary>Reference high frequency in Hz. Ranges from 20.0 to 20000.0. Default is 5000.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.lfReference">
      <summary>Reference low-frequency in Hz. Ranges from 20.0 to 1000.0. Default is 250.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.reflectionsDelay">
      <summary>Late reverberation level relative to room effect in mB. Ranges from -10000.0 to 2000.0. Default is 0.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.reflectionsLevel">
      <summary>Early reflections level relative to room effect in mB. Ranges from -10000.0 to 1000.0. Default is -10000.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.reverbDelay">
      <summary>Late reverberation delay time relative to first reflection in seconds. Ranges from 0.0 to 0.1. Default is 0.04.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.reverbLevel">
      <summary>Late reverberation level relative to room effect in mB. Ranges from -10000.0 to 2000.0. Default is 0.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.reverbPreset">
      <summary>Set/Get reverb preset properties.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.room">
      <summary>Room effect level at low frequencies in mB. Ranges from -10000.0 to 0.0. Default is 0.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.roomHF">
      <summary>Room effect high-frequency level re. low frequency level in mB. Ranges from -10000.0 to 0.0. Default is 0.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.roomLF">
      <summary>Room effect low-frequency level in mB. Ranges from -10000.0 to 0.0. Default is 0.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbFilter.roomRolloff">
      <summary>Rolloff factor for room effect. Ranges from 0.0 to 10.0. Default is 10.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.decayHFRatio">
      <summary>High-frequency to mid-frequency decay time ratio.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.decayTime">
      <summary>Reverberation decay time at mid frequencies.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.density">
      <summary>Value that controls the modal density in the late reverberation decay.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.diffusion">
      <summary>Value that controls the echo density in the late reverberation decay.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.HFReference">
      <summary>Reference high frequency (hz).</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.LFReference">
      <summary>Reference low frequency (hz).</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.maxDistance">
      <summary>The distance from the centerpoint that the reverb will not have any effect. Default = 15.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.minDistance">
      <summary>The distance from the centerpoint that the reverb will have full effect at. Default = 10.0.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.reflections">
      <summary>Early reflections level relative to room effect.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.reflectionsDelay">
      <summary>Initial reflection delay time.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.reverb">
      <summary>Late reverberation level relative to room effect.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.reverbDelay">
      <summary>Late reverberation delay time relative to initial reflection.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.reverbPreset">
      <summary>Set/Get reverb preset properties.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.room">
      <summary>Room effect level (at mid frequencies).</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.roomHF">
      <summary>Relative room effect level at high frequencies.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.roomLF">
      <summary>Relative room effect level at low frequencies.</summary>
    </member>
    <member name="P:UnityEngine.AudioReverbZone.roomRolloffFactor">
      <summary>Like rolloffscale in global settings, but for reverb room size effect.</summary>
    </member>
    <member name="P:UnityEngine.AudioSettings.driverCapabilities">
      <summary>Returns the speaker mode capability of the current audio driver. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AudioSettings.dspTime">
      <summary>
        <para>Returns the current time of the audio system.</para>
        <para>This is a value specified in seconds and based on the actual number of samples the audio system processes and is therefore much more precise than the time obtained via the <see cref="P:UnityEngine.Time.time" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSettings.outputSampleRate">
      <summary>
        <para>Get the mixer's current output rate.</para>
        <para>As of version 5.0 setting the sample rate from scripts is no longer supported. This has to be set in the Audio section of the project settings instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSettings.speakerMode">
      <summary>
        <para>Gets the current speaker mode. Default is 2 channel stereo.</para>
        <para>As of version 5.0 setting the speaker mode from scripts is no longer supported. This has to be set in the Audio section of the project settings instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AudioSettings.GetConfiguration">
      <summary>
        <para>Returns the current configuration of the audio device and system. The values in the struct may then be modified and reapplied via <see cref="M:UnityEngine.AudioSettings.Reset(UnityEngine.AudioConfiguration)" />.</para>
        <para>See <see cref="M:UnityEngine.AudioSettings.Reset(UnityEngine.AudioConfiguration)" /> for an example.</para>
      </summary>
      <returns>The new configuration to be applied.</returns>
    </member>
    <member name="M:UnityEngine.AudioSettings.GetDSPBufferSize(System.Int32@,System.Int32@)">
      <summary>
        <para>Get the mixer's buffer size in samples.</para>
        <para>For mobiles (iOS devices and Android) the is also settable from the menu 'Audio Settings-&gt;Mobile DSP Buffer size'. The software mixer mixes to a ringbuffer. The size of this ringbuffer is determined here. It mixes a block of sound data every 'bufferlength' number of samples, and there are 'numbuffers' number of these blocks that make up the entire ringbuffer. Adjusting these values can lead to extremely low latency performance (smaller values), or greater stability in sound output (larger values). Warning! The 'buffersize' is generally best left alone. Making the granularity smaller will just increase CPU usage (cache misses and DSP network overhead). Making it larger affects how often you hear commands update such as volume/pitch/pan changes. Anything above 20ms will be noticable and sound parameter changes will be obvious instead of smooth. Unity chooses the most optimal size by default for best stability, depending on the output type, and if the drivers are emulated or not (for example DirectSound is emulated using waveOut on NT). It is not recommended changing this value unless you really need to. You may get worse performance than the default settings chosen by Unity. As of version 5.0 setting the DSP buffer size from scripts is no longer supported. This has to be set in the Audio section of the project settings instead.</para>
      </summary>
      <param name="bufferLength">Is the length of each buffer in the ringbuffer.</param>
      <param name="numBuffers">Is number of buffers.</param>
    </member>
    <member name="M:UnityEngine.AudioSettings.Reset(UnityEngine.AudioConfiguration)">
      <summary>Performs a change of the device configuration. In response to this the <see href="AudioSettings.OnAudioConfigurationChanged" cref="AudioSettings.OnAudioConfigurationChanged" /> delegate is invoked with the argument deviceWasChanged=false. It cannot be guaranteed that the exact settings specified can be used, but the an attempt is made to use the closest match supported by the system.</summary>
      <param name="config">The new configuration to be used.</param>
      <returns>True if all settings could be successfully applied.</returns>
    </member>
    <member name="P:UnityEngine.AudioSource.bypassEffects">
      <summary>Bypass effects (Applied from filter components or global listener filters).</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.bypassListenerEffects">
      <summary>When set global effects on the AudioListener will not be applied to the audio signal generated by the AudioSource. Does not apply if the AudioSource is playing into a mixer group.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.bypassReverbZones">
      <summary>When set doesn't route the signal from an AudioSource into the global reverb associated with reverb zones.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.clip">
      <summary>The default <see cref="T:UnityEngine.AudioClip" /> to play.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.dopplerLevel">
      <summary>Sets the Doppler scale for this AudioSource.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.ignoreListenerPause">
      <summary>
        <para>Allows AudioSource to play even though AudioListener.pause is set to true. This is useful for the menu element sounds or background music in pause menus.</para>
        <para>This property can only be set via the script and is not serialized.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.ignoreListenerVolume">
      <summary>
        <para>This makes the audio source not take into account the volume of the audio listener.</para>
        <para>Enable this when playing back music. When playing back music you want a separate setting which is unaffected by the normal sound effects volume.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.isPlaying">
      <summary>
        <para>Is the <see cref="P:UnityEngine.AudioSource.clip" /> playing right now (Read Only)?</para>
        <para>Note: AudioSource.isPlaying will return <c>false</c> when AudioSource.Pause() is called. When you use AudioSource.Play() again back, it will return true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.loop">
      <summary>
        <para>Is the audio clip looping?</para>
        <para>If you disable looping on a playing AudioSource the sound will stop after the end of the current loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.maxDistance">
      <summary>
        <para>(Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at.</para>
        <para>(Linear rolloff) MaxDistance is the distance where the sound is completely inaudible.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.minDistance">
      <summary>
        <para>Within the Min distance the AudioSource will cease to grow louder in volume.</para>
        <para>Outside the min distance the volume starts to attenuate.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.mute">
      <summary>Un- / Mutes the AudioSource. Mute sets the volume=0, Un-Mute restore the original volume.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.outputAudioMixerGroup">
      <summary>The target group to which the AudioSource should route its signal.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.panStereo">
      <summary>
        <para>Pans a playing sound in a stereo way (left or right). This only applies to sounds that are Mono or Stereo.</para>
        <para>This pan is applied before 3D panning calculations are considered. In other words, stereo panning affects the left right balance of the sound before it is spatialised in 3D.Mono sounds are panned from left to right using constant power panning (non linear fade). This means when pan = 0.0, the balance for the sound in each speaker is 71% left and 71% right, not 50% left and 50% right. This gives (audibly) smoother pans.Stereo sounds heave each left/right value faded up and down according to the specified pan position. This means when pan = 0.0, the balance for the sound in each speaker is 100% left and 100% right. When pan = -1.0, only the left channel of the stereo sound is audible, when pan = 1.0, only the right channel of the stereo sound is audible.Values range from -1.0 to 1.0. -1.0 = Full left 0.0 = center 1.0 = full rightDefault = 0.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.pitch">
      <summary>The pitch of the audio source.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.playOnAwake">
      <summary>If set to true, the audio source will automatically start playing on awake.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.priority">
      <summary>
        <para>Sets the priority of the <see cref="T:UnityEngine.AudioSource" />.</para>
        <para>Unity is virtualizing AudioSources, when there's more AudioSources playing than available hardware channels. The AudioSources with lowest priority (and audibility) is virtualized first. Priority is an integer between 0 and 255. 0=highest priority, 255=lowest priority.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.reverbZoneMix">
      <summary>
        <para>The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones.</para>
        <para>The range from 0 to 1 is linear (like the volume property) while the range from 1 to 1.1 is an extra boost range that allows you to boost the reverberated signal by 10 dB. The associated curve in combination with the distance-based attenuation curve is useful when trying to simulate transitions from near-field to distant sounds.Note that prior to Unity 5.0 reverb zones were not applied to 2D sounds. With the generalization of 2D and 3D sounds in Unity 5.0 through the Spatial Blend parameter the reverb can now be applied to any sound. Therefore when importing Unity projects made with versions prior to 5.0 this parameter will be set to 0 for all the sounds that were 2D sounds, but is now adjustable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.rolloffMode">
      <summary>Sets/Gets how the AudioSource attenuates over distance.</summary>
    </member>
    <member name="P:UnityEngine.AudioSource.spatialBlend">
      <summary>
        <para>Sets how much this AudioSource is affected by 3D spatialisation calculations (attenuation, doppler etc). 0.0 makes the sound full 2D, 1.0 makes it full 3D.</para>
        <para>Aside from determining if this AudioSource is heard as a 2D or 3D source, this property is useful to morph between the two modes.3D spatial calculations are applied after stereo panning is determined and can be used in conjunction with panStereo.Morphing between the 2 modes is useful for sounds that should be progressively heard as normal 2D sounds the closer they are to the listener.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.spatialize">
      <summary>
        <para>Enables or disables spatialization.</para>
        <para>Custom spatializer effects improve the realism of sound propagation by incorporating the binaural head-related transfer function (HRTF) such that the listener can better sense the directionality of the sound through the filtering of the head and the micro-delays between the ears. Unity supports custom spatialization effects as optional plugins through the native audio plugin system, and in case such plugins are present, will show a "Spatialize" checkbox on the AudioSource that corresponds to this property. If no plugin is present (and selected in the project audio settings), attempts to set this property to true will fail with a warning.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.spread">
      <summary>
        <para>Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space.</para>
        <para>0 = all sound channels are located at the same speaker location and is 'mono'. 360 = all subchannels are located at the opposite speaker location to the speaker location that it should be according to 3D position. Default = 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.time">
      <summary>
        <para>Playback position in seconds.</para>
        <para>Use this to read current playback time or to seek to a new playback time.Be aware that: On a compressed audio track position does not necessary reflect the actual time in the track Compressed audio is represented as a set of so-called packets. The length of a packet depends on the compression settings and can quite often be 2-3 seconds per packet.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.timeSamples">
      <summary>
        <para>Playback position in PCM samples.</para>
        <para>Use this to read current playback time or to seek to a new playback time in samples, if you want more precise timing than what <see cref="P:UnityEngine.AudioSource.time" /> variable allows.See Also: <see cref="P:UnityEngine.AudioSource.time" /> variable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.velocityUpdateMode">
      <summary>
        <para>Whether the Audio Source should be updated in the fixed or dynamic update.</para>
        <para>Make sure this is set to update in the same update loop as the Audio Source is moved in if you are experiencing problems with Doppler effect simulation for this source. The default setting will automatically set the source to be updated in the fixed update loop if it is attached to a rigidbody, and dynamic otherwise.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AudioSource.volume">
      <summary>The volume of the audio source (0.0 to 1.0).</summary>
    </member>
    <member name="M:UnityEngine.AudioSource.GetCustomCurve(UnityEngine.AudioSourceCurveType)">
      <summary>
        <para>Get the current custom curve for the given AudioSourceCurveType.</para>
        <para>Note that if there is no curve set, or the corresponding curve type value setter has been set, a single key AnimationCurve will be returned corresponding to the current value.</para>
      </summary>
      <param name="type">The curve type to get.</param>
      <returns>The custom AnimationCurve corresponding to the given curve type.</returns>
    </member>
    <member name="M:UnityEngine.AudioSource.GetSpatializerFloat(System.Int32,System.Single@)">
      <summary>
        <para>Reads a user-defined parameter of a custom spatializer effect that is attached to an AudioSource.</para>
        <para>Since this is for internal use in custom inspectors controlling custom spatializer effects implemented as native audio plugins, it is up to the spatializer to perform necessary clipping on the UI and native sides through the setparameter/getparameter callbacks of the native audio plugin.</para>
      </summary>
      <param name="index">Zero-based index of user-defined parameter to be read.</param>
      <param name="value">Return value of the user-defined parameter that is read.</param>
      <returns>True, if the parameter could be read.</returns>
    </member>
    <member name="M:UnityEngine.AudioSource.Pause">
      <summary>Pauses playing the <see cref="P:UnityEngine.AudioSource.clip" />.</summary>
      <seealso cref="M:UnityEngine.AudioSource.Play(System.UInt64)" />
      <seealso cref="M:UnityEngine.AudioSource.Stop" />
    </member>
    <member name="M:UnityEngine.AudioSource.Play(System.UInt64)">
      <summary>
        <para>Plays the <see cref="P:UnityEngine.AudioSource.clip" /> with an optional certain delay.</para>
        <para>The delay parameter is deprecated, please use the newer PlayDelayed function instead which specifies the delay in seconds.Note: To obtain sample accuracy with an <see cref="T:UnityEngine.AudioClip" /> with a different samplerate (than 44.1 khz) you have to do the math yourselves. Delaying an audiosource with an attached <see cref="T:UnityEngine.AudioClip" /> with samplerate of, say, 32 khz, with 16k samples(.5 sec) is done by Play(22050). ((44100/32000) * 16000 = 22050).Note: The <see cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" /> API will give you more accurate control over when the audio clip is played.</para>
      </summary>
      <param name="delay">Delay in number of samples, assuming a 44100Hz sample rate (meaning that Play(44100) will delay the playing by exactly 1 sec).</param>
      <seealso cref="M:UnityEngine.AudioSource.Stop" />
      <seealso cref="M:UnityEngine.AudioSource.Pause" />
      <seealso cref="P:UnityEngine.AudioSource.clip" />
      <seealso cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" />
    </member>
    <member name="M:UnityEngine.AudioSource.Play">
      <summary>
        <para>Plays the <see cref="P:UnityEngine.AudioSource.clip" /> with an optional certain delay.</para>
        <para>The delay parameter is deprecated, please use the newer PlayDelayed function instead which specifies the delay in seconds.Note: To obtain sample accuracy with an <see cref="T:UnityEngine.AudioClip" /> with a different samplerate (than 44.1 khz) you have to do the math yourselves. Delaying an audiosource with an attached <see cref="T:UnityEngine.AudioClip" /> with samplerate of, say, 32 khz, with 16k samples(.5 sec) is done by Play(22050). ((44100/32000) * 16000 = 22050).Note: The <see cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" /> API will give you more accurate control over when the audio clip is played.</para>
      </summary>
      <seealso cref="M:UnityEngine.AudioSource.Stop" />
      <seealso cref="M:UnityEngine.AudioSource.Pause" />
      <seealso cref="P:UnityEngine.AudioSource.clip" />
      <seealso cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" />
    </member>
    <member name="M:UnityEngine.AudioSource.PlayDelayed(System.Single)">
      <summary>
        <para>Plays the <see cref="P:UnityEngine.AudioSource.clip" /> with a delay specified in seconds. Users are advised to use this function instead of the old Play(delay) function that took a delay specified in samples relative to a reference rate of 44.1 kHz as an argument.</para>
        <para>Note: This function replaces the Play(delay) function when called with the delay-argument. In that function the delay had to be specified as samples relative to a reference rate of 44100. This is inconvenient when the engine is running on a different sample rate and the source sound has an even different rate. Working with delays specified in seconds makes this independent of these.</para>
      </summary>
      <param name="delay">Delay time specified in seconds.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.PlayOneShot(UnityEngine.AudioClip,System.Single)">
      <summary>Plays an <see cref="T:UnityEngine.AudioClip" />, and scales the <see cref="T:UnityEngine.AudioSource" /> volume by volumeScale.</summary>
      <param name="clip">The clip being played.</param>
      <param name="volumeScale">The scale of the volume (0-1).</param>
    </member>
    <member name="M:UnityEngine.AudioSource.PlayOneShot(UnityEngine.AudioClip)">
      <summary>Plays an <see cref="T:UnityEngine.AudioClip" />, and scales the <see cref="T:UnityEngine.AudioSource" /> volume by volumeScale.</summary>
      <param name="clip">The clip being played.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.PlayScheduled(System.Double)">
      <summary>
        <para>Plays the <see cref="P:UnityEngine.AudioSource.clip" /> at a specific time on the absolute time-line that AudioSettings.dspTime reads from.</para>
        <para>This is the preferred way to stitch AudioClips in music players because it is independent of the frame rate and gives the audio system enough time to prepare the playback of the sound to fetch it from media where the opening and buffering takes a lot of time (streams) without causing sudden CPU spikes.</para>
        <para>The example at <see cref="M:UnityEngine.AudioSource.SetScheduledEndTime(System.Double)" /> shows how you can play two audio clips without pops or clicks between the clips. The approach is to have two AudioSources with clips attached, and queue up each clip using its AudioSource.See Also: <see cref="M:UnityEngine.AudioSource.SetScheduledStartTime(System.Double)" />.</para>
      </summary>
      <param name="time">Time in seconds on the absolute time-line that AudioSettings.dspTime refers to for when the sound should start playing.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.SetCustomCurve(UnityEngine.AudioSourceCurveType,UnityEngine.AnimationCurve)">
      <summary>
        <para>Set the custom curve for the given AudioSourceCurveType.</para>
        <para>The curve will be scaled so that it is applied over AudioSource.maxDistance from the AudioSource.Note that the internal AnimationCurve to be rescaled to range from 0..1 for performance reasons. This means calling AudioSource.GetCustomCurve will return a potentially different curve to what was just set.</para>
      </summary>
      <param name="type">The curve type that should be set.</param>
      <param name="curve">The curve that should be applied to the given curve type.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.SetScheduledEndTime(System.Double)">
      <summary>
        <para>Changes the time at which a sound that has already been scheduled to play will end. Notice that depending on the timing not all rescheduling requests can be fulfilled.</para>
        <para>Note that the time specified is still a time on the absolute time-line, meaning that the sound will stop when reaching that time, regardless of when it was started. So if you have a 5 second long sound and want it to play at time T and stop after 3 seconds (i.e. silencing the last 2 seconds of the sound), you need to specify the end time to be T+3. This function is useful in music systems to overcome the discontinuities in signals that frame-based lossy codecs cause.</para>
        <para>Note: If possible create clips that overlap, and use the scheduled end time for the first, and <see cref="P:UnityEngine.AudioSource.time" /> for the second to trim out the overlapped part, as the example above shows.</para>
      </summary>
      <param name="time">Time in seconds.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.SetScheduledStartTime(System.Double)">
      <summary>
        <para>Changes the time at which a sound that has already been scheduled to play will start.</para>
        <para>Notice that depending on the timing not all rescheduling requests can be fulfilled.One interesting use case for this is stinger sound effects that are initiated by game events, but that you also want to be synchronized to specific beats in music. Then this function can be used to defer the stinger until the next musical transition.Note: In general it is better to use <see cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" /> to cue up audio. Only use SetScheduledStartTime if you have scheduled an audio clip to play in the future and you need to change the time at which it starts. Calling SetScheduledStartTime will not cause an un-scheduled audio clip to play.See Also: <see cref="M:UnityEngine.AudioSource.PlayScheduled(System.Double)" />.</para>
      </summary>
      <param name="time">Time in seconds.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.SetSpatializerFloat(System.Int32,System.Single)">
      <summary>
        <para>Sets a user-defined parameter of a custom spatializer effect that is attached to an AudioSource.</para>
        <para>Since this is for internal use in custom inspectors controlling custom spatializer effects implemented as native audio plugins, it is up to the spatializer to perform necessary clipping on the UI and native sides through the setparameter/getparameter callbacks of the native audio plugin.</para>
      </summary>
      <param name="index">Zero-based index of user-defined parameter to be set.</param>
      <param name="value">New value of the user-defined parameter.</param>
      <returns>True, if the parameter could be set.</returns>
    </member>
    <member name="M:UnityEngine.AudioSource.Stop">
      <summary>Stops playing the <see cref="P:UnityEngine.AudioSource.clip" />.</summary>
      <seealso cref="M:UnityEngine.AudioSource.Play(System.UInt64)" />
      <seealso cref="M:UnityEngine.AudioSource.Pause" />
    </member>
    <member name="M:UnityEngine.AudioSource.UnPause">
      <summary>
        <para>Unpause the paused playback of this AudioSource.</para>
        <para>This function is similar to calling Play () on a paused AudioSource, except that it will not create a new playback voice if it is not currently paused.This is also useful if you have paused one-shots and want to resume playback without creating a new playback voice for the attached AudioClip.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AudioSource.PlayClipAtPoint(UnityEngine.AudioClip,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Plays an AudioClip at a given position in world space.</para>
        <para>This function creates an audio source but automatically disposes of it once the clip has finished playing.</para>
      </summary>
      <param name="clip">Audio data to play.</param>
      <param name="position">Position in world space from which sound originates.</param>
      <param name="volume">Playback volume.</param>
    </member>
    <member name="M:UnityEngine.AudioSource.PlayClipAtPoint(UnityEngine.AudioClip,UnityEngine.Vector3)">
      <summary>
        <para>Plays an AudioClip at a given position in world space.</para>
        <para>This function creates an audio source but automatically disposes of it once the clip has finished playing.</para>
      </summary>
      <param name="clip">Audio data to play.</param>
      <param name="position">Position in world space from which sound originates.</param>
    </member>
    <member name="P:UnityEngine.Avatar.isHuman">
      <summary>Return true if this avatar is a valid human avatar.</summary>
    </member>
    <member name="P:UnityEngine.Avatar.isValid">
      <summary>Return true if this avatar is a valid mecanim avatar. It can be a generic avatar or a human avatar.</summary>
    </member>
    <member name="M:UnityEngine.AvatarBuilder.BuildGenericAvatar(UnityEngine.GameObject,System.String)">
      <summary>
        <para>Create a new generic avatar.</para>
        <para>All transforms under the root game object will be part of this generic avatar.</para>
      </summary>
      <param name="go">Root object of your transform hierarchy.</param>
      <param name="rootMotionTransformName">Transform name of the root motion transform. If empty no root motion is defined and you must take care of avatar movement yourself.</param>
    </member>
    <member name="M:UnityEngine.AvatarBuilder.BuildHumanAvatar(UnityEngine.GameObject,UnityEngine.HumanDescription)">
      <summary>
        <para>Create a humanoid avatar.</para>
        <para>The avatar is created using the supplied HumanDescription object which specifies the muscle space range limits and retargeting parameters like arm/leg twist and arm/leg stretch.See Also: HumanDescription.</para>
      </summary>
      <param name="go">Root object of your transform hierachy.</param>
      <param name="monoHumanDescription">Description of the avatar.</param>
    </member>
    <member name="P:UnityEngine.Behaviour.enabled">
      <summary>
        <para>Enabled Behaviours are Updated, disabled Behaviours are not.</para>
        <para>This is shown as the small checkbox in the inspector of the behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Behaviour.isActiveAndEnabled">
      <summary>
        <para>Has the Behaviour had enabled called.</para>
        <para>True while the behaviour is enabled, false when disabled.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.bottom">
      <summary>Height of the billboard that is below ground.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.height">
      <summary>Height of the billboard.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.imageCount">
      <summary>Number of pre-baked images that can be switched when the billboard is viewed from different angles.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.indexCount">
      <summary>Number of indices in the billboard mesh. The mesh is not necessarily a quad. It can be a more complex shape which fits the actual image more precisely.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.material">
      <summary>The material used for rendering.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.vertexCount">
      <summary>Number of vertices in the billboard mesh. The mesh is not necessarily a quad. It can be a more complex shape which fits the actual image more precisely.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.width">
      <summary>Width of the billboard.</summary>
    </member>
    <member name="M:UnityEngine.BillboardAsset.#ctor">
      <summary>Constructs a new BillboardAsset.</summary>
    </member>
    <member name="P:UnityEngine.BillboardRenderer.billboard">
      <summary>The BillboardAsset to render.</summary>
    </member>
    <member name="M:UnityEngine.BillboardRenderer.#ctor">
      <summary>Constructor.</summary>
    </member>
    <member name="P:UnityEngine.BitStream.isReading">
      <summary>Is the BitStream currently being read? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.BitStream.isWriting">
      <summary>Is the BitStream currently being written? (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Boolean@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Char@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Int16@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Int32@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Single@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Single@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Quaternion@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Quaternion@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Vector3@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Vector3@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.NetworkPlayer@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.NetworkViewID@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="T:UnityEngine.Quaternion" />, <see cref="T:UnityEngine.Vector3" /> and <see cref="T:UnityEngine.NetworkPlayer" />.Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex0">
      <summary>Index of first bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex1">
      <summary>Index of second bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex2">
      <summary>Index of third bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex3">
      <summary>Index of fourth bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight0">
      <summary>Skinning weight for first bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight1">
      <summary>Skinning weight for second bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight2">
      <summary>Skinning weight for third bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight3">
      <summary>Skinning weight for fourth bone.</summary>
    </member>
    <member name="F:UnityEngine.BoundingSphere.position">
      <summary>The position of the center of the <see cref="T:UnityEngine.BoundingSphere" />.</summary>
    </member>
    <member name="F:UnityEngine.BoundingSphere.radius">
      <summary>The radius of the <see cref="T:UnityEngine.BoundingSphere" />.</summary>
    </member>
    <member name="M:UnityEngine.BoundingSphere.#ctor(UnityEngine.Vector3,System.Single)">
      <summary>Initializes a BoundingSphere.</summary>
      <param name="pos">The center of the sphere.</param>
      <param name="rad">The radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.BoundingSphere.#ctor(UnityEngine.Vector4)">
      <summary>Initializes a BoundingSphere.</summary>
      <param name="packedSphere">A four-component vector containing the position (packed into the XYZ components) and radius (packed into the W component).</param>
    </member>
    <member name="P:UnityEngine.Bounds.center">
      <summary>The center of the bounding box.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.extents">
      <summary>The extents of the box. This is always half of the <see cref="P:UnityEngine.Bounds.size" />.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.max">
      <summary>The maximal point of the box. This is always equal to <c>center+extents</c>.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.min">
      <summary>The minimal point of the box. This is always equal to <c>center-extents</c>.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.size">
      <summary>
        <para>The total size of the box. This is always twice as large as the <see cref="P:UnityEngine.Bounds.extents" />.</para>
        <para>
          <c>size.x</c> is the width, <c>size.y</c> is the height and <c>size.z</c> is the depth of the box.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.#ctor(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Creates new Bounds with a given <c>center</c> and total <c>size</c>. Bound <see cref="P:UnityEngine.Bounds.extents" /> will be half the given size.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.ClosestPoint(UnityEngine.Vector3)">
      <summary>
        <para>The closest point on the bounding box.</para>
        <para>If the point is inside the bounding box, unmodified point position will be returned.</para>
      </summary>
      <param name="point">Arbitrary point.</param>
      <returns>The point on the bounding box or inside the bounding box.</returns>
    </member>
    <member name="M:UnityEngine.Bounds.Contains(UnityEngine.Vector3)">
      <summary>Is <c>point</c> contained in the bounding box?</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Encapsulate(UnityEngine.Vector3)">
      <summary>Grows the Bounds to include the <c>point</c>.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Encapsulate(UnityEngine.Bounds)">
      <summary>Grow the bounds to encapsulate the bounds.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Expand(System.Single)">
      <summary>Expand the bounds by increasing its <c>size</c> by <c>amount</c> along each side.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Expand(UnityEngine.Vector3)">
      <summary>Expand the bounds by increasing its <c>size</c> by <c>amount</c> along each side.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.IntersectRay(UnityEngine.Ray)">
      <summary>Does <c>ray</c> intersect this bounding box?</summary>
    </member>
    <member name="M:UnityEngine.Bounds.IntersectRay(UnityEngine.Ray,System.Single@)">
      <summary>
        <para>Does <c>ray</c> intersect this bounding box?</para>
        <para>When the function returns true, the distance to the ray's origin will be returned in the <c>distance</c> parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.Intersects(UnityEngine.Bounds)">
      <summary>Does another bounding box intersect with this bounding box?</summary>
    </member>
    <member name="M:UnityEngine.Bounds.SetMinMax(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Sets the bounds to the <c>min</c> and <c>max</c> value of the box.</para>
        <para>Using this function is faster than assigning <c>min</c> and <c>max</c> separately.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.SqrDistance(UnityEngine.Vector3)">
      <summary>The smallest squared distance between the point and this bounding box.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.ToString">
      <summary>Returns a nicely formatted string for the bounds.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.ToString(System.String)">
      <summary>Returns a nicely formatted string for the bounds.</summary>
    </member>
    <member name="P:UnityEngine.BoxCollider.center">
      <summary>The center of the box, measured in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.BoxCollider.size">
      <summary>
        <para>The size of the box, measured in the object's local space.</para>
        <para>The box size will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoxCollider2D.size">
      <summary>
        <para>The width and height of the rectangle.</para>
        <para>The X coordinate of the vector represents the width while the Y represents the height. These values are specified relative to a center point, so the distance from the center to the left edge is actually width/2.See Also: <see href="BoxCollider2D-center" cref="center" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.enabled">
      <summary>
        <para>Is Caching enabled?</para>
        <para>WebPlayer users may disable Caching for all WebPlayer applications by right-clicking on the WebPlayer content, selecting "Setup...", and checking the 'Disable all caching' checkbox. If caching is disabled, WWW.LoadFromCacheOrDownload() will continue to function, but will never cache downloaded AssetBundles. Caching is always enabled for PC/Mac Standalone and iOS/Android player builds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.expirationDelay">
      <summary>
        <para>The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted.</para>
        <para>This value defaults to 150 days (12,960,000 seconds). Lower values will cause the cache to be cleaned more aggressively in order to minimize disk storage usage. The delay cannot be set greater than 12,960,000 seconds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.maximumAvailableDiskSpace">
      <summary>
        <para>The total number of bytes that can potentially be allocated for caching.</para>
        <para>This value can be set to a smaller number in order to limit the amount of disk space used by cached AssetBundles. The WebPlayer shared cache allows up to 50 MiB of cached AssetBundles. PC/Mac Standalone applications and iOS/Android applications have a limit of 4 GiB. WebPlayer applications that make use of a dedicated cache are limited to the number of bytes specified in the Caching license agreement. This property does not account for total available disk space. If a user's computer has less available disk space on the drive where the cache is located than maximumAvailableDiskSpace, the full amount of maximumAvailableDiskSpace will not be usable. Cache storage is allocated on an as-needed basis in order to minimize disk space usage.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.ready">
      <summary>Is caching ready?</summary>
    </member>
    <member name="P:UnityEngine.Caching.spaceFree">
      <summary>
        <para>The number of currently unused bytes in the cache.</para>
        <para>When the cache is empty, this value equals maximumAvailableDiskSpace. As AssetBundles are stored in the cache, this value will decrease. Caching manages cached content based on a Least Recently Used (LRU) algorithm. If insufficient space is available in the cache to store a requested AssetBundle, the oldest AssetBundles in the cache will be iteratively removed until enough space is free for the new AssetBundle. This property does not account for total available disk space. If a user's computer has less available disk space on the drive where the cache is located than spaceFree, the full amount of spaceFree will not be usable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.spaceOccupied">
      <summary>
        <para>Used disk space in bytes.</para>
        <para>Initially this is 0. As you download files to the cache, this will increment. If insufficient space is available in the cache to store a requested AssetBundle, the least-recently-used AssetBundles in the cache will be iteratively removed until enough space is available for the new AssetBundle.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.Authorize(System.String,System.String,System.Int64,System.String)">
      <summary>
        <para>(This is a WebPlayer-only function).</para>
        <para>Enables a dedicated, application-specific WebPlayer cache (Dedicated WebPlayer caches require a paid license from Unity Technologies). If you have a dedicated cache license, call this function at WebPlayer application startup with the license information provided to you. Starting with the release of Unity 3.2, all WebPlayer applications have access to a 50 MiB shared cache; calling the Authorize() function is not necessary. Starting with the release of Unity 3.4, PC/Mac Standalone players and iOS/Android players have access to a 4 GiB dedicated cache for each application; calling the Authorize() function is not necessary.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.Authorize(System.String,System.String,System.Int64,System.Int32,System.String)">
      <summary>
        <para>(This is a WebPlayer-only function).</para>
        <para>Enables a dedicated, application-specific WebPlayer cache (Dedicated WebPlayer caches require a paid license from Unity Technologies). If you have a dedicated cache license, call this function at WebPlayer application startup with the license information provided to you. Starting with the release of Unity 3.2, all WebPlayer applications have access to a 50 MiB shared cache; calling the Authorize() function is not necessary. Starting with the release of Unity 3.4, PC/Mac Standalone players and iOS/Android players have access to a 4 GiB dedicated cache for each application; calling the Authorize() function is not necessary.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.CleanCache">
      <summary>
        <para>Delete all AssetBundle and Procedural Material content that has been cached by the current application.</para>
        <para>This function is not available to WebPlayer applications that use the shared cache.See Also: Downloading Asset Bundles, Procedural Materials Caching.</para>
      </summary>
      <returns>True when cache cleaning succeeded, false if cache was in use.</returns>
    </member>
    <member name="M:UnityEngine.Caching.IsVersionCached(System.String,System.Int32)">
      <summary>
        <para>Checks if an AssetBundle is cached.</para>
        <para>When using the default shared cache, the URL of the WebPlayer application bundle is automatically prepended to the <c>url</c> parameter; this prevents filename collisions with identically-named AssetBundles used by other developers' WebPlayer applications. WebPlayer applications that use a dedicated cache do not experience this behavior. This function can be utilized to enable AssetBundle preloading. First, call Caching.IsVersionCached() to see if the current version of an AssetBundle is already cached. If the AssetBundle is not cached, it can be preloaded in the background so that it is immediately available for loading into memory when requested.</para>
      </summary>
      <returns>True if an AssetBundle matching the <c>url</c> and <c>version</c> parameters has previously been loaded using WWW.LoadFromCacheOrDownload() and is currently stored in the cache. Returns false if the AssetBundle is not in cache, either because it has been flushed from the cache or was never loaded using the Caching API.</returns>
    </member>
    <member name="M:UnityEngine.Caching.MarkAsUsed(System.String,System.Int32)">
      <summary>
        <para>Bumps the timestamp of a cached file to be the current time.</para>
        <para>This allows you to keep files in the cache even if you are not explicitly loading them. Returns true if the url is cached.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.allCameras">
      <summary>Returns all enabled cameras in the scene.</summary>
    </member>
    <member name="P:UnityEngine.Camera.allCamerasCount">
      <summary>
        <para>The number of cameras in the current scene.</para>
        <para>Returns the size of the array that Camera.allCameras returns and the amount of cameras that Camera.GetAllCameras will fill.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.current">
      <summary>
        <para>The camera we are currently rendering with, for low-level render control only (Read Only).</para>
        <para>Most of the time you will want to use Camera.main instead. Use this function only when implementing one of the following events: MonoBehaviour.OnRenderImage, MonoBehaviour.OnPreRender, MonoBehaviour.OnPostRender.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.main">
      <summary>
        <para>The first enabled camera tagged "MainCamera" (Read Only).</para>
        <para>Returns <c>null</c> if there is no such camera in the scene.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Camera.onPostRender">
      <summary>Event that is fired after any camera finishes rendering.</summary>
    </member>
    <member name="F:UnityEngine.Camera.onPreCull">
      <summary>Event that is fired before any camera starts culling.</summary>
    </member>
    <member name="F:UnityEngine.Camera.onPreRender">
      <summary>
        <para>Event that is fired before any camera starts rendering.</para>
        <para>Note that when onPreRender is called, the camera's render target is not set up yet, and the depth texture(s) are not rendered yet either. If you want to do something later on (when the render target is already set), try using a <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.actualRenderingPath">
      <summary>Actually used rendering path (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.aspect">
      <summary>
        <para>The aspect ratio (width divided by height).</para>
        <para>By default the aspect ratio is automatically calculated from the screen's aspect ratio, even if the camera is not rendering to full area. If you modify the <c>aspect</c> ratio of the camera, the value will stay until you call camera.ResetAspect(); which resets the aspect to the screen's aspect ratio.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.backgroundColor">
      <summary>
        <para>The color with which the screen will be cleared.</para>
        <para>Only used if <see cref="P:UnityEngine.Camera.clearFlags" /> are set to CameraClearFlags.SolidColor (or CameraClearFlags.Skybox but the skybox is not set up).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.cameraToWorldMatrix">
      <summary>
        <para>Matrix that transforms from camera space to world space (Read Only).</para>
        <para>Use this to calculate where in the world a specific camera space point is.Note that camera space matches OpenGL convention: camera's forward is the negative Z axis. This is different from Unity's convention, where forward is the positive Z axis.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.cameraType">
      <summary>Identifies what kind of camera this is.</summary>
    </member>
    <member name="P:UnityEngine.Camera.clearFlags">
      <summary>
        <para>How the camera clears the background.</para>
        <para>Can be CameraClearFlags.Skybox, CameraClearFlags.SolidColor, CameraClearFlags.Depth or CameraClearFlags.Nothing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.clearStencilAfterLightingPass">
      <summary>
        <para>Should the camera clear the stencil buffer after the deferred light pass?</para>
        <para>When using Deferred Shading or Legacy Deferred Lighting, the g-buffer and lighting passes use the stencil buffer. By default contents of the stencil buffer are preserved (not cleared) and end up containing information related to lights. Setting this property to <c>true</c> makes stencil be cleared to zero after the deferred light pass is done.Typically if you're using deferred shading camera and UI elements with Masks (see <see cref="T:UnityEngine.UI.Mask" />), you'll want the stencil buffer to be cleared.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.commandBufferCount">
      <summary>Number of command buffers set up on this camera (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.cullingMask">
      <summary>
        <para>This is used to render parts of the scene selectively.</para>
        <para>If the <see cref="T:UnityEngine.GameObject" />'s <c>layerMask</c> AND the camera's <c>cullingMask</c> is zero then the game object will be invisible from this camera.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.depth">
      <summary>
        <para>Camera's depth in the camera rendering order.</para>
        <para>Cameras with lower depth are rendered before cameras with higher depth.Use this to control the order in which cameras are drawn if you have multiple cameras and some of them don't cover the full screen.See Also: camera component, <see cref="P:UnityEngine.Camera.rect" /></para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.depthTextureMode">
      <summary>
        <para>How and if camera generates a depth texture.</para>
        <para>A camera can build a screen-space depth texture. This is mostly useful for image post-processing effects. Note that generating the texture incurs a performance cost.See Also: Using camera's depth textures, <see cref="T:UnityEngine.DepthTextureMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.eventMask">
      <summary>
        <para>Mask to select which layers can trigger events on the camera.</para>
        <para>Just as the camera's <c>cullingMask</c> determines if the camera is able to see the <see cref="T:UnityEngine.GameObject" />, the event mask determines whether the <see cref="T:UnityEngine.GameObject" /> is able to receive mouse events. Only objects visible by the camera and whose <c>layerMask</c> overlaps with the camera's <c>eventMask</c> will be able to receive OnMouseXXX events. Setting this mask to zero will improve performance and is recommended if you don't use OnMouseXXX events.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.farClipPlane">
      <summary>The far clipping plane distance.</summary>
    </member>
    <member name="P:UnityEngine.Camera.fieldOfView">
      <summary>
        <para>The field of view of the camera in degrees.</para>
        <para>This is the vertical field of view; horizontal FOV varies depending on the viewport's aspect ratio. Field of view is ignored when camera is orthographic (see <see cref="P:UnityEngine.Camera.orthographic" />).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.hdr">
      <summary>
        <para>High dynamic range rendering.</para>
        <para>Should this camera use HDR rendering?</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.layerCullDistances">
      <summary>
        <para>Per-layer culling distances.</para>
        <para>Normally Camera skips rendering of objects that are further away than <see cref="P:UnityEngine.Camera.farClipPlane" />. You can set up some Layers to use smaller culling distances using layerCullDistances. This is very useful to cull small objects early on, if you put them into appropriate layers.When assigning layerCullDistances, you need to assign float array that has 32 values. Zero values in cull distances means "use far plane distance".By default, per-layer culling will use a plane aligned with the camera. You can change this to a sphere by setting layerCullSpherical on the Camera to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.layerCullSpherical">
      <summary>
        <para>How to perform per-layer culling for a Camera.</para>
        <para>Normally this type of culling is performed by moving the Camera's far plane closer to the eye. By setting this value to true, the culling is instead based on spherical distance. The benefit is that rotating on the same spot does not affect which objects are visible.See Also: <see cref="P:UnityEngine.Camera.layerCullDistances" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.nearClipPlane">
      <summary>The near clipping plane distance.</summary>
    </member>
    <member name="P:UnityEngine.Camera.opaqueSortMode">
      <summary>
        <para>Opaque object sorting mode.</para>
        <para>Opaque objects are sorted by various criteria (sorting layers, shader queues, materials, distance, lightmaps etc.) to maximize both the CPU efficiency (reduce number of state changes and improve draw call batching), and to maximize GPU efficiency (many GPUs prefer rough front-to-back rendering order for faster rejection of invisible surfaces).By default, opaque objects are grouped in rough front-to-back buckets, on the GPUs where doing that is beneficial. There are GPUs where doing this distance based sorting is not really helpful (most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default.The <see cref="P:UnityEngine.Camera.opaqueSortMode" /> property lets you override this default behavior. For example, you might want to never do distance-based sorting for opaque objects, if you know you need much more CPU performance than GPU performance.See Also: <see cref="T:UnityEngine.Rendering.OpaqueSortMode" /> enum, <see cref="P:UnityEngine.Camera.transparencySortMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.orthographic">
      <summary>
        <para>Is the camera orthographic (<c>true</c>) or perspective (<c>false</c>)?</para>
        <para>When ortho is <c>true</c>, camera's viewing volume is defined by <see cref="P:UnityEngine.Camera.orthographicSize" />. When orthographic is <c>false</c>, camera's viewing volume is defined by <see cref="P:UnityEngine.Camera.fieldOfView" />.See Also: camera component, <see cref="P:UnityEngine.Camera.transparencySortMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.orthographicSize">
      <summary>
        <para>Camera's half-size when in orthographic mode.</para>
        <para>This is half of the vertical size of the viewing volume. Horizontal viewing size varies depending on viewport's aspect ratio. Orthographic size is ignored when camera is not orthographic (see <see cref="P:UnityEngine.Camera.orthographic" />).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelHeight">
      <summary>How tall is the camera in pixels (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelRect">
      <summary>Where on the screen is the camera rendered in pixel coordinates.</summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelWidth">
      <summary>How wide is the camera in pixels (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.projectionMatrix">
      <summary>
        <para>Set a custom projection matrix.</para>
        <para>If you change this matrix, the camera no longer updates its rendering based on its <see cref="P:UnityEngine.Camera.fieldOfView" />. This lasts until you call <see cref="M:UnityEngine.Camera.ResetProjectionMatrix" />.Use a custom projection only if you really need a non-standard projection. This property is used by Unity's water rendering to setup an <c>oblique projection</c> matrix. Using custom projections requires good knowledge of transformation and projection matrices.Note that projection matrix passed to shaders can be modified depending on platform and other state. If you need to calculate projection matrix for shader use from camera's projection, use <see cref="M:UnityEngine.GL.GetGPUProjectionMatrix(UnityEngine.Matrix4x4,System.Boolean)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.rect">
      <summary>
        <para>Where on the screen is the camera rendered in normalized coordinates.</para>
        <para>The values in <c>rect</c> range from zero (left/bottom) to one (right/top).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.renderingPath">
      <summary>Rendering path.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoConvergence">
      <summary>Distance to a point where virtual eyes converge.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoEnabled">
      <summary>
        <para>Stereoscopic rendering.</para>
        <para>Is this camera rendering from two virtual eye-points to a stereoscopic output?</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoMirrorMode">
      <summary>Render only once and use resulting image for both eyes.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoSeparation">
      <summary>Distance between the virtual eyes.</summary>
    </member>
    <member name="P:UnityEngine.Camera.targetDisplay">
      <summary>
        <para>Set the target display for this Camera.</para>
        <para>This setting redirects the Camera Render to a secondary display. Maximum number of secondary displays (eg. Monitors) supported is 8.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.targetTexture">
      <summary>
        <para>Destination render texture.</para>
        <para>Usually cameras render directly to screen, but for some effects it is useful to make a camera render into a texture. This is done by creating a <see cref="T:UnityEngine.RenderTexture" /> object and setting it as <see cref="P:UnityEngine.Camera.targetTexture" /> on the camera. The camera will then render into that texture.When targetTexture is <c>null</c>, camera renders to screen.When rendering into a texture, the camera always renders into the whole texture; effectively <see cref="P:UnityEngine.Camera.rect" /> and <see cref="P:UnityEngine.Camera.pixelRect" /> are ignored.It is also possible to make camera render into separate <see cref="T:UnityEngine.RenderBuffer" />, or into multiple textures at once, using <see cref="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)" /> function.See Also:: <see cref="T:UnityEngine.RenderTexture" />, <see cref="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.transparencySortMode">
      <summary>
        <para>Transparent object sorting mode.</para>
        <para>By default, perspective cameras sort objects based on distance from camera position to the object center; and orthographic cameras sort based on distance along the view direction.If you're making a 2D game with a perspective camera, you might want to use <see cref="F:UnityEngine.TransparencySortMode.Orthographic" /> sort mode so that objects are sorted based on distance along the camera's view.See Also: <see cref="T:UnityEngine.TransparencySortMode" /> enum, <see cref="P:UnityEngine.Camera.opaqueSortMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.useOcclusionCulling">
      <summary>Whether or not the Camera will use occlusion culling during rendering.</summary>
    </member>
    <member name="P:UnityEngine.Camera.velocity">
      <summary>
        <para>Get the world-space speed of the camera (Read Only).</para>
        <para>This camera's motion in units per second as it was during the last frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.worldToCameraMatrix">
      <summary>
        <para>Matrix that transforms from world to camera space.</para>
        <para>Use this to calculate the camera space position of objects or to provide custom camera's location that is not based on the transform.Note that camera space matches OpenGL convention: camera's forward is the negative Z axis. This is different from Unity's convention, where forward is the positive Z axis.If you change this matrix, the camera no longer updates its rendering based on its <see cref="T:UnityEngine.Transform" />. This lasts until you call <see cref="M:UnityEngine.Camera.ResetWorldToCameraMatrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Add a command buffer to be executed at a specified place.</para>
        <para>Multiple command buffers can be set to execute at the same camera event (or even the same buffer can be added multiple times). To remove command buffer from execution, use <see cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
    </member>
    <member name="M:UnityEngine.Camera.CalculateObliqueMatrix(UnityEngine.Vector4)">
      <summary>
        <para>Calculates and returns oblique near-plane projection matrix.</para>
        <para>Given a clip plane vector, this function returns camera's projection matrix which has this clip plane set as its near plane.</para>
      </summary>
      <param name="clipPlane">Vector4 that describes a clip plane.</param>
      <returns>Oblique near-plane projection matrix.</returns>
    </member>
    <member name="M:UnityEngine.Camera.CopyFrom(UnityEngine.Camera)">
      <summary>
        <para>Makes this camera's settings match other camera.</para>
        <para>This will copy all camera's variables (field of view, clear flags, culling mask, ...) from the <c>other/</c> camera. It will also set this camera's transform to match the other camera, as well as this camera's layer to match the layer of the other camera.This can be useful if you want one camera to match the other camera's setup, when doing custom rendering effects. For example when using <see cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      <summary>Get command buffers to be executed at a specified place.</summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <returns>Array of command buffers.</returns>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer" />
      <seealso cref="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />
    </member>
    <member name="M:UnityEngine.Camera.RemoveAllCommandBuffers">
      <summary>Remove all command buffers set on this camera.</summary>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer" />
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)" />
    </member>
    <member name="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Remove command buffer from execution at a specified place.</para>
        <para>If the same buffer is added multiple times on this camera event, all occurrences of it will be removed.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)" />, <see cref="M:UnityEngine.Camera.RemoveAllCommandBuffers" />, <see cref="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
    </member>
    <member name="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      <summary>
        <para>Remove command buffers from execution at a specified place.</para>
        <para>This function removes all command buffers set on the specified camera event.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Camera.RemoveAllCommandBuffers" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
    </member>
    <member name="M:UnityEngine.Camera.Render">
      <summary>
        <para>Render the camera manually.</para>
        <para>This will render the camera. It will use the camera's clear flags, target texture and all other settings.The camera will send <c>OnPreCull</c>, <c>OnPreRender</c> and <c>OnPostRender</c> to any scripts attached, and render any eventual image filters.This is used for taking precise control of render order. To make use of this feature, create a camera and disable it. Then call Render on it.You are not able to call the Render function from a camera that is currently rendering. If you wish to do this create a copy of the camera, and make it match the original one using <see cref="M:UnityEngine.Camera.CopyFrom(UnityEngine.Camera)" />.See Also: <see cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.Cubemap,System.Int32)">
      <summary>
        <para>Render into a static cubemap from this camera.</para>
        <para>This function is mostly useful in the editor for "baking" static cubemaps of your scene. See wizard example below. If you want a realtime-updated cubemap, use RenderToCubemap variant that uses a RenderTexture with <see cref="P:UnityEngine.RenderTexture.isCubemap" /> flag, see below.Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="T:UnityEngine.CubemapFace" /> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on).This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality.Note also that ReflectionProbes are a more advanced way of performing realtime reflections. Cubemaps can be created in the editor by selecting the Create-&gt;Legacy option.See Also: Cubemap assets, Reflective shaders.</para>
      </summary>
      <param name="cubemap">The cube map to render to.</param>
      <param name="faceMask">A bitmask which determines which of the six faces are rendered to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.Cubemap)">
      <summary>
        <para>Render into a static cubemap from this camera.</para>
        <para>This function is mostly useful in the editor for "baking" static cubemaps of your scene. See wizard example below. If you want a realtime-updated cubemap, use RenderToCubemap variant that uses a RenderTexture with <see cref="P:UnityEngine.RenderTexture.isCubemap" /> flag, see below.Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="T:UnityEngine.CubemapFace" /> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on).This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality.Note also that ReflectionProbes are a more advanced way of performing realtime reflections. Cubemaps can be created in the editor by selecting the Create-&gt;Legacy option.See Also: Cubemap assets, Reflective shaders.</para>
      </summary>
      <param name="cubemap">The cube map to render to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.RenderTexture,System.Int32)">
      <summary>
        <para>Render into a cubemap from this camera.</para>
        <para>This is used for real-time reflections into cubemap render textures. It can be quite expensive though, especially if all six cubemap faces are rendered each frame.The Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="T:UnityEngine.CubemapFace" /> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on).This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality.Note that the RenderTexture must have isCubemap set to true. This is illustrated in the example following.See Also: RenderTexture.isCubemap, Reflective shaders.</para>
      </summary>
      <param name="cubemap">The texture to render to.</param>
      <param name="faceMask">A bitfield indicating which cubemap faces should be rendered into.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.RenderTexture)">
      <summary>
        <para>Render into a cubemap from this camera.</para>
        <para>This is used for real-time reflections into cubemap render textures. It can be quite expensive though, especially if all six cubemap faces are rendered each frame.The Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="T:UnityEngine.CubemapFace" /> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on).This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality.Note that the RenderTexture must have isCubemap set to true. This is illustrated in the example following.See Also: RenderTexture.isCubemap, Reflective shaders.</para>
      </summary>
      <param name="cubemap">The texture to render to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)">
      <summary>
        <para>Render the camera with shader replacement.</para>
        <para>It will use the camera's clear flags, target texture and all other settings.The camera will not send <c>OnPreCull</c>, <c>OnPreRender</c> or <c>OnPostRender</c> to attached scripts. Image filters will not be rendered either.This is used for special effects, e.g. rendering screenspace normal buffer of the whole scene, heat vision and so on. To make use of this feature, usually you create a camera and disable it. Then call RenderWithShader on it.You are not able to call the Render function from a camera that is currently rendering. If you wish to do this create a copy of the camera, and make it match the original one using <see cref="M:UnityEngine.Camera.CopyFrom(UnityEngine.Camera)" />.See Also: Rendering with Replaced Shaders, <see cref="M:UnityEngine.Camera.SetReplacementShader(UnityEngine.Shader,System.String)" />, <see cref="M:UnityEngine.Camera.Render" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetAspect">
      <summary>
        <para>Revert the aspect ratio to the screen's aspect ratio.</para>
        <para>Call this to end the effect of setting <see cref="P:UnityEngine.Camera.aspect" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetProjectionMatrix">
      <summary>
        <para>Make the projection reflect normal camera's parameters.</para>
        <para>Call this to end the effect of setting <see cref="P:UnityEngine.Camera.projectionMatrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetReplacementShader">
      <summary>
        <para>Remove shader replacement from camera.</para>
        <para>Call this to end the effect of setting <see cref="M:UnityEngine.Camera.SetReplacementShader(UnityEngine.Shader,System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetWorldToCameraMatrix">
      <summary>
        <para>Make the rendering position reflect the camera's position in the scene.</para>
        <para>Call this to end the effect of setting <see cref="P:UnityEngine.Camera.worldToCameraMatrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenPointToRay(UnityEngine.Vector3)">
      <summary>
        <para>Returns a ray going from camera through a screen point.</para>
        <para>Resulting ray is in world space, starting on the near plane of the camera and going through position's (x,y) pixel coordinates on the screen (position.z is ignored).Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenToViewportPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from screen space into viewport space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />). The z position is in world units from the camera.Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenToWorldPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from screen space into world space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.SetReplacementShader(UnityEngine.Shader,System.String)">
      <summary>
        <para>Make the camera render with shader replacement.</para>
        <para>Call <see cref="M:UnityEngine.Camera.ResetReplacementShader" /> to reset it back to normal rendering.See Also: Rendering with Replaced Shaders, <see cref="M:UnityEngine.Camera.ResetReplacementShader" />, <see cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)">
      <summary>Sets the Camera to render to the chosen buffers of one or more RenderTextures.</summary>
      <param name="colorBuffer">The RenderBuffer(s) to which color information will be rendered.</param>
      <param name="depthBuffer">The RenderBuffer to which depth information will be rendered.</param>
      <seealso cref="T:UnityEngine.RenderBuffer" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Camera.targetTexture" />
    </member>
    <member name="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer)">
      <summary>Sets the Camera to render to the chosen buffers of one or more RenderTextures.</summary>
      <param name="colorBuffer">The RenderBuffer(s) to which color information will be rendered.</param>
      <param name="depthBuffer">The RenderBuffer to which depth information will be rendered.</param>
      <seealso cref="T:UnityEngine.RenderBuffer" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Camera.targetTexture" />
    </member>
    <member name="M:UnityEngine.Camera.ViewportPointToRay(UnityEngine.Vector3)">
      <summary>
        <para>Returns a ray going from camera through a viewport point.</para>
        <para>Resulting ray is in world space, starting on the near plane of the camera and going through position's (x,y) coordinates on the viewport (position.z is ignored).Viewport coordinates are normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ViewportToScreenPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from viewport space into screen space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ViewportToWorldPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from viewport space into world space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.Note that it transforms a x-y screen position, into a x-y-z position in 3D space. You provide the function with a vector where the x-y components of the vector are the screen coordinates and the z component is the distance of the resulting plane from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.WorldToScreenPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space into screen space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="P:UnityEngine.Camera.pixelWidth" />,<see cref="P:UnityEngine.Camera.pixelHeight" />). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.WorldToViewportPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space into viewport space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.GetAllCameras(UnityEngine.Camera[])">
      <summary>
        <para>Fills an array of Camera with the current cameras in the scene, without allocating a new array.</para>
        <para>The passed in array needs to be of minimum size of what allCamerasCount .When the array size is larger than the allCamerasCount value, only the first elements up to allCamerasCount will be filled up.When the array size is smaller than the allCamerasCount value, an argument exception is thrown.When the array argument passed in is null, this call will throw a nullreference exception.The return value will indicate how many cameras where put into the array.</para>
      </summary>
      <param name="cameras">An array to be filled up with cameras currently in the scene.</param>
    </member>
    <member name="P:UnityEngine.Canvas.cachedSortingLayerValue">
      <summary>Cached calculated value based upon SortingLayerID.</summary>
    </member>
    <member name="P:UnityEngine.Canvas.isRootCanvas">
      <summary>Is this the root <see cref="T:UnityEngine.Canvas" />?</summary>
    </member>
    <member name="P:UnityEngine.Canvas.overridePixelPerfect">
      <summary>Allows for nested canvases to override pixelPerfect settings inherited from parent canvases.</summary>
    </member>
    <member name="P:UnityEngine.Canvas.overrideSorting">
      <summary>
        <para>Override the sorting of canvas.</para>
        <para>Allows for nested canvas's to ignore the parent draw order and draw ontop or below.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.pixelPerfect">
      <summary>
        <para>Force elements in the canvas to be aligned with pixels. Only applies with renderMode is Screen Space.</para>
        <para>Enabling pixelPerfect can make elements appear sharper and prevent blurriness. However, if many elements are scaled or rotated, or use subtle animated position or scaling, it may be advantageous to disable pixelPerfect, since the movement will be smoother without.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.pixelRect">
      <summary>
        <para>Get the render rect for the <see cref="T:UnityEngine.Canvas" />.</para>
        <para>If in overlay mode this will be the screen dimensions. If in world mode this will be the camera screen viewport rect.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.planeDistance">
      <summary>How far away from the camera is the Canvas generated.</summary>
    </member>
    <member name="P:UnityEngine.Canvas.referencePixelsPerUnit">
      <summary>
        <para>The number of pixels per unit that is considered the default.</para>
        <para>Sprites have a Pixels Per Unit that control the pixel density of the sprite. For sprites that have the same Pixels Per Unit as the Reference Pixels Per Unit in the Canvas, the pixel density will be one to one.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.renderMode">
      <summary>Is the <see cref="T:UnityEngine.Canvas" /> in World or Overlay mode?</summary>
    </member>
    <member name="P:UnityEngine.Canvas.renderOrder">
      <summary>
        <para>The render order in which the canvas is being emitted to the scene.</para>
        <para>Note: Currently only Screen Space - Overlay canvas's are ordered correctly as Screen Space - Camera and World Space are emitted and sorted based upon distance from the camera.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.scaleFactor">
      <summary>Used to scale the entire canvas, while still making it fit the screen. Only applies with renderMode is Screen Space.</summary>
    </member>
    <member name="P:UnityEngine.Canvas.sortingLayerID">
      <summary>
        <para>Unique ID of the Canvas' sorting layer.</para>
        <para>See <see cref="T:UnityEngine.Renderer" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.sortingLayerName">
      <summary>
        <para>Name of the Canvas' sorting layer.</para>
        <para>See <see cref="T:UnityEngine.Renderer" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.sortingOrder">
      <summary>
        <para>Canvas' order within a sorting layer.</para>
        <para>See <see cref="T:UnityEngine.Renderer" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Canvas.worldCamera">
      <summary>
        <see cref="T:UnityEngine.Camera" /> used for sizing the <see cref="T:UnityEngine.Canvas" /> when in Screen Space - Camera. Also used as the <see cref="T:UnityEngine.Camera" /> that events will be sent through for a World Space [[Canvas].</summary>
    </member>
    <member name="M:UnityEngine.Canvas.ForceUpdateCanvases">
      <summary>
        <para>Force all canvases to update their content.</para>
        <para>A canvas performs its layout and content generation calculations at the end of a frame, just before rendering, in order to ensure that it's based on all the latest changes that may have happened during that frame. This means that in the Start callback and the first Update callback, the layout and content under the canvas may not be up-to-date.Code that relies on up-to-date layout or content can call this method to ensure it before executing code that relies on it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Canvas.GetDefaultCanvasMaterial">
      <summary>Returns the default material that can be used for rendering normal elements on the Canvas.</summary>
    </member>
    <member name="P:UnityEngine.CanvasGroup.alpha">
      <summary>Set the alpha of the group.</summary>
    </member>
    <member name="P:UnityEngine.CanvasGroup.blocksRaycasts">
      <summary>Does this group block raycasting (allow collision).</summary>
    </member>
    <member name="P:UnityEngine.CanvasGroup.ignoreParentGroups">
      <summary>
        <para>Should the group ignore parent groups?</para>
        <para>If set to true the group will ignore any parent group settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CanvasGroup.interactable">
      <summary>Is the group interactable (are the elements beneath the group enabled).</summary>
    </member>
    <member name="M:UnityEngine.CanvasGroup.IsRaycastLocationValid(UnityEngine.Vector2,UnityEngine.Camera)">
      <summary>Returns true if the Group allows raycasts.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.absoluteDepth">
      <summary>Depth of the renderer realitive to the root canvas.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.cull">
      <summary>Indicates whether geometry emitted by this rendered is ignored.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.hasMoved">
      <summary>True if any change has occured that would invalidate the positions of generated geometry.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.hasPopInstruction">
      <summary>
        <para>Enable 'render stack' pop draw call.</para>
        <para>When rendering using the hierarchy the renderer can insert a 'pop'. The pop instruction is executed after all children have been rendered. The canvas renderer is rerendered using the configured pop materials.See: <see cref="M:UnityEngine.CanvasRenderer.SetPopMaterial(UnityEngine.Material,System.Int32)" /><see cref="P:UnityEngine.CanvasRenderer.popMaterialCount" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.hasRectClipping">
      <summary>True if rect clipping has been enabled on this renderer.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.materialCount">
      <summary>The number of materials usable by this renderer.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.popMaterialCount">
      <summary>The number of materials usable by this renderer. Used internally for masking.</summary>
    </member>
    <member name="P:UnityEngine.CanvasRenderer.relativeDepth">
      <summary>Depth of the renderer realative to the parent canvas.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.Clear">
      <summary>Remove all cached vertices.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.DisableRectClipping">
      <summary>Disables rectangle clipping for this CanvasRenderer.</summary>
      <seealso cref="M:UnityEngine.CanvasRenderer.EnableRectClipping(UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.CanvasRenderer.EnableRectClipping(UnityEngine.Rect)">
      <summary>Enables rect clipping on the CanvasRendered. Geometry outside of the specified rect will be clipped (not rendered).</summary>
      <seealso cref="M:UnityEngine.CanvasRenderer.DisableRectClipping" />
    </member>
    <member name="M:UnityEngine.CanvasRenderer.GetAlpha">
      <summary>Get the current alpha of the renderer.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.GetColor">
      <summary>Get the current color of the renderer.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.GetMaterial(System.Int32)">
      <summary>Gets the current <see cref="T:UnityEngine.Material" /> assigned to the CanvasRenderer.</summary>
      <param name="index">The material index to retrieve (0 if this parameter is omitted).</param>
      <returns>Result.</returns>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.GetMaterial">
      <summary>Gets the current <see cref="T:UnityEngine.Material" /> assigned to the CanvasRenderer.</summary>
      <returns>Result.</returns>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.GetPopMaterial(System.Int32)">
      <summary>Gets the current <see cref="T:UnityEngine.Material" /> assigned to the CanvasRenderer. Used internally for masking.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetAlpha(System.Single)">
      <summary>Set the alpha of the renderer. Will be multiplied with the <see cref="T:UnityEngine.UIVertex" /> alpha and the <see cref="T:UnityEngine.Canvas" /> alpha.</summary>
      <param name="alpha">Alpha.</param>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetColor(UnityEngine.Color)">
      <summary>Set the color of the renderer. Will be multiplied with the <see cref="T:UnityEngine.UIVertex" /> color and the <see cref="T:UnityEngine.Canvas" /> color.</summary>
      <param name="color">Renderer multiply color.</param>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetMaterial(UnityEngine.Material,System.Int32)">
      <summary>Set the material for the canvas renderer. If a texture is specified then it will be used as the 'MainTex' instead of the material's 'MainTex'.</summary>
      <param name="material">Material for rendering.</param>
      <param name="index">Material index.</param>
      <seealso cref="M:UnityEngine.CanvasRenderer.SetTexture(UnityEngine.Texture)" />
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetMaterial(UnityEngine.Material,UnityEngine.Texture)">
      <summary>Set the material for the canvas renderer. If a texture is specified then it will be used as the 'MainTex' instead of the material's 'MainTex'.</summary>
      <param name="material">Material for rendering.</param>
      <param name="texture">Material texture overide.</param>
      <seealso cref="M:UnityEngine.CanvasRenderer.SetTexture(UnityEngine.Texture)" />
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetMesh(UnityEngine.Mesh)">
      <summary>Sets the Mesh used by this renderer.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetPopMaterial(UnityEngine.Material,System.Int32)">
      <summary>Set the material for the canvas renderer. Used internally for masking.</summary>
    </member>
    <member name="M:UnityEngine.CanvasRenderer.SetTexture(UnityEngine.Texture)">
      <summary>Sets the texture used by this renderer's material.</summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.center">
      <summary>The center of the capsule, measured in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.direction">
      <summary>
        <para>The direction of the capsule.</para>
        <para>The value can be 0, 1 or 2 corresponding to the X, Y and Z axes, respectively.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.height">
      <summary>
        <para>The height of the capsule meased in the object's local space.</para>
        <para>The capsule's height will be scaled by the transform's scale. Note that the height is the actual height including the half-spheres at each end.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.radius">
      <summary>
        <para>The radius of the sphere, measured in the object's local space.</para>
        <para>The capsule's radius will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.center">
      <summary>The center of the character's capsule relative to the transform's position.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.collisionFlags">
      <summary>What part of the capsule collided with the environment during the last CharacterController.Move call.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.detectCollisions">
      <summary>
        <para>Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled).</para>
        <para>This method does not affect collisions detected during the character controller's movement but rather decides whether an incoming collider will be blocked by the controller's collider. For example, a box collider in the scene will block the movement of the controller, but the box may still fall through the controller if detectCollisions is false. This property is useful to disable the character controller temporarily. For example, you might want to mount a character into a car and disable collision detection until it exits the car again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.height">
      <summary>The height of the character's capsule.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.isGrounded">
      <summary>Was the CharacterController touching the ground during the last move?</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.radius">
      <summary>The radius of the character's capsule.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.skinWidth">
      <summary>
        <para>The character's collision skin width.</para>
        <para>Specifies a skin around the character within which contacts will be generated by the physics engine. Use it to avoid numerical precision issues.This is dependant on the scale of the world, but should be a small, positive non zero value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.slopeLimit">
      <summary>The character controllers slope limit in degrees.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.stepOffset">
      <summary>The character controllers step offset in meters.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.velocity">
      <summary>
        <para>The current relative velocity of the Character (see notes).</para>
        <para>This allows you to track how fast the character is actually walking for example when he is stuck at a wall this value will be the zero vector.Note: The velocity returned is simply the difference in distance for the current timestep before and after a call to CharacterController.Move or CharacterController.SimpleMove. The velocity is relative because it won't track movements to the transform that happen outside of the CharacterController (e.g. character parented under another moving Transform, such as a moving vehicle).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CharacterController.Move(UnityEngine.Vector3)">
      <summary>
        <para>A more complex move function taking absolute movement deltas.</para>
        <para>Attempts to move the controller by <c>motion</c>, the motion will only be constrained by collisions. It will slide along colliders. <see cref="T:UnityEngine.CollisionFlags" /> is the summary of collisions that occurred during the Move. This function does not apply any gravity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CharacterController.SimpleMove(UnityEngine.Vector3)">
      <summary>
        <para>Moves the character with <c>speed</c>.</para>
        <para>Velocity along the y-axis is ignored. Speed is in meters/s. Gravity is automatically applied. Returns if the character is grounded. It is recommended that you make only one call to Move or SimpleMove per frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.advance">
      <summary>The horizontal distance from the origin of this character to the origin of the next character.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.bearing">
      <summary>The horizontal distance from the origin of this glyph to the begining of the glyph image.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.glyphHeight">
      <summary>The height of the glyph image.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.glyphWidth">
      <summary>The width of the glyph image.</summary>
    </member>
    <member name="F:UnityEngine.CharacterInfo.index">
      <summary>Unicode value of the character.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.maxX">
      <summary>The maximum extend of the glyph image in the x-axis.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.maxY">
      <summary>The maximum extend of the glyph image in the y-axis.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.minX">
      <summary>The minium extend of the glyph image in the x-axis.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.minY">
      <summary>The minimum extend of the glyph image in the y-axis.</summary>
    </member>
    <member name="F:UnityEngine.CharacterInfo.size">
      <summary>
        <para>The size of the character or 0 if it is the default font size.</para>
        <para>Only used with characters generated at runtime for dynamic fonts).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CharacterInfo.style">
      <summary>
        <para>The style of the character.</para>
        <para>Only used with characters generated at runtime for dynamic fonts).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.uvBottomLeft">
      <summary>The uv coordinate matching the bottom left of the glyph image in the font texture.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.uvBottomRight">
      <summary>The uv coordinate matching the bottom right of the glyph image in the font texture.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.uvTopLeft">
      <summary>The uv coordinate matching the top left of the glyph image in the font texture.</summary>
    </member>
    <member name="P:UnityEngine.CharacterInfo.uvTopRight">
      <summary>The uv coordinate matching the top right of the glyph image in the font texture.</summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.enableProjection">
      <summary>
        <para>Brings violated constraints back into alignment even when the solver fails.</para>
        <para>Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.highTwistLimit">
      <summary>
        <para>The upper limit around the primary axis of the character joint.</para>
        <para>The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.lowTwistLimit">
      <summary>
        <para>The lower limit around the primary axis of the character joint.</para>
        <para>The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.projectionAngle">
      <summary>
        <para>Set the angular tolerance threshold (in degrees) for projection.</para>
        <para>If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.projectionDistance">
      <summary>
        <para>Set the linear tolerance threshold for projection.</para>
        <para>If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swing1Limit">
      <summary>
        <para>The angular limit of rotation (in degrees) around the primary axis of the character joint.</para>
        <para>The limit is symmetric. For example, a value of 30 will limit the rotation between -30 and +30 degrees. The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swing2Limit">
      <summary>
        <para>The angular limit of rotation (in degrees) around the primary axis of the character joint.</para>
        <para>The limit is symmetric. Thus a value of eg. 30 will limit the rotation between -30 and +30 degrees. The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swingAxis">
      <summary>
        <para>The secondary axis around which the joint can rotate.</para>
        <para>CharacterJoint.swing1Limit are the limits of the rotation allowed around this axis.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swingLimitSpring">
      <summary>The configuration of the spring attached to the swing limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.twistLimitSpring">
      <summary>The configuration of the spring attached to the twist limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.CircleCollider2D.radius">
      <summary>Radius of the circle.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.bendingStiffness">
      <summary>
        <para>Bending stiffness of the cloth.</para>
        <para>Must be between zero and one. Setting the value to zero disables bending stiffness simulation. In many cases, when you want a cloth to be more stiff, actually reducing the number of vertices will get you better results - and performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.capsuleColliders">
      <summary>
        <para>An array of CapsuleColliders which this Cloth instance should collide with.</para>
        <para>Any capsule colliders specified in Cloth.capsuleColliders will collide with the cloth vertices. A maximum of 32 capsules are supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.coefficients">
      <summary>The cloth skinning coefficients used to set up how the cloth interacts with the skinned mesh.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.collisionMassScale">
      <summary>How much to increase mass of colliding particles.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.damping">
      <summary>
        <para>Damp cloth motion.</para>
        <para>Set this to damp the motions of a cloth instance. Must be between zero and one. Setting this to zero will disable cloth damping.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.enabled">
      <summary>
        <para>Is this cloth enabled?</para>
        <para>This is the same as the checkbox next to the component label in the inspector. A disabled cloth component will not update it's physics simulation, so you can use this to suspend the simulation of cloth objects when they are not needed, as cloth simulation is a very CPU-intensive task.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.externalAcceleration">
      <summary>
        <para>A constant, external acceleration applied to the cloth.</para>
        <para>Use this to simulate constant forces on the cloth, such as wind waving a flag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.friction">
      <summary>The friction of the cloth when colliding with the character.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.normals">
      <summary>
        <para>The current normals of the cloth object.</para>
        <para>This gives you read access to the normals of the cloth object, so you can analyse it's current simulation state. Note that the normal indices may not necessarily correspond to the indices of the source mesh - especially when triangle stripping or UV seams are used in the source mesh (ie, multiple indices for the same vertex), cloth vertices will be different, as the cloth simulation only uses a single index for each vertex.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.randomAcceleration">
      <summary>
        <para>A random, external acceleration applied to the cloth.</para>
        <para>Use this to simulate randomly changing forces on the cloth, such as wind turbulences waving a flag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.sleepThreshold">
      <summary>
        <para>Cloth's sleep threshold.</para>
        <para>Sleep threshold is a linear speed of cloth particles, below which the whole cloth piece is going to fall asleep.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.solverFrequency">
      <summary>Number of solver iterations per second.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.sphereColliders">
      <summary>
        <para>An array of ClothSphereColliderPairs which this Cloth instance should collide with.</para>
        <para>Any ClothSphereColliderPair specified in Cloth.capsuleColliders will collide with the cloth vertices. A maximum of 32 spheres are supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.stretchingStiffness">
      <summary>
        <para>Stretching stiffness of the cloth.</para>
        <para>Must be greater than zero and smaller or equal to one. In many cases, when you want a cloth to be more stiff, actually reducing the number of vertices will get you better results - and performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.useContinuousCollision">
      <summary>Enable continuous collision to improve collision stability.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.useGravity">
      <summary>Should gravity affect the cloth simulation?</summary>
    </member>
    <member name="P:UnityEngine.Cloth.useVirtualParticles">
      <summary>Add one virtual particle per triangle to improve collision stability.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.vertices">
      <summary>
        <para>The current vertex positions of the cloth object.</para>
        <para>This gives you read access to the vertex positions of the cloth object, so you can analyse it's current simulation state. Note that the vertex indices may not necessarily correspond to the indices of the source mesh - especially when triangle stripping or UV seams are used in the source mesh (ie, multiple indices for the same vertex), cloth vertices will be different, as the cloth simulation only uses a single index for each vertex.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cloth.worldAccelerationScale">
      <summary>How much world-space acceleration of the character will affect cloth vertices.</summary>
    </member>
    <member name="P:UnityEngine.Cloth.worldVelocityScale">
      <summary>How much world-space movement of the character will affect cloth vertices.</summary>
    </member>
    <member name="M:UnityEngine.Cloth.ClearTransformMotion">
      <summary>
        <para>Clear the pending transform changes from affecting the cloth simulation.</para>
        <para>When the transform of a cloth changes, the cloth will not directly follow that change, but instead, the new positions of the SkinnedMeshRenderer's vertices will affect the cloth through the configured constraints in the next cloth simulation update, so that moving the tranform will result in realistic motion of the cloth. You can call ClearTransformMotion on the cloth to change this behavior. Calling ClearTransformMotion will move the cloth simulation particles along with the transform, so that the transform movement has no effect on the cloth simulation. This is useful if you want to teleport Characters from one point in the scene to another, without having the cloth suddenly jerk into place.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cloth.SetEnabledFading(System.Boolean,System.Single)">
      <summary>Fade the cloth simulation in or out.</summary>
      <param name="enabled">Fading enabled or not.</param>
    </member>
    <member name="M:UnityEngine.Cloth.SetEnabledFading(System.Boolean)">
      <summary>Fade the cloth simulation in or out.</summary>
      <param name="enabled">Fading enabled or not.</param>
    </member>
    <member name="F:UnityEngine.ClothSkinningCoefficient.collisionSphereDistance">
      <summary>
        <para>Definition of a sphere a vertex is not allowed to enter. This allows collision against the animated cloth.</para>
        <para>The pair (collisionSphereRadius, collisionSphereDistance) define a sphere for each cloth vertex. The sphere's center is located at the position constrainPosition - constrainNormal * (collisionSphereRadius + collisionSphereDistance) and its radius is collisionSphereRadius, where constrainPosition and constrainNormal are the vertex positions and normals generated by the SkinnedMeshRenderer. The Cloth makes sure that the cloth vertex does not enter this sphere. As a typical usecase, set collisionSphereDistance to zero and collisionSphereRadius to a large value w.r.t. the triangle size. In this setup, the cloth collides against the skinned mesh. Default: 0.0 Range: [0,inf).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ClothSkinningCoefficient.maxDistance">
      <summary>
        <para>Distance a vertex is allowed to travel from the skinned mesh vertex position.</para>
        <para>The Cloth component makes sure that the cloth vertices stay within maxDistance from the skinned mesh vertex positions. If maxDistance is zero, the vertex is not simulated but set to the skinned mesh vertex position. This behavior is useful for attaching the cloth vertex to the skin of an animated character. Default: 0.2 Range: [0, inf).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ClothSphereColliderPair.first">
      <summary>The first SphereCollider of a ClothSphereColliderPair.</summary>
    </member>
    <member name="P:UnityEngine.ClothSphereColliderPair.second">
      <summary>The second SphereCollider of a ClothSphereColliderPair.</summary>
    </member>
    <member name="M:UnityEngine.ClothSphereColliderPair.#ctor(UnityEngine.SphereCollider)">
      <summary>Creates a ClothSphereColliderPair. If only one SphereCollider is given, the ClothSphereColliderPair will define a simple sphere. If two SphereColliders are given, the ClothSphereColliderPair defines a conic capsule shape, composed of the two spheres and the cone connecting the two.</summary>
      <param name="a">The first SphereCollider of a ClothSphereColliderPair.</param>
    </member>
    <member name="M:UnityEngine.ClothSphereColliderPair.#ctor(UnityEngine.SphereCollider,UnityEngine.SphereCollider)">
      <summary>Creates a ClothSphereColliderPair. If only one SphereCollider is given, the ClothSphereColliderPair will define a simple sphere. If two SphereColliders are given, the ClothSphereColliderPair defines a conic capsule shape, composed of the two spheres and the cone connecting the two.</summary>
      <param name="a">The first SphereCollider of a ClothSphereColliderPair.</param>
      <param name="b">The second SphereCollider of a ClothSphereColliderPair.</param>
    </member>
    <member name="P:UnityEngine.Collider.attachedRigidbody">
      <summary>
        <para>The rigidbody the collider is attached to.</para>
        <para>Returns null if the collider is attached to no rigidbody.Colliders are automatically connected to the rigidbody attached to the same game object or attached to any parent game object.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.bounds">
      <summary>
        <para>The world space bounding volume of the collider.</para>
        <para>Note that this will be an empty bounding box if the collider is disabled or the game object is inactive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.contactOffset">
      <summary>
        <para>Contact offset value of this collider.</para>
        <para>Colliders whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive. Contact offset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.enabled">
      <summary>
        <para>Enabled Colliders will collide with other colliders, disabled Colliders won't.</para>
        <para>This is shown as the small checkbox in the inspector of the Colliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.isTrigger">
      <summary>
        <para>Is the collider a trigger?</para>
        <para>A trigger doesn't register a collision with an incoming <see cref="T:UnityEngine.Rigidbody" />. Instead, it sends <c>OnTriggerEnter</c>, <c>OnTriggerExit</c> and <c>OnTriggerStay</c> message when a rigidbody enters or exits the trigger volume.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.material">
      <summary>
        <para>The material used by the collider.</para>
        <para>If material is shared by colliders, it will duplicate the material and assign it to the collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.sharedMaterial">
      <summary>
        <para>The shared physic material of this collider.</para>
        <para>Modifying this material will change the surface properties of all colliders using the material. In most cases you want to modify <see cref="P:UnityEngine.Collider.material" /> instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider.ClosestPointOnBounds(UnityEngine.Vector3)">
      <summary>
        <para>The closest point to the bounding box of the attached collider.</para>
        <para>This can be used to calculate hit points when applying explosion damage.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single)">
      <summary>Casts a <see cref="T:UnityEngine.Ray" /> that ignores all Colliders except this one.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max length of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="P:UnityEngine.Collider2D.attachedRigidbody">
      <summary>
        <para>The Rigidbody2D attached to the Collider2D's GameObject.</para>
        <para>This property will be null if no Rigidbody2D is attached.See Also: Rigidbody2D::ref::</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.bounds">
      <summary>
        <para>The world space bounding area of the collider.</para>
        <para>Note that this will be an empty bounding box if the collider is disabled or the game object is inactive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.isTrigger">
      <summary>Is this collider configured as a trigger?</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.offset">
      <summary>
        <para>The local offset of the collider geometry.</para>
        <para>This offset can be used to shift the local origin of any 2D collider geometry.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.shapeCount">
      <summary>The number of separate shaped regions in the collider.</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.sharedMaterial">
      <summary>The PhysicsMaterial2D that is applied to this collider.</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.usedByEffector">
      <summary>
        <para>Whether the collider is used by an attached effector or not.</para>
        <para>When checked, the <see cref="T:UnityEngine.Collider2D" /> continues to work as a collision or trigger area however it will also be used by any <see cref="T:UnityEngine.Effector2D" /> on the same GameObject.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouching(UnityEngine.Collider2D)">
      <summary>
        <para>Check whether this collider is touching the <c>collider</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching this collider.</param>
      <returns>Whether the <c>collider</c> is touching this collider or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouchingLayers(System.Int32)">
      <summary>
        <para>Checks whether this collider is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether this collider is touching any collider on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouchingLayers">
      <summary>
        <para>Checks whether this collider is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <returns>Whether this collider is touching any collider on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.OverlapPoint(UnityEngine.Vector2)">
      <summary>
        <para>Check if a collider overlaps a point in space.</para>
        <para>This will always return false when used on an <see cref="T:UnityEngine.EdgeCollider2D" />.</para>
      </summary>
      <param name="point">A point in world space.</param>
    </member>
    <member name="P:UnityEngine.Collision.collider">
      <summary>
        <para>The <see cref="T:UnityEngine.Collider" /> we hit (Read Only).</para>
        <para>To find all colliders that were hit in detail you have to iterate the contact points (<see cref="P:UnityEngine.Collision.contacts" /> property).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.contacts">
      <summary>
        <para>The contact points generated by the physics engine.</para>
        <para>Every contact contains a contact point, normal and the two colliders that collided (see <see cref="T:UnityEngine.ContactPoint" />). From inside <c>OnCollisionStay</c> or <c>OnCollisionEnter</c> you can always be sure that <c>contacts</c> has at least one element.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.gameObject">
      <summary>The <see cref="T:UnityEngine.GameObject" /> whose collider we are colliding with. (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Collision.impulse">
      <summary>
        <para>The total impulse applied to this contact pair to resolve the collision.</para>
        <para>The total impulse is obtained by summing up impulses applied at all contact points in this collision pair. To work out the total force applied you can divide the total impulse by the last frame's fixedDeltaTime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.relativeVelocity">
      <summary>The relative linear velocity of the two colliding objects (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Collision.rigidbody">
      <summary>The <see cref="T:UnityEngine.Rigidbody" /> we hit (Read Only). This is <c>null</c> if the object we hit is a collider with no rigidbody attached.</summary>
    </member>
    <member name="P:UnityEngine.Collision.transform">
      <summary>
        <para>The <see cref="T:UnityEngine.Transform" /> of the object we hit (Read Only).</para>
        <para>If we collided against a collider with a <see cref="T:UnityEngine.Rigidbody" />, the transform will be the transform attached to the rigidbody. If we collided against a collider without a rigidbody, the transform will be the transform attached to the collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.collider">
      <summary>The incoming Collider2D involved in the collision.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.contacts">
      <summary>The specific points of contact with the incoming Collider2D.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.enabled">
      <summary>
        <para>Whether the collision was disabled or not.</para>
        <para>Typically all collisions are enabled however certain features can disable the collision. When a collision is disabled, only its collision response is disabled, the collision itself is still reported as you would expect. Effectors can disable collisions but you will still get those collisions reported allowing you to perform additional actions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.gameObject">
      <summary>The incoming GameObject involved in the collision.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.relativeVelocity">
      <summary>The relative linear velocity of the two colliding objects (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.rigidbody">
      <summary>The incoming Rigidbody2D involved in the collision.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.transform">
      <summary>The Transform of the incoming object involved in the collision.</summary>
    </member>
    <member name="P:UnityEngine.Color.black">
      <summary>Solid black. RGBA is (0, 0, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.blue">
      <summary>Solid blue. RGBA is (0, 0, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.clear">
      <summary>Completely transparent. RGBA is (0, 0, 0, 0).</summary>
    </member>
    <member name="P:UnityEngine.Color.cyan">
      <summary>Cyan. RGBA is (0, 1, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.gray">
      <summary>Gray. RGBA is (0.5, 0.5, 0.5, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.green">
      <summary>Solid green. RGBA is (0, 1, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.grey">
      <summary>English spelling for <see cref="P:UnityEngine.Color.gray" />. RGBA is the same (0.5, 0.5, 0.5, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.magenta">
      <summary>Magenta. RGBA is (1, 0, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.red">
      <summary>Solid red. RGBA is (1, 0, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.white">
      <summary>Solid white. RGBA is (1, 1, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.yellow">
      <summary>Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!</summary>
    </member>
    <member name="F:UnityEngine.Color.a">
      <summary>Alpha component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color.b">
      <summary>Blue component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color.g">
      <summary>Green component of the color.</summary>
    </member>
    <member name="P:UnityEngine.Color.gamma">
      <summary>A version of the color that has had the gamma curve applied.</summary>
    </member>
    <member name="P:UnityEngine.Color.grayscale">
      <summary>The grayscale value of the color. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Color.linear">
      <summary>A version of the color that has had the inverse gamma curve applied.</summary>
    </member>
    <member name="P:UnityEngine.Color.maxColorComponent">
      <summary>Returns the maximum color component value: Max(r,g,b).</summary>
    </member>
    <member name="F:UnityEngine.Color.r">
      <summary>Red component of the color.</summary>
    </member>
    <member name="M:UnityEngine.Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Constructs a new Color with given r,g,b,a components.</summary>
      <param name="r">Red component.</param>
      <param name="g">Green component.</param>
      <param name="b">Blue component.</param>
      <param name="a">Alpha component.</param>
    </member>
    <member name="M:UnityEngine.Color.#ctor(System.Single,System.Single,System.Single)">
      <summary>Constructs a new Color with given r,g,b components and sets <c>a</c> to 1.</summary>
      <param name="r">Red component.</param>
      <param name="g">Green component.</param>
      <param name="b">Blue component.</param>
    </member>
    <member name="M:UnityEngine.Color.ToString">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color.ToString(System.String)">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color.Lerp(UnityEngine.Color,UnityEngine.Color,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>
          <c>t</c> is clamped between 0 and 1. When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Color.LerpUnclamped(UnityEngine.Color,UnityEngine.Color,System.Single)" />
    </member>
    <member name="M:UnityEngine.Color.LerpUnclamped(UnityEngine.Color,UnityEngine.Color,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.See Also: <see cref="M:UnityEngine.Color.Lerp(UnityEngine.Color,UnityEngine.Color,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Color.(UnityEngine.Color,UnityEngine.Color)">
      <summary>Subtracts color <c>b</c> from color <c>a</c>. Each component is subtracted separately.</summary>
    </member>
    <member name="M:UnityEngine.Color.operator *(UnityEngine.Color,UnityEngine.Color)">
      <summary>Multiplies two colors together. Each component is multiplied separately.</summary>
    </member>
    <member name="M:UnityEngine.Color.operator *(UnityEngine.Color,System.Single)">
      <summary>Multiplies color <c>a</c> by the float <c>b</c>. Each color component is scaled separately.</summary>
    </member>
    <member name="M:UnityEngine.Color.operator *(System.Single,UnityEngine.Color)">
      <summary>Multiplies color <c>a</c> by the float <c>b</c>. Each color component is scaled separately.</summary>
    </member>
    <member name="M:UnityEngine.Color.operator /(UnityEngine.Color,System.Single)">
      <summary>Divides color <c>a</c> by the float <c>b</c>. Each color component is scaled separately.</summary>
    </member>
    <member name="M:UnityEngine.Color.operator +(UnityEngine.Color,UnityEngine.Color)">
      <summary>Adds two colors together. Each component is added separately.</summary>
    </member>
    <member name="F:UnityEngine.Color32.a">
      <summary>Alpha component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.b">
      <summary>Blue component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.g">
      <summary>Green component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.r">
      <summary>Red component of the color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
      <summary>Constructs a new Color with given r, g, b, a components.</summary>
    </member>
    <member name="M:UnityEngine.Color32.ToString">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.ToString(System.String)">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.Lerp(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>
          <c>t</c> is clamped between 0 and 1. When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Color32.LerpUnclamped(UnityEngine.Color32,UnityEngine.Color32,System.Single)" />
    </member>
    <member name="M:UnityEngine.Color32.LerpUnclamped(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.See Also: <see cref="M:UnityEngine.Color32.Lerp(UnityEngine.Color32,UnityEngine.Color32,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ColorUtility.ToHtmlStringRGB(UnityEngine.Color)">
      <summary>Returns the color as a hexadecimal string in the format "RRGGBB".</summary>
      <param name="color">The color to be converted.</param>
      <returns>Hexadecimal string representing the color.</returns>
    </member>
    <member name="M:UnityEngine.ColorUtility.ToHtmlStringRGBA(UnityEngine.Color)">
      <summary>Returns the color as a hexadecimal string in the format "RRGGBBAA".</summary>
      <param name="color">The color to be converted.</param>
      <returns>Hexadecimal string representing the color.</returns>
    </member>
    <member name="M:UnityEngine.ColorUtility.TryParseHtmlString(System.String,UnityEngine.Color@)">
      <summary>
        <para>Attempts to convert a html color string.</para>
        <para>Strings that begin with '#' will be parsed as hexadecimal in the following way: #RGB (becomes RRGGBB) #RRGGBB #RGBA (becomes RRGGBBAA) #RRGGBBAA When not specified alpha will default to FF. Strings that do not begin with '#' will be parsed as literal colors, with the following supported: red, cyan, blue, darkblue, lightblue, purple, yellow, lime, fuchsia, white, silver, grey, black, orange, brown, maroon, green, olive, navy, teal, aqua, magenta.. The following example creates a custom PropertyDrawer that allows the user to input html colors. This property drawer can be shown in the inspector when a color property has the attribute ColorHtmlProperty.<c>our custom property drawer.</c></para>
      </summary>
      <param name="htmlString">Case insensitive html string to be converted into a color.</param>
      <param name="color">The converted color.</param>
      <returns>True if the string was successfully converted else false.</returns>
    </member>
    <member name="P:UnityEngine.CombineInstance.mesh">
      <summary>
        <see cref="T:UnityEngine.Mesh" /> to combine.</summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.subMeshIndex">
      <summary>Submesh index of the mesh.</summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.transform">
      <summary>Matrix to transform the mesh with before combining.</summary>
    </member>
    <member name="P:UnityEngine.Compass.enabled">
      <summary>Used to enable or disable compass. Note, that if you want <c>Input.compass.trueHeading</c> property to contain a valid value, you must also enable location updates by calling <c>Input.location.Start()</c>.</summary>
    </member>
    <member name="P:UnityEngine.Compass.headingAccuracy">
      <summary>
        <para>Accuracy of heading reading in degrees.</para>
        <para>Negative value mean unreliable reading. If accuracy is not supported or not available, 0 is returned. Not all platforms support this pricise accuracy, so the value may vary between few constant values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.magneticHeading">
      <summary>
        <para>The heading in degrees relative to the magnetic North Pole. (Read Only)</para>
        <para>The value in this property is always measured relative to the top of the screen in its current orientation. The heading of magnetic north is not exactly the same as true geographical north - to get the exact heading, use the <see cref="P:UnityEngine.Compass.trueHeading" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.rawVector">
      <summary>
        <para>The raw geomagnetic data measured in microteslas. (Read Only)</para>
        <para>The compass is actually a magnetometer that measures the magnetic field in the device's XYZ coordinates - in the absence of a stronger magnet, it will measure the Earth's field from which the compass heading can be found. This property can be used if you want to make non-standard use of the compass (eg, find the heading from the X or Z axis of the device).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.timestamp">
      <summary>Timestamp (in seconds since 1970) when the heading was last time updated. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Compass.trueHeading">
      <summary>
        <para>The heading in degrees relative to the geographic North Pole. (Read Only)</para>
        <para>The value in this property is always measured relative to the top of the screen in its current orientation. Note, that if you want this property to contain a valid value, you must also enable location updates by calling <c>Input.location.Start()</c>. (Read Only)</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Component.gameObject">
      <summary>The game object this component is attached to. A component is always attached to a game object.</summary>
    </member>
    <member name="P:UnityEngine.Component.tag">
      <summary>
        <para>The tag of this game object.</para>
        <para>A tag can be used to identify a game object. Tags must be declared in the Tags and Layers manager before using them.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Component.transform">
      <summary>The <see cref="T:UnityEngine.Transform" /> attached to this <see cref="T:UnityEngine.GameObject" /> (null if there is none attached).</summary>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="parameter">Optional parameter to pass to the method (can be any value).</param>
      <param name="options">Should an error be raised if the method does not exist for a given target object?</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="parameter">Optional parameter to pass to the method (can be any value).</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="options">Should an error be raised if the method does not exist for a given target object?</param>
    </member>
    <member name="M:UnityEngine.Component.CompareTag(System.String)">
      <summary>Is this game object tagged with <c>tag</c> ?</summary>
      <param name="tag">The tag to compare.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponent(System.Type)">
      <summary>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponent``1">
      <summary>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponent(System.String)">
      <summary>
        <para>Returns the component with name <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>It is better to use GetComponent with a Type instead of a string for performance reasons. Sometimes you might not be able to get to the type however, for example when trying to access a C# script from Javascript. In that case you can simply access the component by name instead of type. Example:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInChildren(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInChildren``1">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInParent(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</para>
        <para>Only active components are returned.</para>
      </summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInParent``1">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</para>
        <para>Only active components are returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponents(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" />.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponents``1">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" />.</summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren(System.Type,System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children.</summary>
      <param name="t">The type of Component to retrieve.</param>
      <param name="includeInactive">Should Components on inactive GameObjects be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children.</summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren``1(System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children.</summary>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren``1">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its children.</summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent(System.Type,System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</summary>
      <param name="t">The type of Component to retrieve.</param>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent``1(System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</summary>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent``1">
      <summary>Returns all components of Type <c>type</c> in the <see cref="T:UnityEngine.GameObject" /> or any of its parents.</summary>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="value">Optional parameter for the method.</param>
      <param name="options">Should an error be raised if the target object doesn't implement the method for the message?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="value">Optional parameter for the method.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="options">Should an error be raised if the target object doesn't implement the method for the message?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="options">Should an error be raised if the method does not exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="value">Optional parameter value for the method.</param>
      <param name="options">Should an error be raised if the method does not exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="value">Optional parameter value for the method.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
    </member>
    <member name="P:UnityEngine.ComputeBuffer.count">
      <summary>Number of elements in the buffer (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ComputeBuffer.stride">
      <summary>Size of one element in the buffer (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.#ctor(System.Int32,System.Int32)">
      <summary>
        <para>Create a Compute Buffer.</para>
        <para>Use <see cref="M:UnityEngine.ComputeBuffer.Release" /> to release the buffer when no longer needed.See Also: <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />, <see cref="T:UnityEngine.ComputeShader" /> class, <see cref="M:UnityEngine.Shader.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)" />, <see cref="M:UnityEngine.Material.SetBuffer(System.String,UnityEngine.ComputeBuffer)" />, Compute Shaders.</para>
      </summary>
      <param name="count">Number of elements in the buffer.</param>
      <param name="stride">Size of one element in the buffer. Has to match size of buffer type in the shader. See Compute Shaders for cross-platform compatibility information.</param>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.#ctor(System.Int32,System.Int32,UnityEngine.ComputeBufferType)">
      <summary>
        <para>Create a Compute Buffer.</para>
        <para>Use <see cref="M:UnityEngine.ComputeBuffer.Release" /> to release the buffer when no longer needed.See Also: <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />, <see cref="T:UnityEngine.ComputeShader" /> class, <see cref="M:UnityEngine.Shader.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)" />, <see cref="M:UnityEngine.Material.SetBuffer(System.String,UnityEngine.ComputeBuffer)" />, Compute Shaders.</para>
      </summary>
      <param name="count">Number of elements in the buffer.</param>
      <param name="stride">Size of one element in the buffer. Has to match size of buffer type in the shader. See Compute Shaders for cross-platform compatibility information.</param>
      <param name="type">Type of the buffer, default is ComputeBufferType.Default.</param>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.GetData(System.Array)">
      <summary>
        <para>Read data values from the buffer into an array.</para>
        <para>The retrieved data will follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">An array to receive the data.</param>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.Release">
      <summary>Release a Compute Buffer.</summary>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.SetData(System.Array)">
      <summary>
        <para>Set the buffer with values from an array.</para>
        <para>The input data must follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">Array of values to fill the buffer.</param>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Copy counter value of append/consume buffer into another buffer.</para>
        <para>Append/consume buffers keep track of the number of elements in them with a special counter variable. CopyCount takes an append/consume buffer as <c>src</c>, and copies its counter value into <c>dst</c> buffer at given byte offset.This is most commonly used in conjunction with <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, to render arbitrary number of primitives without reading their count back to the CPU.</para>
      </summary>
      <param name="src">Append/consume buffer to copy the counter from.</param>
      <param name="dst">A buffer to copy the counter to.</param>
      <param name="dstOffset">Target byte offset in <c>dst</c>.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Execute a compute shader.</para>
        <para>This functions "runs" the compute shader, with the given work size as indicated by threadsX, threadsY, threadsZ parameters.See Also: <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" />, Compute Shaders.</para>
      </summary>
      <param name="kernelIndex">Which kernel to execute. A single compute shader asset can have multiple kernel entry points.</param>
      <param name="threadsX">Work size in X dimension.</param>
      <param name="threadsY">Work size in Y dimension.</param>
      <param name="threadsZ">Work size in Z dimension.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      <summary>
        <para>Find <see cref="T:UnityEngine.ComputeShader" /> kernel index.</para>
        <para>A single compute shader can contain many "kernels" (functions that do the computation); FindKernel returns kernel index given the name.See Also: <see cref="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)" />.</para>
      </summary>
      <param name="name">Name of kernel function.</param>
      <returns>Kernel index, or -1 if not found.</returns>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets an input or output compute buffer.</para>
        <para>Buffers and textures are set per-kernel. Use <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" /> to find kernel index by function name.See Also: <see cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)" />, <see cref="T:UnityEngine.ComputeBuffer" />.</para>
      </summary>
      <param name="kernelIndex">For which kernel the buffer is being set. See <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" />.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="buffer">Buffer to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      <summary>
        <para>Set a float parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.See Also: <see cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])" />, <see cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)" />, <see cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])" />, <see cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)" />.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      <summary>
        <para>Set multiple consecutive float parameters at once.</para>
        <para>This function can be used to set float vector, float array or float vector array values. For example, float4 myArray[4] in the compute shader can be filled by passing 16 floats. See Compute Shaders for information on data layout rules and cross-platform compatibility.Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.See Also: <see cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)" />, <see cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])" />, <see cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)" />.</para>
      </summary>
      <param name="name">Array variable name in the shader code.</param>
      <param name="values">Value array to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      <summary>
        <para>Set an integer parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.See Also: <see cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])" />, <see cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])" />, <see cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)" />.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      <summary>
        <para>Set multiple consecutive integer parameters at once.</para>
        <para>This function can be used to set int vector, int array or int vector array values. For example, int4 myArray[4] in the compute shader can be filled by passing 16 integers. See Compute Shaders for information on data layout rules and cross-platform compatibility.Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.See Also: <see cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])" />, <see cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)" />, <see cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)" />.</para>
      </summary>
      <param name="name">Array variable name in the shader code.</param>
      <param name="values">Value array to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      <summary>
        <para>Set a texture parameter.</para>
        <para>This function can either set a regular texture that is read in the compute shader, or an output texture that is written into by the shader. For an output texture, it has to be a <see cref="T:UnityEngine.RenderTexture" /> with random write flag enabled, see <see cref="P:UnityEngine.RenderTexture.enableRandomWrite" />.Buffers and textures are set per-kernel. Use <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" /> to find kernel index by function name.See Also: <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" />, <see cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)" />, <see cref="P:UnityEngine.RenderTexture.enableRandomWrite" />.</para>
      </summary>
      <param name="kernelIndex">For which kernel the texture is being set. See <see cref="M:UnityEngine.ComputeShader.FindKernel(System.String)" />.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="texture">Texture to set.</param>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.See Also: <see cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])" />, <see cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)" />, <see cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])" />.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXDrive">
      <summary>Definition of how the joint's rotation will behave around its local X axis. Only used if Rotation Drive Mode is Swing &amp; Twist.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXLimitSpring">
      <summary>The configuration of the spring attached to the angular X limit of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXMotion">
      <summary>Allow rotation around the X axis to be Free, completely Locked, or Limited according to Low and High Angular XLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYLimit">
      <summary>Boundary defining rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYMotion">
      <summary>Allow rotation around the Y axis to be Free, completely Locked, or Limited according to Angular YLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYZDrive">
      <summary>Definition of how the joint's rotation will behave around its local Y and Z axes. Only used if Rotation Drive Mode is Swing &amp; Twist.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYZLimitSpring">
      <summary>The configuration of the spring attached to the angular Y and angular Z limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularZLimit">
      <summary>Boundary defining rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularZMotion">
      <summary>Allow rotation around the Z axis to be Free, completely Locked, or Limited according to Angular ZLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.configuredInWorldSpace">
      <summary>If enabled, all Target values will be calculated in world space instead of the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.highAngularXLimit">
      <summary>Boundary defining upper rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.linearLimit">
      <summary>Boundary defining movement restriction, based on distance from the joint's origin.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.linearLimitSpring">
      <summary>The configuration of the spring attached to the linear limit of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.lowAngularXLimit">
      <summary>Boundary defining lower rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionAngle">
      <summary>Set the angular tolerance threshold (in degrees) for projection.If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle).</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionDistance">
      <summary>Set the linear tolerance threshold for projection.If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle).</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionMode">
      <summary>Brings violated constraints back into alignment even when the solver fails. Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.rotationDriveMode">
      <summary>Control the object's rotation with either X &amp; YZ or Slerp Drive by itself.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.secondaryAxis">
      <summary>
        <para>The joint's secondary axis.</para>
        <para>Together, secondary and primary axes define the joint's coordinate space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.slerpDrive">
      <summary>Definition of how the joint's rotation will behave around all local axes. Only used if Rotation Drive Mode is Slerp Only.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.swapBodies">
      <summary>
        <para>If enabled, the two connected rigidbodies will be swapped, as if the joint was attached to the other body.</para>
        <para>Prior to Unity 3.4, this was wrongfully applied to all ConfigurableJoints with the <c>configuredInWorldSpace/</c> property set. If you want to restore the behaviour of older Unity versions and you are using	 <c>configuredInWorldSpace</c>, enable this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetAngularVelocity">
      <summary>This is a <see cref="T:UnityEngine.Vector3" />. It defines the desired angular velocity that the joint should rotate into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetPosition">
      <summary>The desired position that the joint should move into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetRotation">
      <summary>This is a <see cref="T:UnityEngine.Quaternion" />. It defines the desired rotation that the joint should rotate into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetVelocity">
      <summary>The desired velocity that the joint should move along.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.xDrive">
      <summary>Definition of how the joint's movement will behave along its local X axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.xMotion">
      <summary>Allow movement along the X axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.yDrive">
      <summary>Definition of how the joint's movement will behave along its local Y axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.yMotion">
      <summary>Allow movement along the Y axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.zDrive">
      <summary>Definition of how the joint's movement will behave along its local Z axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.zMotion">
      <summary>Allow movement along the Z axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.force">
      <summary>The force applied to the rigidbody every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.relativeForce">
      <summary>The force - relative to the rigid bodies coordinate system - applied every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.relativeTorque">
      <summary>The torque - relative to the rigid bodies coordinate system - applied every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.torque">
      <summary>The torque applied to the rigidbody every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.force">
      <summary>
        <para>The linear force applied to the rigidbody each physics update.</para>
        <para>The <c>force</c> is specified in the global coordinate frame i.e. independent of the rigid-body rotation and is applied to the center-of-mass therefore no torque is generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.relativeForce">
      <summary>
        <para>The linear force, relative to the rigid-body coordinate system, applied each physics update.</para>
        <para>The <c>force</c> is specified in the local rigid-body coordinate frame i.e. dependent on the rigid-body rotation and is applied to the center-of-mass therefore no torque is generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.torque">
      <summary>The torque applied to the rigidbody each physics update.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.normal">
      <summary>Normal of the contact point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.otherCollider">
      <summary>The other collider in contact at the point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.point">
      <summary>The point of contact.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.thisCollider">
      <summary>The first collider in contact at the point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.collider">
      <summary>The collider attached to the object receiving the collision message.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.normal">
      <summary>
        <para>Surface normal at the contact point.</para>
        <para>This is the normal vector (ie, the vector perpendicular to the surface) of the incoming Collider2D at the contact point.See Also: <see cref="T:UnityEngine.Collider2D" /> class.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.otherCollider">
      <summary>The incoming collider involved in the collision at this contact point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.point">
      <summary>The point of contact between the two colliders in world space.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.collider">
      <summary>The collider that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.controller">
      <summary>The controller that hit the collider.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.gameObject">
      <summary>The game object that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.moveDirection">
      <summary>
        <para>The direction the CharacterController was moving in when the collision occured.</para>
        <para>This is the direction that the CharacterController was moving in when the collision occured. It can be used to find a reasonable direction to apply forces to touched rigidbodies.Note that this is not necessarily the same as the movement vector passed to CharacterController.Move or CharacterController.SimpleMove. The CharacterController uses a sequence of motions to perform a move in accordance with the move direction and the step Offset, in order to step over obstacles. moveDirection will be the direction of the motion during which the collision was detected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.moveLength">
      <summary>
        <para>How far the character has travelled until it hit the collider.</para>
        <para>Note that this can is different from what you pass to CharacterController.Move, because all movement is constrained by collisions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.normal">
      <summary>
        <para>The normal of the surface we collided with in world space.</para>
        <para>Note: When the CharacterController is colliding with an edge or a corner rather than a flat surface, the reported normal may be different when colliding with BoxColliders than when colliding with MeshColliders. This is due to a limitation in how PhysX handles Capsule/BoxCollider collisions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.point">
      <summary>The impact point in world space.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.rigidbody">
      <summary>
        <para>The rigidbody that was hit by the controller.</para>
        <para>Null if we didn't touch a rigidbody but a static collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.transform">
      <summary>The transform that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.CrashReport.lastReport">
      <summary>Returns last crash report, or null if no reports are available.</summary>
    </member>
    <member name="P:UnityEngine.CrashReport.reports">
      <summary>Returns all currently available reports in a new array.</summary>
    </member>
    <member name="F:UnityEngine.CrashReport.text">
      <summary>
        <para>Crash report data as formatted text.</para>
        <para>NOTE: data provided and text format depends on the target platform.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CrashReport.time">
      <summary>Time, when the crash occured.</summary>
    </member>
    <member name="M:UnityEngine.CrashReport.Remove">
      <summary>Remove report from available reports list.</summary>
      <seealso cref="M:UnityEngine.CrashReport.RemoveAll" />
    </member>
    <member name="M:UnityEngine.CrashReport.RemoveAll">
      <summary>Remove all reports from available reports list.</summary>
      <seealso cref="M:UnityEngine.CrashReport.Remove" />
    </member>
    <member name="P:UnityEngine.Cubemap.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cubemap.mipmapCount">
      <summary>
        <para>How many mipmap levels are in this texture (Read Only).</para>
        <para>The returned value includes the base level as well, so it is always 1 or more.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.#ctor(System.Int32,UnityEngine.TextureFormat,System.Boolean)">
      <summary>
        <para>Create a new empty cubemap texture.</para>
        <para>The texture will be <c>size</c> on each side and can be created with or without mipmaps.Usually you will want to set the colors of the texture after creating it, using <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" /> functions.</para>
      </summary>
      <param name="size">Width/height of a cube face in pixels.</param>
      <param name="format">Pixel data format to be used for the Cubemap.</param>
      <param name="mipmap">Should mipmaps be created?</param>
      <seealso cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" />
      <seealso cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" />.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.See Also: <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> functions.</para>
      </summary>
      <param name="updateMipmaps">Should all mipmap levels be updated?</param>
      <param name="makeNoLongerReadable">Should the Cubemap texture data be readable/modifiable after changes are applied?</param>
    </member>
    <member name="M:UnityEngine.Cubemap.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" />.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.See Also: <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> functions.</para>
      </summary>
      <param name="updateMipmaps">Should all mipmap levels be updated?</param>
    </member>
    <member name="M:UnityEngine.Cubemap.Apply">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" />.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.See Also: <see cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel color at coordinates (face, x, y).</para>
        <para>If the pixel coordinates are out of bounds (larger than width/height or small than 0), they will be clamped or repeat based on the texture's wrap mode.The texture must have the Is Readable flag set in the import settings, otherwise this function will fail.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Returns pixel colors of a cubemap face.</para>
        <para>This function returns an array of pixel colors of the whole mip level of a cubemap face.The returned array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>.The texture must have the Is Readable flag set in the import settings, otherwise this function will fail.Using <c>GetPixels</c> can be faster than calling <see cref="M:UnityEngine.Cubemap.GetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels.See Also: <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
      <param name="face">The face from which pixel data is taken.</param>
      <param name="miplevel">Mipmap level for the chosen face.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace)">
      <summary>
        <para>Returns pixel colors of a cubemap face.</para>
        <para>This function returns an array of pixel colors of the whole mip level of a cubemap face.The returned array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>.The texture must have the Is Readable flag set in the import settings, otherwise this function will fail.Using <c>GetPixels</c> can be faster than calling <see cref="M:UnityEngine.Cubemap.GetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels.See Also: <see cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
      <param name="face">The face from which pixel data is taken.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets pixel color at coordinates (face, x, y).</para>
        <para>Call <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card. Uploading is an expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixel</c> is ignored.</para>
      </summary>
      <seealso cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Sets pixel colors of a cubemap face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole cubemap face. Call <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored.See Also: <see cref="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)" />, <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
      <param name="colors">Pixel data for the Cubemap face.</param>
      <param name="face">The face to which the new data should be applied.</param>
      <param name="miplevel">The mipmap level for the face.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace)">
      <summary>
        <para>Sets pixel colors of a cubemap face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole cubemap face. Call <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored.See Also: <see cref="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)" />, <see cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
      <param name="colors">Pixel data for the Cubemap face.</param>
      <param name="face">The face to which the new data should be applied.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.SmoothEdges(System.Int32)">
      <summary>
        <para>Performs smoothing of near edge regions.</para>
        <para>Helps to compensate lack of linear interpolation across the edges of cubemap in GPU.Usually you will want to call this function for the cubemap which is going to be used for glossy reflections.</para>
      </summary>
      <param name="smoothRegionWidthInPixels">Pixel distance at edges over which to apply smoothing.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.SmoothEdges">
      <summary>
        <para>Performs smoothing of near edge regions.</para>
        <para>Helps to compensate lack of linear interpolation across the edges of cubemap in GPU.Usually you will want to call this function for the cubemap which is going to be used for glossy reflections.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.enabled">
      <summary>
        <para>Pauses culling group execution.</para>
        <para>No events will be sent when the culling group is disabled. No state is cleared when disabling the culling group thus when you re-enable it, it will send visibility events relative to the last frame it was active on.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.onStateChanged">
      <summary>Sets the callback that will be called when a sphere's visibility and/or distance state has changed.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.targetCamera">
      <summary>
        <para>Locks the CullingGroup to a specific camera.</para>
        <para>If targetCamera is assigned then the bounding spheres will only be culled from the perspective of that camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.#ctor">
      <summary>Create a CullingGroup.</summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.Dispose">
      <summary>
        <para>Clean up all memory used by the CullingGroup immediately.</para>
        <para>The CullingGroup can no longer be used after this method has been called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.EraseSwapBack(System.Int32)">
      <summary>
        <para>Erase a given bounding sphere by moving the final sphere on top of it.</para>
        <para>This method also keeps the visibility information correctly synchronized, such that the correct onBecameVisible/onBecameInvisible callbacks will still be sent.</para>
      </summary>
      <param name="index">The index of the entry to erase.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.EraseSwapBack``1(System.Int32,``0[],System.Int32@)">
      <summary>
        <para>Erase a given entry in an arbitrary array by copying the final entry on top of it, then decrementing the number of entries used by one.</para>
        <para>This method is designed to be used in conjunction with the other overload, for updating your own data arrays when an entry is deleted.</para>
      </summary>
      <param name="index">The index of the entry to erase.</param>
      <param name="myArray">An array of entries.</param>
      <param name="size">The number of entries in the array that are actually used.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.GetDistance(System.Int32)">
      <summary>Get the current distance band index of a given sphere.</summary>
      <param name="index">The index of the sphere.</param>
      <returns>The sphere's current distance band index.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.IsVisible(System.Int32)">
      <summary>
        <para>Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.</para>
        <para>Note that this method uses the most recently computed visibility states. Visibility is updated immediately before rendering, so using this method in Update/LateUpdate will provide results based on calculations from the previous frame.</para>
      </summary>
      <param name="index">The index of the bounding sphere.</param>
      <returns>True if the sphere is visible; false if it is invisible.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Boolean,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter.The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="visible">True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Int32,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter.The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="distanceIndex">The distance band that retrieved spheres must be in.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Boolean,System.Int32,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter.The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="visible">True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.</param>
      <param name="distanceIndex">The distance band that retrieved spheres must be in.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])">
      <summary>
        <para>Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.</para>
        <para>Each distance value indicates a band that is 'up to' that distance; the array [10, 20, 30] describes distance bands "from 0 to 10m", "from 10m to 20m" and "from 20m to 30m."The distance from the reference point (set by CullingGroup.SetDistanceRefPoint) to the nearest edge of the sphere is used to calculate which distance band a sphere is in. Therefore a sphere that covers multiple distance bands will be considered to be in the nearest one to the reference point.The distanceBehaviours array describes how a sphere being in a given distance band should have its culling modified. For example, you might force any object within 20m to be visible even if it is behind the camera (to ensure that characters behind the player are still running full animation, audio, etc) while forcing any object beyond 200m to be invisible (effectively, culling spheres based on distance).In addition to forcing objects to be visible or invisible, you can use distance bands to drive level-of-detail changes in your objects. For example, you might define bands "from 0 to 40m" and "from 40m to 80m", and while you might have both bands apply occlusion and frustum culling as normal, you could have objects in the second band be animated with a less complex rig, or run a less complex AI behaviour.By default, any spheres beyond the final bounding distance are implicitly forced to be invisible. To avoid this, you can specify a final bounding distance of float.PositiveInfinity.</para>
      </summary>
      <param name="distances">An array of bounding distances. The distances should be sorted in increasing order.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingSphereCount(System.Int32)">
      <summary>
        <para>Sets the number of bounding spheres in the bounding spheres array that are actually being used.</para>
        <para>For performance reasons, you should not repeatedly re-allocate your bounding spheres array as new spheres are added and removed; instead you should create one array at the maximum size you will need, and then track the number of spheres that are actually being used within it. This way you avoid expensive allocation and copy operations.</para>
      </summary>
      <param name="count">The number of bounding spheres being used.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingSpheres(UnityEngine.BoundingSphere[])">
      <summary>
        <para>Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.</para>
        <para>Note that the provided array is simply referenced, not copied; therefore you can simply modify the data in the array on successive frames without calling SetBoundingSpheres again each time.</para>
      </summary>
      <param name="array">The <see cref="T:UnityEngine.BoundingSphere" />s to cull.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetDistanceReferencePoint(UnityEngine.Vector3)">
      <summary>Set the reference point from which distance bands are measured.</summary>
      <param name="point">A fixed point to measure the distance from.</param>
      <seealso cref="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])" />
    </member>
    <member name="M:UnityEngine.CullingGroup.SetDistanceReferencePoint(UnityEngine.Transform)">
      <summary>Set the reference point from which distance bands are measured.</summary>
      <param name="transform">A transform to measure the distance from. The transform's position will be automatically tracked.</param>
      <seealso cref="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])" />
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.currentDistance">
      <summary>The current distance band index of the sphere, after the most recent culling pass.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.hasBecomeInvisible">
      <summary>Did this sphere change from being visible to being invisible in the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.hasBecomeVisible">
      <summary>Did this sphere change from being invisible to being visible in the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.index">
      <summary>The index of the sphere that has changed.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.isVisible">
      <summary>Was the sphere considered visible by the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.previousDistance">
      <summary>The distance band index of the sphere before the most recent culling pass.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.wasVisible">
      <summary>Was the sphere visible before the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.Cursor.lockState">
      <summary>
        <para>How should the cursor be handled?</para>
        <para>When locked, the cursor will automatically be centered on view and made to never leave the view. This will primarily be used with <see cref="P:UnityEngine.Cursor.visible" /> = false. When confined, the cursor behave normally with the exception of being confined to the view.In the web player, the cursor may only be locked/confined after the user has clicked on the content and the user has not left the content view with the cursor. After the user presses escape or switches to another application the cursor will be automatically reset to normal. The cursor state will also be lost when exiting full screen mode.To provide a good user experience it is recommended to only lock or confine the cursor as a result of pressing a button. Also you should check if the cursor was reset, in order to e.g. pause the game or bring up a game menu. In the Web Player and Editor the cursor will automatically be reset when you press escape. In the Standalone Player you have full control over the mouse cursor, thus it won't automatically be reset unless you switch applications.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cursor.visible">
      <summary>Should the cursor be visible?</summary>
    </member>
    <member name="M:UnityEngine.Cursor.SetCursor(UnityEngine.Texture2D,UnityEngine.CursorMode)">
      <summary>Specify a custom cursor that you wish to use as a cursor.</summary>
    </member>
    <member name="M:UnityEngine.Cursor.SetCursor(UnityEngine.Texture2D,UnityEngine.Vector2,UnityEngine.CursorMode)">
      <summary>Specify a custom cursor that you wish to use as a cursor.</summary>
      <param name="texture">The texture to use for the cursor or null to set the default cursor. Note that a texture needs to be imported with "Read/Write enabled" in the texture importer (or using the "Cursor" defaults), in order to be used as a cursor.</param>
      <param name="hotspot">The offset from the top left of the texture to use as the target point (must be within the bounds of the cursor).</param>
      <param name="cursorMode">Allow this cursor to render as a hardware cursor on supported platforms, or force software cursor.</param>
    </member>
    <member name="P:UnityEngine.Debug.developerConsoleVisible">
      <summary>Opens or closes developer console.</summary>
    </member>
    <member name="P:UnityEngine.Debug.isDebugBuild">
      <summary>
        <para>In the Build Settings dialog there is a check box called "Development Build".</para>
        <para>If it is checked isDebugBuild will be true. In the editor <c>isDebugBuild</c> always returns true. It is recommended to remove all calls to Debug.Log when deploying a game, this way you can easily deploy beta builds with debug prints and final builds without.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean)">
      <summary>
        <para>Assert the condition.</para>
        <para>Message of a type of <see cref="F:UnityEngine.LogType.Assert" /> is logged.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean,System.String)">
      <summary>
        <para>Assert the condition.</para>
        <para>Message of a type of <see cref="F:UnityEngine.LogType.Assert" /> is logged.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean,System.String,System.Object[])">
      <summary>
        <para>Assert the condition.</para>
        <para>Message of a type of <see cref="F:UnityEngine.LogType.Assert" /> is logged.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="format">Formatted string for display.</param>
      <param name="args">Arguments for the formatted string.</param>
    </member>
    <member name="M:UnityEngine.Debug.Break">
      <summary>
        <para>Pauses the editor.</para>
        <para>This is useful when you want to check certain values on the inspector and you are not able to pause it manually.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.ClearDeveloperConsole">
      <summary>Clears errors from the developer console.</summary>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single,System.Boolean)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame.Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
      <param name="duration">How long the line should be visible for.</param>
      <param name="depthTest">Should the line be obscured by objects closer to the camera?</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame.Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
      <param name="duration">How long the line should be visible for.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame.Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame.Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single,System.Boolean)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame.If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
      <param name="duration">How long the line will be visible for (in seconds).</param>
      <param name="depthTest">Should the line be obscured by other objects closer to the camera?</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame.If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
      <param name="duration">How long the line will be visible for (in seconds).</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame.If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame.If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
    </member>
    <member name="M:UnityEngine.Debug.Log(System.Object)">
      <summary>
        <para>Logs <c>message</c> to the Unity Console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This can be useful for locating the object on which an error occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.Log(System.Object,UnityEngine.Object)">
      <summary>
        <para>Logs <c>message</c> to the Unity Console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This can be useful for locating the object on which an error occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogError(System.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogError(System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogErrorFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted error message to the Unity console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogErrorFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted error message to the Unity console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogException(System.Exception)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.LogException(System.Exception,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.LogFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogWarning(System.Object)">
      <summary>
        <para>A variant of Debug.Log that logs a warning message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object a warning occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogWarning(System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs a warning message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object a warning occurs.When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogWarningFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted warning message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogWarningFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted warning message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="P:UnityEngine.DetailPrototype.bendFactor">
      <summary>Bend factor of the detailPrototype.</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.dryColor">
      <summary>Color when the DetailPrototypes are "dry".</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.healthyColor">
      <summary>Color when the DetailPrototypes are "healthy".</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.maxHeight">
      <summary>Maximum height of the grass billboards (if render mode is GrassBillboard).</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.maxWidth">
      <summary>Maximum width of the grass billboards (if render mode is GrassBillboard).</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.minHeight">
      <summary>Minimum height of the grass billboards (if render mode is GrassBillboard).</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.minWidth">
      <summary>Minimum width of the grass billboards (if render mode is GrassBillboard).</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.noiseSpread">
      <summary>How spread out is the noise for the DetailPrototype.</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.prototype">
      <summary>GameObject used by the DetailPrototype.</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.prototypeTexture">
      <summary>Texture used by the DetailPrototype.</summary>
    </member>
    <member name="P:UnityEngine.DetailPrototype.renderMode">
      <summary>Render mode for the DetailPrototype.</summary>
    </member>
    <member name="F:UnityEngine.Display.displays">
      <summary>
        <para>The list of currently connected Displays. Contains at least one (main) display.</para>
        <para>It will be automatically updated should the display be connected/disconnected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Display.main">
      <summary>
        <para>Main Display.</para>
        <para>It is synonymous to Display.displays[0].</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Display.colorBuffer">
      <summary>Color RenderBuffer.</summary>
    </member>
    <member name="P:UnityEngine.Display.depthBuffer">
      <summary>Depth RenderBuffer.</summary>
    </member>
    <member name="P:UnityEngine.Display.renderingHeight">
      <summary>Rendering Height.</summary>
    </member>
    <member name="P:UnityEngine.Display.renderingWidth">
      <summary>Rendering Width.</summary>
    </member>
    <member name="P:UnityEngine.Display.systemHeight">
      <summary>
        <para>System Height.</para>
        <para>The native height of Display.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Display.systemWidth">
      <summary>
        <para>System Width.</para>
        <para>The native width of Display.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Display.Activate">
      <summary>
        <para>Activate an external display. Eg. Secondary Monitors connected to the System.</para>
        <para>The function Activate() will create a window of Screen width, Screen height and default Refresh Rates. This function is available on Windows, Linux and Mac platforms. The default primary Monitor is always indexed 0. Secondary Monitors range from 1 to 7. Ensure an external monitor is connected before Activating it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Display.Activate(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>This overloaded function available for Windows allows specifying desired Window Width, Height and Refresh Rate.</para>
        <para>The default primary Monitor is always indexed 0. Secondary Monitors range from 1 to 7. Ensure an external monitor is connected before Activating it.</para>
      </summary>
      <param name="width">Desired Width of the Window (for Windows only. On Linux and Mac uses Screen Width).</param>
      <param name="height">Desired Height of the Window (for Windows only. On Linux and Mac uses Screen Height).</param>
      <param name="refreshRate">Desired Refresh Rate.</param>
    </member>
    <member name="M:UnityEngine.Display.SetParams(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>This Windows only function can be used to set Size and Position of the Screen when Multi-Display is enabled.</para>
        <para>To change the size and position of Primary Display you must also activate Primary display by calling : Display.displays[0].Activate(0, 0, 0);</para>
      </summary>
      <param name="width">Change Window Width (Windows Only).</param>
      <param name="height">Change Window Height (Windows Only).</param>
      <param name="x">Change Window Position X (Windows Only).</param>
      <param name="y">Change Window Position Y (Windows Only).</param>
    </member>
    <member name="M:UnityEngine.Display.SetRenderingResolution(System.Int32,System.Int32)">
      <summary>Sets Rendering resolution for the display.</summary>
      <param name="w">Rendering width.</param>
      <param name="h">Rendering height.</param>
    </member>
    <member name="M:UnityEngine.Display.MultiDisplayLicense">
      <summary>Check if MultiDisplayLicense is enabled.</summary>
    </member>
    <member name="M:UnityEngine.Display.RelativeMouseAt(UnityEngine.Vector3)">
      <summary>
        <para>Query relative mouse coordinates.</para>
        <para>RelativeMouseAt can be used to query relative mouse input coordinates and the screen in which Mouse Input is recorded. This is only valid on the Windows Desktop platforms with Multiple Displays. x, y returns the coordinates in relative space and z returns the screen in which Mouse Input is handled.</para>
      </summary>
      <param name="inputMouseCoordinates">Mouse Input Position as Coordinates.</param>
    </member>
    <member name="P:UnityEngine.DistanceJoint2D.distance">
      <summary>The distance separating the two ends of the joint.</summary>
    </member>
    <member name="P:UnityEngine.DistanceJoint2D.maxDistanceOnly">
      <summary>Whether to maintain a maximum distance only or not. If not then the absolute distance will be maintained instead.</summary>
    </member>
    <member name="M:UnityEngine.DistanceJoint2D.GetReactionForce(System.Single)">
      <summary>Gets the reaction force of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction force for.</param>
    </member>
    <member name="M:UnityEngine.DistanceJoint2D.GetReactionTorque(System.Single)">
      <summary>Gets the reaction torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction torque for.</param>
    </member>
    <member name="M:UnityEngine.DrivenRectTransformTracker.Add(UnityEngine.Object,UnityEngine.RectTransform,UnityEngine.DrivenTransformProperties)">
      <summary>Add a RectTransform to be driven.</summary>
      <param name="driver">The object to drive properties.</param>
      <param name="rectTransform">The RectTransform to be driven.</param>
      <param name="drivenProperties">The properties to be driven.</param>
      <seealso cref="T:UnityEngine.RectTransform" />
      <seealso cref="T:UnityEngine.DrivenTransformProperties" />
    </member>
    <member name="M:UnityEngine.DrivenRectTransformTracker.Clear">
      <summary>Clear the list of RectTransforms being driven.</summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.indirectScale">
      <summary>Allows for scaling the contribution coming from realtime &amp; static lightmaps.</summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.synchronousMode">
      <summary>
        <para>When enabled, new dynamic Global Illumination output is shown in each frame.</para>
        <para>This affects performance a lot and should mostly be used for automated testing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.updateThreshold">
      <summary>
        <para>Threshold for limiting updates of realtime GI.</para>
        <para>A value of 0 means that the lightmap will update regardless of the amount of change in input lighting. A higher value causes the GI to only update when the threshold is exceeded. This is useful for saving CPU cycles and updating those parts of the scene where the lighting is being changed more frequently than other areas where the lighting is mostly static. The default value is 1.0.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.SetEmissive(UnityEngine.Renderer,UnityEngine.Color,System.Int32)">
      <summary>
        <para>Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.</para>
        <para>Note that a subsequent <see cref="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Renderer)" /> call on <c>any</c> renderer within the system will clear the effects of DynamicGI.SetEmissive.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateEnvironment">
      <summary>Schedules an update of the environment texture.</summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Renderer)">
      <summary>
        <para>Schedules an update of the albedo and emissive textures of a system that contains the renderer or the terrain.</para>
        <para>The third overload specifies a region of the terrain that needs to be updated. This makes sure that only the systems that overlap with the specified rectangle get updated, which could help improve performance. The coordinates are specified the same way as in <see cref="M:UnityEngine.TerrainData.SetAlphamaps(System.Int32,System.Int32,System.Single[,,])" />.</para>
      </summary>
      <param name="renderer">The <see cref="T:UnityEngine.Renderer" /> to use when searching for a system to update.</param>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Terrain)">
      <summary>
        <para>Schedules an update of the albedo and emissive textures of a system that contains the renderer or the terrain.</para>
        <para>The third overload specifies a region of the terrain that needs to be updated. This makes sure that only the systems that overlap with the specified rectangle get updated, which could help improve performance. The coordinates are specified the same way as in <see cref="M:UnityEngine.TerrainData.SetAlphamaps(System.Int32,System.Int32,System.Single[,,])" />.</para>
      </summary>
      <param name="terrain">The <see cref="T:UnityEngine.Terrain" /> to use when searching for systems to update.</param>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Terrain,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Schedules an update of the albedo and emissive textures of a system that contains the renderer or the terrain.</para>
        <para>The third overload specifies a region of the terrain that needs to be updated. This makes sure that only the systems that overlap with the specified rectangle get updated, which could help improve performance. The coordinates are specified the same way as in <see cref="M:UnityEngine.TerrainData.SetAlphamaps(System.Int32,System.Int32,System.Single[,,])" />.</para>
      </summary>
      <param name="terrain">The <see cref="T:UnityEngine.Terrain" /> to use when searching for systems to update.</param>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.edgeCount">
      <summary>
        <para>Gets the number of edges.</para>
        <para>This is one less than the number of points.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.pointCount">
      <summary>
        <para>Gets the number of points.</para>
        <para>This cannot be less than two which will form a single edge.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.points">
      <summary>Get or set the points defining multiple continuous edges.</summary>
    </member>
    <member name="M:UnityEngine.EdgeCollider2D.Reset">
      <summary>Reset to a single edge consisting of two points.</summary>
    </member>
    <member name="P:UnityEngine.Effector2D.colliderMask">
      <summary>
        <para>The mask used to select specific layers allowed to interact with the effector.</para>
        <para>Any <see cref="T:UnityEngine.Collider2D" /> used by the effector will only interact with colliders on the specified layers. The layer on the GameObject will not be used by these colliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Effector2D.useColliderMask">
      <summary>Should the collider-mask be used or the global collision matrix?</summary>
    </member>
    <member name="P:UnityEngine.Event.current">
      <summary>The current event that's being processed right now.</summary>
    </member>
    <member name="P:UnityEngine.Event.alt">
      <summary>
        <para>Is Alt/Option key held down? (Read Only)</para>
        <para>On Windows, this returns true if any Alt key is held down. On Mac, this returns true if any Option key is held down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.button">
      <summary>
        <para>Which mouse button was pressed.</para>
        <para>0 means left mouse button, 1 means right mouse button, 2 means middle mouse button. Used in EventType.MouseDown, EventType.MouseUp events.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.capsLock">
      <summary>
        <para>Is Caps Lock on? (Read Only)</para>
        <para>Returns true if Caps Lock is switched on.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.character">
      <summary>
        <para>The character typed.</para>
        <para>Used in EventType.KeyDown event. Note that EventType.KeyUp events might not contain a character, only Event.keyCode.See Also: Event.keyCode.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.clickCount">
      <summary>
        <para>How many consecutive mouse clicks have we received.</para>
        <para>Used in EventType.MouseDown event; use this to differentiate between a single and double clicks.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.command">
      <summary>
        <para>Is Command/Windows key held down? (Read Only)</para>
        <para>On Windows, this returns true if any Windows key is held down. On Mac, this returns true if any Command key is held down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.commandName">
      <summary>
        <para>The name of an ExecuteCommand or ValidateCommand Event.</para>
        <para>"Copy", "Cut", "Paste", "Delete", "FrameSelected", "Duplicate", "SelectAll" and so on. Sent only in the editor.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.control">
      <summary>
        <para>Is Control key held down? (Read Only)</para>
        <para>Returns true if any Control key is held down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.delta">
      <summary>
        <para>The relative movement of the mouse compared to last event.</para>
        <para>Used in EventType.MouseMove, EventType.MouseDrag, EventType.ScrollWheel events.See Also: Event.mousePosition.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.functionKey">
      <summary>
        <para>Is the current keypress a function key? (Read Only)</para>
        <para>Returns true if the current keypress is an arrow key, page up, page down, backspace, etc. key. If this key needs special processing in order to work in text editing, <c>functionKey</c> is on.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.isKey">
      <summary>Is this event a keyboard event? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Event.isMouse">
      <summary>Is this event a mouse event? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Event.keyCode">
      <summary>
        <para>The raw key code for keyboard events.</para>
        <para>Used in EventType.KeyDown and EventType.KeyUp events; this returns <see cref="T:UnityEngine.KeyCode" /> value that matches the physical keyboard key. Use this for handling cursor keys, function keys etc.See Also: Event.character.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.modifiers">
      <summary>Which modifier keys are held down.</summary>
    </member>
    <member name="P:UnityEngine.Event.mousePosition">
      <summary>
        <para>The mouse position.</para>
        <para>Used in EventType.MouseMove and EventType.MouseDrag events.See Also: Event.delta.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.numeric">
      <summary>
        <para>Is the current keypress on the numeric keyboard? (Read Only)</para>
        <para>Use this flag to destinguish between main &amp; numeric keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.shift">
      <summary>
        <para>Is Shift held down? (Read Only)</para>
        <para>Returns true if any Shift key is held down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Event.type">
      <summary>The type of event.</summary>
    </member>
    <member name="M:UnityEngine.Event.GetTypeForControl(System.Int32)">
      <summary>
        <para>Get a filtered event type for a given control ID.</para>
        <para>This function is used to implement mouse locking and keyboard focus. The controlID can be obtained from GUIUtilty.GetControlID ().</para>
      </summary>
      <param name="controlID">The ID of the control you are querying from.</param>
    </member>
    <member name="M:UnityEngine.Event.Use">
      <summary>
        <para>Use this event.</para>
        <para>Call this method when you've used an event. The event's type will be set to EventType.Used, causing other GUI elements to ignore it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Event.GetEventCount">
      <summary>Returns the current number of events that are stored in the event queue.</summary>
      <returns>Current number of events currently in the event queue.</returns>
    </member>
    <member name="M:UnityEngine.Event.KeyboardEvent(System.String)">
      <summary>
        <para>Create a keyboard event.</para>
        <para>This is useful when you need to check if a certain key has been pressed - possibly with modifiers. The syntax for the key string is a key name (same as in the Input Manager), optionally prefixed by any number of modifiers: &amp; = Alternate, ^ = Control, % = Command/Windows key, # = Shift Examples: &amp;f12 = Alternate + F12, "^[0]" = Control + keypad0 .</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Event.PopEvent(UnityEngine.Event)">
      <summary>Get the next queued [Event] from the event system.</summary>
      <param name="outEvent">Next Event.</param>
    </member>
    <member name="P:UnityEngine.Font.ascent">
      <summary>
        <para>The ascent of the font.</para>
        <para>The ascent of the font is the distance from the baseline to the top line of the font, as defined in the font's original data file.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Font.characterInfo">
      <summary>
        <para>Access an array of all characters contained in the font texture.</para>
        <para>You can read this if you want to render the font texture using custom generated Meshes, or you can set it when you want to build your own custom font assets from scripts (or modify existing ones).See Also: <see cref="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Font.dynamic">
      <summary>Is the font a dynamic font.</summary>
    </member>
    <member name="P:UnityEngine.Font.fontSize">
      <summary>The default size of the font.</summary>
    </member>
    <member name="P:UnityEngine.Font.lineHeight">
      <summary>
        <para>The line height of the font.</para>
        <para>This is the line height of the font, used to align lines of text above each other.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Font.material">
      <summary>The material used for the font display.</summary>
    </member>
    <member name="M:UnityEngine.Font.#ctor">
      <summary>
        <para>Create a new Font.</para>
        <para>You may want to use this if you need to create Font objects programmatically to set up your own font by assigning the Font.characterInfo property.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Font.#ctor(System.String)">
      <summary>
        <para>Create a new Font.</para>
        <para>You may want to use this if you need to create Font objects programmatically to set up your own font by assigning the Font.characterInfo property.</para>
      </summary>
      <param name="name">The name of the created Font object.</param>
    </member>
    <member name="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32,UnityEngine.FontStyle)">
      <summary>
        <para>Get rendering info for a specific character.</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. If the character <c>ch</c> with the specified <c>size</c> and <c>style</c> is present in the font texture, then this method will return true, and info will contain the texture placement information for that character. If the character is not present, this method returns false. If <c>size</c> is zero, it will use the default size for the font.See Also: <see cref="P:UnityEngine.Font.characterInfo" />. Example at <see cref="M:UnityEngine.Font.RequestCharactersInTexture(System.String,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="ch">The character you need rendering information for.</param>
      <param name="info">Returns the CharacterInfo struct with the rendering information for the character (if available).</param>
      <param name="size">The size of the character (default value of zero will use font default size).</param>
      <param name="style">The style of the character.</param>
    </member>
    <member name="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32)">
      <summary>
        <para>Get rendering info for a specific character.</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. If the character <c>ch</c> with the specified <c>size</c> and <c>style</c> is present in the font texture, then this method will return true, and info will contain the texture placement information for that character. If the character is not present, this method returns false. If <c>size</c> is zero, it will use the default size for the font.See Also: <see cref="P:UnityEngine.Font.characterInfo" />. Example at <see cref="M:UnityEngine.Font.RequestCharactersInTexture(System.String,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="ch">The character you need rendering information for.</param>
      <param name="info">Returns the CharacterInfo struct with the rendering information for the character (if available).</param>
      <param name="size">The size of the character (default value of zero will use font default size).</param>
    </member>
    <member name="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@)">
      <summary>
        <para>Get rendering info for a specific character.</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. If the character <c>ch</c> with the specified <c>size</c> and <c>style</c> is present in the font texture, then this method will return true, and info will contain the texture placement information for that character. If the character is not present, this method returns false. If <c>size</c> is zero, it will use the default size for the font.See Also: <see cref="P:UnityEngine.Font.characterInfo" />. Example at <see cref="M:UnityEngine.Font.RequestCharactersInTexture(System.String,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="ch">The character you need rendering information for.</param>
      <param name="info">Returns the CharacterInfo struct with the rendering information for the character (if available).</param>
    </member>
    <member name="M:UnityEngine.Font.HasCharacter(System.Char)">
      <summary>
        <para>Does this font have a specific character?</para>
        <para>This function checks whether the font has a particular character defined. Some fonts do not have all characters defined (for example, no symbols, or no lower case characters).</para>
      </summary>
      <param name="c">The character to check for.</param>
      <returns>Whether or not the font has the character specified.</returns>
    </member>
    <member name="M:UnityEngine.Font.RequestCharactersInTexture(System.String,System.Int32,UnityEngine.FontStyle)">
      <summary>
        <para>Request characters to be added to the font texture (dynamic fonts only).</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. Call this function to request Unity to make sure all the characters in the string <c>characters</c> are available in the font's font texture (and it's <c>characterInfo</c> property). This is useful when you want to implement your own code to render dynamic fonts. You can supply a custom font size and style for the characters. If <c>size</c> is zero (the default), it will use the default size for that font.RequestCharactersInTexture may cause the font texture to be regenerated if it does not have space to add all the requested characters. If the font texture is regenerated it will only contain characters which have been used using Font.RequestCharactersInTexture, or using Unity's text rendering functions during the last frame. So it is advisable to always call RequestCharactersInTexture for any text on the screen you wish to render using custom font rendering functions, even if the characters are currently present in the texture, to make sure they don't get purged during texture rebuild.See Also: <c>textureRebuilt</c>, <see cref="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="characters">The characters which are needed to be in the font texture.</param>
      <param name="size">The size of the requested characters (the default value of zero will use the font's default size).</param>
      <param name="style">The style of the requested characters.</param>
    </member>
    <member name="M:UnityEngine.Font.RequestCharactersInTexture(System.String,System.Int32)">
      <summary>
        <para>Request characters to be added to the font texture (dynamic fonts only).</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. Call this function to request Unity to make sure all the characters in the string <c>characters</c> are available in the font's font texture (and it's <c>characterInfo</c> property). This is useful when you want to implement your own code to render dynamic fonts. You can supply a custom font size and style for the characters. If <c>size</c> is zero (the default), it will use the default size for that font.RequestCharactersInTexture may cause the font texture to be regenerated if it does not have space to add all the requested characters. If the font texture is regenerated it will only contain characters which have been used using Font.RequestCharactersInTexture, or using Unity's text rendering functions during the last frame. So it is advisable to always call RequestCharactersInTexture for any text on the screen you wish to render using custom font rendering functions, even if the characters are currently present in the texture, to make sure they don't get purged during texture rebuild.See Also: <c>textureRebuilt</c>, <see cref="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="characters">The characters which are needed to be in the font texture.</param>
      <param name="size">The size of the requested characters (the default value of zero will use the font's default size).</param>
    </member>
    <member name="M:UnityEngine.Font.RequestCharactersInTexture(System.String)">
      <summary>
        <para>Request characters to be added to the font texture (dynamic fonts only).</para>
        <para>Note: You should only ever need to use this when you want to implement your own text rendering. Call this function to request Unity to make sure all the characters in the string <c>characters</c> are available in the font's font texture (and it's <c>characterInfo</c> property). This is useful when you want to implement your own code to render dynamic fonts. You can supply a custom font size and style for the characters. If <c>size</c> is zero (the default), it will use the default size for that font.RequestCharactersInTexture may cause the font texture to be regenerated if it does not have space to add all the requested characters. If the font texture is regenerated it will only contain characters which have been used using Font.RequestCharactersInTexture, or using Unity's text rendering functions during the last frame. So it is advisable to always call RequestCharactersInTexture for any text on the screen you wish to render using custom font rendering functions, even if the characters are currently present in the texture, to make sure they don't get purged during texture rebuild.See Also: <c>textureRebuilt</c>, <see cref="M:UnityEngine.Font.GetCharacterInfo(System.Char,UnityEngine.CharacterInfo@,System.Int32,UnityEngine.FontStyle)" />.</para>
      </summary>
      <param name="characters">The characters which are needed to be in the font texture.</param>
    </member>
    <member name="M:UnityEngine.Font.CreateDynamicFontFromOSFont(System.String,System.Int32)">
      <summary>
        <para>Creates a Font object which lets you render a font installed on the user machine.</para>
        <para>CreateDynamicFontFromOSFont creates a font object which references fonts from the OS. This lets you render text using any font installed on the user's machine. See <see cref="M:UnityEngine.Font.GetOSInstalledFontNames" /> for getting names of installed fonts at runtime, which can be used with this function.</para>
      </summary>
      <param name="fontname">The name of the OS font to use for this font object.</param>
      <param name="size">The default character size of the generated font.</param>
      <returns>The generate Font object.</returns>
    </member>
    <member name="M:UnityEngine.Font.CreateDynamicFontFromOSFont(System.String[],System.Int32)">
      <summary>
        <para>Creates a Font object which lets you render a font installed on the user machine.</para>
        <para>CreateDynamicFontFromOSFont creates a font object which references fonts from the OS. This lets you render text using any font installed on the user's machine. See <see cref="M:UnityEngine.Font.GetOSInstalledFontNames" /> for getting names of installed fonts at runtime, which can be used with this function.</para>
      </summary>
      <param name="fontnames">Am array of names of OS fonts to use for this font object. When rendering characters using this font object, the first font which is installed on the machine, which contains the requested character will be used.</param>
      <param name="size">The default character size of the generated font.</param>
      <returns>The generate Font object.</returns>
    </member>
    <member name="M:UnityEngine.Font.GetMaxVertsForString(System.String)">
      <summary>Returns the maximum number of verts that the text generator may return for a given string.</summary>
      <param name="str">Input string.</param>
    </member>
    <member name="M:UnityEngine.Font.GetOSInstalledFontNames">
      <summary>
        <para>Get names of fonts installed on the machine.</para>
        <para>GetOSInstalledFontNames lets you get the names of all the fonts installed on the machine. These names can be passed to <see cref="M:UnityEngine.Font.CreateDynamicFontFromOSFont(System.String,System.Int32)" />, to dynamically render text using any font installed on the user's OS.</para>
      </summary>
      <returns>An array of the names of all fonts installed on the machine.</returns>
    </member>
    <member name="P:UnityEngine.GameObject.activeInHierarchy">
      <summary>
        <para>Is the GameObject active in the scene?</para>
        <para>This lets you know if a gameObject is active in the game. That is the case if its <see cref="P:UnityEngine.GameObject.activeSelf" /> property is enabled, as well as that of all it's parents.See Also: <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" />, <see cref="P:UnityEngine.GameObject.activeSelf" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.activeSelf">
      <summary>
        <para>The local active state of this GameObject. (Read Only)</para>
        <para>This returns the local active state of this GameObject, which is set using <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" />. Note that a GameObject may be inactive because a parent is not active, even if this returns true. This state will then be used once all parents are active. Use <see cref="P:UnityEngine.GameObject.activeInHierarchy" /> if you want to check if the GameObject is actually treated as active in the scene.See Also: <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" />, <see cref="P:UnityEngine.GameObject.activeInHierarchy" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.isStatic">
      <summary>
        <para>Editor only API that specifies if a game object is static.</para>
        <para>Returns true if any of the static flags are set.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.layer">
      <summary>
        <para>The layer the game object is in. A layer is in the range [0...31].</para>
        <para>Layers can be used for selective rendering from cameras or ignoring raycasts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.tag">
      <summary>
        <para>The tag of this game object.</para>
        <para>A tag can be used to identify a game object. Tags must be declared in the Tags and Layers manager before using them.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.transform">
      <summary>The <see cref="T:UnityEngine.Transform" /> attached to this GameObject. (null if there is none attached).</summary>
    </member>
    <member name="M:UnityEngine.GameObject.#ctor(System.String)">
      <summary>
        <para>Creates a new game object, named name.</para>
        <para>A <see cref="T:UnityEngine.Transform" /> is always added to the game object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.#ctor">
      <summary>
        <para>Creates a new game object.</para>
        <para>A <see cref="T:UnityEngine.Transform" /> is always added to the game object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.#ctor(System.String,System.Type[])">
      <summary>Creates a game object and attaches the specified components.</summary>
    </member>
    <member name="M:UnityEngine.GameObject.AddComponent(System.String)">
      <summary>
        <para>Adds a component class named <c>className</c> to the game object.</para>
        <para>Use this function to change behaviour of objects on the fly. You can also add script to game objects by passing in the name of the script class.Some components require other components to exist in the same game object as well. This function automatically adds any required components as well eg. if you add a <see cref="T:UnityEngine.HingeJoint" /> this will automatically add a <see cref="T:UnityEngine.Rigidbody" /> as well.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.AddComponent(System.Type)">
      <summary>
        <para>Adds a component class of type <c>componentType</c> to the game object. C# Users can use a generic version.</para>
        <para>Note that there is no RemoveComponent(), to remove a component, use Object.Destroy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.AddComponent``1">
      <summary>
        <para>Adds a component class of type <c>componentType</c> to the game object. C# Users can use a generic version.</para>
        <para>Note that there is no RemoveComponent(), to remove a component, use Object.Destroy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.CompareTag(System.String)">
      <summary>Is this game object tagged with <c>tag</c> ?</summary>
      <param name="tag">The tag to compare.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponent(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>GetComponent is the primary way of accessing other components. From javascript the type of a script is always the name of the script as seen in the project view. You can access both builtin components or scripts with this function.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponent``1">
      <summary>
        <para>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>GetComponent is the primary way of accessing other components. From javascript the type of a script is always the name of the script as seen in the project view. You can access both builtin components or scripts with this function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponent(System.String)">
      <summary>
        <para>Returns the component with name <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>It is better to use GetComponent with a Type instead of a string for performance reasons. Sometimes you might not be able to get to the type however, for example when trying to access a C# script from Javascript. In that case you can simply access the component by name instead of type.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInChildren(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the GameObject or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInChildren``1">
      <summary>
        <para>Returns the component of Type <c>type</c> in the GameObject or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInParent(System.Type)">
      <summary>
        <para>Finds component in the parent.</para>
        <para>Recurses upwards till it finds a valid component. Returns null if no component found.</para>
      </summary>
      <param name="type">Type of component to find.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInParent``1">
      <summary>
        <para>Finds component in the parent.</para>
        <para>Recurses upwards till it finds a valid component. Returns null if no component found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponents(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the GameObject.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponents``1">
      <summary>Returns all components of Type <c>type</c> in the GameObject.</summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren(System.Type,System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <param name="includeInactive">Should Components on inactive GameObjects be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren(System.Type)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren``1(System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren``1">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent(System.Type,System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent(System.Type)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent``1(System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent``1">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
      <param name="options">Should an error be raised if the method doesn't exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
      <param name="options">Should an error be raised if the method doesn't exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="T:UnityEngine.MonoBehaviour" /> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)" /> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SetActive(System.Boolean)">
      <summary>
        <para>Activates/Deactivates the GameObject.</para>
        <para>Note that a GameObject may be inactive because a parent is not active. In that case, calling SetActive() will not activate it, but only set the local state of the GameObject, which can be checked using <see cref="P:UnityEngine.GameObject.activeSelf" />. This state will then be used once all parents are active. Making a GameObject inactive will disable every component, turning off any attached renderers, colliders, rigidbodies, scripts, etc... Any scripts that you have attached to the GameObject will no longer have <c>Update()</c> called, for example.See Also: <see cref="P:UnityEngine.GameObject.activeSelf" />, <see cref="P:UnityEngine.GameObject.activeInHierarchy" />.</para>
      </summary>
      <param name="value">Activate or deactivation the object.</param>
    </member>
    <member name="M:UnityEngine.GameObject.CreatePrimitive(UnityEngine.PrimitiveType)">
      <summary>Creates a game object with a primitive mesh renderer and appropriate collider.</summary>
      <param name="type">The type of primitive object to create.</param>
    </member>
    <member name="M:UnityEngine.GameObject.Find(System.String)">
      <summary>
        <para>Finds a game object by <c>name</c> and returns it.</para>
        <para>If no game object with <c>name</c> can be found, null is returned. If <c>name</c> contains a '/' character it will traverse the hierarchy like a path name. This function only returns active gameobjects.For performance reasons it is recommended to not use this function every frame Instead cache the result in a member variable at startup or use GameObject.FindWithTag.</para>
        <para>This function is most useful to automatically connect references to other objects at load time, eg. inside MonoBehaviour.Awake or MonoBehaviour.Start. You should avoid calling this function every frame eg. MonoBehaviour.Update for performance reasons. A common pattern is to assign a game object to a variable inside MonoBehaviour.Start. And use the variable in MonoBehaviour.Update.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.FindGameObjectsWithTag(System.String)">
      <summary>
        <para>Returns a list of active GameObjects tagged <c>tag</c>. Returns empty array if no GameObject was found.</para>
        <para>Tags must be declared in the tag manager before using them. A <c>UnityException</c> will be thrown if the tag does not exist or an empty string or <c>null</c> is passed as the tag.</para>
      </summary>
      <param name="tag">The name of the tag to search <c>GameObjects</c> for.</param>
    </member>
    <member name="M:UnityEngine.GameObject.FindWithTag(System.String)">
      <summary>
        <para>Returns one active <see cref="T:UnityEngine.GameObject" /> tagged <c>tag</c>. Returns <c>null</c> if no GameObject was found.</para>
        <para>Tags must be declared in the tag manager before using them. A <c>UnityException</c> will be thrown if the tag does not exist or an empty string or <c>null</c> is passed as the tag.</para>
      </summary>
      <param name="tag">The tag to search for.</param>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Camera)">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function takes given camera's view frustum and returns six planes that form it.See Also: <see cref="T:UnityEngine.Plane" />, <see cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Matrix4x4)">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function returns six planes of a frustum defined by given view &amp; projection matrix.See Also: <see cref="T:UnityEngine.Plane" />, <see cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      <summary>
        <para>Returns true if bounds are inside the plane array.</para>
        <para>Will return true if the bounding box is inside the planes or intersects any of the planes.The TestPlanesAABB function uses the Plane array to test whether a bounding box is in the frustum or not. You can use this function with CalculateFrustrumPlanes to test whether a camera's view contains an object regardless of whether it is rendered or not.See Also: GeometryUtility.CalculateFrustumPlanes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gizmos.color">
      <summary>Sets the color for the gizmos that will be drawn next.</summary>
    </member>
    <member name="P:UnityEngine.Gizmos.matrix">
      <summary>Set the gizmo matrix used to draw all gizmos.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawCube(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draw a solid box with <c>center</c> and <c>size</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawFrustum(UnityEngine.Vector3,System.Single,System.Single,System.Single,System.Single)">
      <summary>Draw a camera frustum using the currently set Gizmos.matrix for it's location and rotation.</summary>
      <param name="center">The apex of the truncated pyramid.</param>
      <param name="fov">Vertical field of view (ie, the angle at the apex in degrees).</param>
      <param name="maxRange">Distance of the frustum's far plane.</param>
      <param name="minRange">Distance of the frustum's near plane.</param>
      <param name="aspect">Width/height ratio.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour.This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="mat">An optional material to apply the texture.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour.This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour.This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="leftBorder">Inset from the rectangle's left edge.</param>
      <param name="rightBorder">Inset from the rectangle's right edge.</param>
      <param name="topBorder">Inset from the rectangle's top edge.</param>
      <param name="bottomBorder">Inset from the rectangle's bottom edge.</param>
      <param name="mat">An optional material to apply the texture.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour.This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="leftBorder">Inset from the rectangle's left edge.</param>
      <param name="rightBorder">Inset from the rectangle's right edge.</param>
      <param name="topBorder">Inset from the rectangle's top edge.</param>
      <param name="bottomBorder">Inset from the rectangle's bottom edge.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawIcon(UnityEngine.Vector3,System.String,System.Boolean)">
      <summary>
        <para>Draw an icon at a position in the scene view.</para>
        <para>The image filename for the icon is specified with the name parameter while the center parameter denotes the location of the icon in world space and the allowScaling parameter determines if the icon is allowed to be scaled. The image file should be placed in the Assets/Gizmos folder.DrawIcon can be used to allow important objects in your game to be selected quickly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawIcon(UnityEngine.Vector3,System.String)">
      <summary>
        <para>Draw an icon at a position in the scene view.</para>
        <para>The image filename for the icon is specified with the name parameter while the center parameter denotes the location of the icon in world space and the allowScaling parameter determines if the icon is allowed to be scaled. The image file should be placed in the Assets/Gizmos folder.DrawIcon can be used to allow important objects in your game to be selected quickly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draws a line starting at <c>from</c> towards <c>to</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawRay(UnityEngine.Ray)">
      <summary>Draws a ray starting at <c>from</c> to <c>from</c> + <c>direction</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draws a ray starting at <c>from</c> to <c>from</c> + <c>direction</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawSphere(UnityEngine.Vector3,System.Single)">
      <summary>Draws a solid sphere with <c>center</c> and <c>radius</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireCube(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draw a wireframe box with <c>center</c> and <c>size</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireSphere(UnityEngine.Vector3,System.Single)">
      <summary>Draws a wireframe sphere with <c>center</c> and <c>radius</c>.</summary>
    </member>
    <member name="P:UnityEngine.GL.invertCulling">
      <summary>
        <para>Select whether to invert the backface culling (true) or not (false).</para>
        <para>This flag can "flip" the culling mode of all rendered objects. Major use case: rendering reflections for mirrors, water etc. Since virtual camera for rendering the reflection is mirrored, the culling order has to be inverted. You can see how the Water script in Effects standard package does that.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.LINES">
      <summary>
        <para>Mode for <see cref="M:UnityEngine.GL.Begin(System.Int32)" />: draw lines.</para>
        <para>If you want to draw something 2D in screen space then probably you will want to use GL.LoadOrtho or GL.LoadPixelMatrix. If you want something in "3D", then probably you should consider using GL.LoadIdentity followed by GL.MultMatrix with the actual 3D transform you want your stuff to be in.See Also: GL.Begin, GL.End.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.modelview">
      <summary>
        <para>The current modelview matrix.</para>
        <para>Assigning to this variable is equivalent to <c>glLoadMatrix(mat)</c> in OpenGL; in other graphics APIs the corresponding functionality is emulated.Changing modelview matrix overrides current camera's view parameters, so most often you want to save and restore matrix using GL.PushMatrix and GL.PopMatrix.Reading this variable returns the current modelview matrix.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.QUADS">
      <summary>
        <para>Mode for <see cref="M:UnityEngine.GL.Begin(System.Int32)" />: draw quads.</para>
        <para>If you want to draw something 2D in screen space then probably you will want to use GL.LoadOrtho or GL.LoadPixelMatrix. If you want something in "3D", then probably you should consider using GL.LoadIdentity followed by GL.MultMatrix with the actual 3D transform you want your stuff to be in.See Also: GL.Begin, GL.End.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.TRIANGLE_STRIP">
      <summary>
        <para>Mode for <see cref="M:UnityEngine.GL.Begin(System.Int32)" />: draw triangle strip.</para>
        <para>If you want to draw something 2D in screen space then probably you will want to use GL.LoadOrtho or GL.LoadPixelMatrix. If you want something in "3D", then probably you should consider using GL.LoadIdentity followed by GL.MultMatrix with the actual 3D transform you want your stuff to be in.See Also: GL.Begin, GL.End.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.TRIANGLES">
      <summary>
        <para>Mode for <see cref="M:UnityEngine.GL.Begin(System.Int32)" />: draw triangles.</para>
        <para>If you want to draw something 2D in screen space then probably you will want to use GL.LoadOrtho or GL.LoadPixelMatrix. If you want something in "3D", then probably you should consider using GL.LoadIdentity followed by GL.MultMatrix with the actual 3D transform you want your stuff to be in.See Also: GL.Begin, GL.End.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.wireframe">
      <summary>
        <para>Should rendering be done in wireframe?</para>
        <para>Turning on wireframe mode will affect all objects rendered after the call, until you turn wireframe back off. In the Unity editor, wireframe mode is always turned off before repainting any window.Note that some platforms, for example mobile (OpenGL ES) does not support wireframe rendering.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Begin(System.Int32)">
      <summary>
        <para>Begin drawing 3D primitives.</para>
        <para>In OpenGL this matches <c>glBegin</c>; on other graphics APIs the same functionality is emulated. Between GL.Begin and GL.End it is valid to call GL.Vertex, GL.Color, GL.TexCoord and other immediate mode drawing functions.You should be careful about culling when drawing primitives yourself. The culling rules may be different depending on which graphics API the game is running. In most cases the safest way is to use <c>Cull Off</c> command in the shader.See Also: GL.End.</para>
      </summary>
      <param name="mode">Primitives to draw: can be <see cref="F:UnityEngine.GL.TRIANGLES" />, <see cref="F:UnityEngine.GL.TRIANGLE_STRIP" />, <see cref="F:UnityEngine.GL.QUADS" /> or <see cref="F:UnityEngine.GL.LINES" />.</param>
    </member>
    <member name="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      <summary>
        <para>Clear the current render buffer.</para>
        <para>This clears the screen or the active <see cref="T:UnityEngine.RenderTexture" /> you are drawing into. In most other situations, some camera is drawing something somewhere, and probably is clearing already with the background color of the skybox.See Also: <see cref="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)" />.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="clearColor">Should the color buffer be cleared?</param>
      <param name="backgroundColor">The color to clear with, used only if <c>clearColor</c> is <c>true</c>.</param>
      <param name="depth">The depth to clear Z buffer with, used only if <c>clearDepth</c> is <c>true</c>.</param>
    </member>
    <member name="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color)">
      <summary>
        <para>Clear the current render buffer.</para>
        <para>This clears the screen or the active <see cref="T:UnityEngine.RenderTexture" /> you are drawing into. In most other situations, some camera is drawing something somewhere, and probably is clearing already with the background color of the skybox.See Also: <see cref="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)" />.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="clearColor">Should the color buffer be cleared?</param>
      <param name="backgroundColor">The color to clear with, used only if <c>clearColor</c> is <c>true</c>.</param>
    </member>
    <member name="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)">
      <summary>
        <para>Clear the current render buffer with camera's skybox.</para>
        <para>This draws skybox into the screen or the active <see cref="T:UnityEngine.RenderTexture" />. If the passed camera does not have custom <see cref="T:UnityEngine.Skybox" /> component, the global skybox from <see cref="T:UnityEngine.RenderSettings" /> will be used.See Also: <see cref="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)" />.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="camera">Camera to get projection parameters and skybox from.</param>
    </member>
    <member name="M:UnityEngine.GL.Color(UnityEngine.Color)">
      <summary>
        <para>Sets current vertex color.</para>
        <para>In OpenGL this matches <c>glColor4f(c.r,c.g,c.b,c.a)</c>; on other graphics APIs the same functionality is emulated.In order for per-vertex colors to work reliably across different hardware, you have to use a shader that binds in the color channel. See BindChannels documentation.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.End">
      <summary>
        <para>End drawing 3D primitives.</para>
        <para>In OpenGL this matches <c>glEnd</c>; on other graphics APIs the same functionality is emulated.See Also: GL.Begin.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.GetGPUProjectionMatrix(UnityEngine.Matrix4x4,System.Boolean)">
      <summary>
        <para>Compute GPU projection matrix from camera's projection matrix.</para>
        <para>In Unity, projection matrices follow OpenGL convention. However on some platforms they have to be transformed a bit to match the native API requirements. Use this function to calculate how the final projection matrix will be like. The value will match what comes as <c>UNITY_MATRIX_P</c> matrix in a shader.The <c>renderIntoTexture</c> value should be set to true if you intend to render into a <see cref="T:UnityEngine.RenderTexture" /> with this projection matrix. On some platforms it affects how the final matrix will look like.See Also: <see cref="P:UnityEngine.Camera.projectionMatrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.InvalidateState">
      <summary>
        <para>Invalidate the internally cached renderstates.</para>
        <para>This invalidates any cached renderstates tied to the GL context. If for example a (native) plugin alters the renderstate settings then Unity's rendering architecture must be made aware of that to not assume the GL context is preserved.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadIdentity">
      <summary>
        <para>Load the identity matrix to the current modelview matrix.</para>
        <para>This function overrides current camera's view parameters, so most often you want to save and restore matrix using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadOrtho">
      <summary>
        <para>Helper function to set up an ortho perspective transform.</para>
        <para>After calling LoadOrtho, the viewing frustum goes from (0,0,-1) to (1,1,100). LoadOrtho can be used for drawing primitives in 2D.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadPixelMatrix">
      <summary>
        <para>Setup a matrix for pixel-correct rendering.</para>
        <para>This sets up modelview and projection matrices so that X, Y coordinates map directly to pixels. The (0,0) is at the bottom left corner of current camera's viewport. The Z coordinate goes from -1 to +1.This function overrides current camera's parameters, so most often you want to save and restore matrices using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadPixelMatrix(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Setup a matrix for pixel-correct rendering.</para>
        <para>This sets up modelview and projection matrices so that X, Y coordinates map directly to pixels. The (left,bottom is at the bottom left corner of current camera's viewport; and (top,right) is at the top right corner of current camera's viewport. The Z coordinate goes from -1 to +1.This function overrides current camera's parameters, so most often you want to save and restore matrices using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Load an arbitrary matrix to the current projection matrix.</para>
        <para>This function overrides current camera's projection parameters, so most often you want to save and restore projection matrix using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord(System.Int32,UnityEngine.Vector3)">
      <summary>
        <para>Sets current texture coordinate (v.x,v.y,v.z) to the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated.The Z component is used only when:1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z).2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord2(System.Int32,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y) for the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord3(System.Int32,System.Single,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y,z) to the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated.The Z component is used only when:1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z).2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Multiplies the current modelview matrix with the one specified.</para>
        <para>Equivalent to <c>glMultMatrix(mat)</c> in OpenGL; in other graphics APIs the corresponding functionality is emulated.Changing modelview matrix overrides current camera's view parameters, so most often you want to save and restore matrix using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.PopMatrix">
      <summary>
        <para>Restores both projection and modelview matrices off the top of the matrix stack.</para>
        <para>Changing modelview or projection matrices overrides current camera's parameters. These matrices can be saved and restored using GL.PushMatrix and GL.PopMatrix.See Also: <see cref="M:UnityEngine.GL.PushMatrix" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.PushMatrix">
      <summary>
        <para>Saves both projection and modelview matrices to the matrix stack.</para>
        <para>Changing modelview or projection matrices overrides current camera's parameters. These matrices can be saved and restored using GL.PushMatrix and GL.PopMatrix.See Also: <see cref="M:UnityEngine.GL.PopMatrix" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.RenderTargetBarrier">
      <summary>
        <para>Resolves the render target for subsequent operations sampling from it.</para>
        <para>At the moment the advanced OpenGL blend operations are the only case requiring this barrier.See Also: <see cref="T:UnityEngine.Rendering.BlendOp" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.TexCoord(UnityEngine.Vector3)">
      <summary>
        <para>Sets current texture coordinate (v.x,v.y,v.z) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated.The Z component is used only when:1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z).2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.TexCoord2(System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.TexCoord3(System.Single,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y,z) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated.The Z component is used only when:1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z).2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Vertex(UnityEngine.Vector3)">
      <summary>
        <para>Submit a vertex.</para>
        <para>In OpenGL this matches <c>glVertex3f(v.x,v.y,v.z)</c>; on other graphics APIs the same functionality is emulated.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Vertex3(System.Single,System.Single,System.Single)">
      <summary>
        <para>Submit a vertex.</para>
        <para>In OpenGL this matches <c>glVertex3f(x,y,z)</c>; on other graphics APIs the same functionality is emulated.This function can only be called between GL.Begin and GL.End functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Viewport(UnityEngine.Rect)">
      <summary>
        <para>Set the rendering viewport.</para>
        <para>All rendering is constrained to be inside the passed <c>pixelRect</c>. If the Viewport is modified, all the rendered content inside of it gets stretched.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gradient.alphaKeys">
      <summary>
        <para>All alpha keys defined in the gradient.</para>
        <para>Note that the alpha keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 alpha keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gradient.colorKeys">
      <summary>
        <para>All color keys defined in the gradient.</para>
        <para>Note that the color keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gradient.#ctor">
      <summary>
        <para>Create a new Gradient object.</para>
        <para>The Gradient's keys can be manipulated using its <see cref="M:UnityEngine.Gradient.SetKeys(UnityEngine.GradientColorKey[],UnityEngine.GradientAlphaKey[])" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gradient.Evaluate(System.Single)">
      <summary>Calculate color at a given time.</summary>
      <param name="time">Time of the key (0 - 1).</param>
    </member>
    <member name="M:UnityEngine.Gradient.SetKeys(UnityEngine.GradientColorKey[],UnityEngine.GradientAlphaKey[])">
      <summary>
        <para>Setup Gradient with an array of color keys and alpha keys.</para>
        <para>Note that the alpha and colors keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys and 2 alpha keys.</para>
      </summary>
      <param name="colorKeys">Color keys of the gradient (maximum 8 color keys).</param>
      <param name="alphaKeys">Alpha keys of the gradient (maximum 8 alpha keys).</param>
    </member>
    <member name="F:UnityEngine.GradientAlphaKey.alpha">
      <summary>Alpha channel of key.</summary>
    </member>
    <member name="F:UnityEngine.GradientAlphaKey.time">
      <summary>Time of the key (0 - 1).</summary>
    </member>
    <member name="M:UnityEngine.GradientAlphaKey.#ctor(System.Single,System.Single)">
      <summary>Gradient alpha key.</summary>
      <param name="alpha">Alpha of key (0 - 1).</param>
      <param name="time">Time of the key (0 - 1).</param>
    </member>
    <member name="F:UnityEngine.GradientColorKey.color">
      <summary>Color of key.</summary>
    </member>
    <member name="F:UnityEngine.GradientColorKey.time">
      <summary>Time of the key (0 - 1).</summary>
    </member>
    <member name="M:UnityEngine.GradientColorKey.#ctor(UnityEngine.Color,System.Single)">
      <summary>Gradient color key.</summary>
      <param name="time">Time of the key (0 - 1).</param>
    </member>
    <member name="P:UnityEngine.Graphics.activeColorBuffer">
      <summary>Currently active color buffer (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Graphics.activeDepthBuffer">
      <summary>Currently active depth/stencil buffer (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing image effects.Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad.Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" /> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="M:UnityEngine.GL.LoadOrtho" />), setup material pass (<see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) and draw a quad (<see cref="M:UnityEngine.GL.Begin(System.Int32)" />).See Also: <see cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])" />, image effects.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">Destination <see cref="T:UnityEngine.RenderTexture" />, or <c>null</c> to blit directly to screen.</param>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing image effects.Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad.Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" /> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="M:UnityEngine.GL.LoadOrtho" />), setup material pass (<see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) and draw a quad (<see cref="M:UnityEngine.GL.Begin(System.Int32)" />).See Also: <see cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])" />, image effects.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">Destination <see cref="T:UnityEngine.RenderTexture" />, or <c>null</c> to blit directly to screen.</param>
      <param name="mat">Material to use. Material's shader could do some post-processing effect, for example.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing image effects.Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad.Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" /> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="M:UnityEngine.GL.LoadOrtho" />), setup material pass (<see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) and draw a quad (<see cref="M:UnityEngine.GL.Begin(System.Int32)" />).See Also: <see cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])" />, image effects.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="mat">Material to use. Material's shader could do some post-processing effect, for example.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      <summary>
        <para>Copies source texture into destination, for multi-tap shader.</para>
        <para>This is mostly used for implementing some image effects. For example, Gaussian or iterative Cone blurring samples source texture at multiple different locations.BlitMultiTap sets <c>dest</c> to be <see cref="P:UnityEngine.RenderTexture.active" /> render texture, sets <c>source</c> as <c>_MainTex</c> property on the material, and draws a full-screen quad. Each vertex of the quad has multiple texture coordinates set up, offset by <c>offsets</c> pixels.See Also: Graphics.Blit, image effects.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">Destination <see cref="T:UnityEngine.RenderTexture" />, or <c>null</c> to blit directly to screen.</param>
      <param name="mat">Material to use for copying. Material's shader should do some post-processing effect.</param>
      <param name="offsets">Variable number of filtering offsets. Offsets are given in pixels.</param>
    </member>
    <member name="M:UnityEngine.Graphics.ClearRandomWriteTargets">
      <summary>
        <para>Clear random write targets for Shader Model 5.0 level pixel shaders.</para>
        <para>This function clears any "random write" targets that were previously set with <see cref="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.RenderTexture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,UnityEngine.Transform)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="T:UnityEngine.MaterialPropertyBlock" />.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera.Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />.Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="T:UnityEngine.MaterialPropertyBlock" /> parameter.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="T:UnityEngine.Material" /> to use.</param>
      <param name="layer">Layer to use.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) will be used.The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> instead.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) will be used.The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> instead.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Matrix4x4)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) will be used.The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> instead.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations). Note that the mesh will not be displayed correctly if matrix has negative scale.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Matrix4x4,System.Int32)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" />) will be used.The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" /> instead.</para>
      </summary>
      <param name="mesh">The <see cref="T:UnityEngine.Mesh" /> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations). Note that the mesh will not be displayed correctly if matrix has negative scale.</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProcedural does a draw call on the GPU, without any vertex or index buffers. This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Note that this call executes immediately, similar to <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />. It uses currently set render target, transformation matrices and currently set shader pass.There's also a similar functionality in CommandBuffers, see <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />.See Also: <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsInstancing" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProcedural does a draw call on the GPU, without any vertex or index buffers. This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Note that this call executes immediately, similar to <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />. It uses currently set render target, transformation matrices and currently set shader pass.There's also a similar functionality in CommandBuffers, see <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)" />.See Also: <see cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsInstancing" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProceduralIndirect does a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="T:UnityEngine.ComputeBuffer" />. Typical use case is generating arbitrary amount of data from a <see cref="T:UnityEngine.ComputeShader" /> and then rendering that, without requiring a readback to the CPU.This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect / OpenGL ES 3.1 glDrawArraysIndirect function (on OpenGL ES 3.1 the last argument is reserved and therefore not used).Note that this call executes immediately, similar to <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />. It uses currently set render target, transformation matrices and currently set shader pass.There's also a similar functionality in CommandBuffers, see <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)" />.See Also: <see cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)" />, <see cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />.</para>
      </summary>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Offset where in the buffer the draw arguments are.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProceduralIndirect does a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="T:UnityEngine.ComputeBuffer" />. Typical use case is generating arbitrary amount of data from a <see cref="T:UnityEngine.ComputeShader" /> and then rendering that, without requiring a readback to the CPU.This is only useful on DirectX 11 level hardware where shaders can read arbitrary data from <see cref="T:UnityEngine.ComputeBuffer" /> buffers.Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect / OpenGL ES 3.1 glDrawArraysIndirect function (on OpenGL ES 3.1 the last argument is reserved and therefore not used).Note that this call executes immediately, similar to <see cref="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)" />. It uses currently set render target, transformation matrices and currently set shader pass.There's also a similar functionality in CommandBuffers, see <see cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)" />.See Also: <see cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)" />, <see cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)" />, <see cref="P:UnityEngine.SystemInfo.supportsComputeShaders" />.</para>
      </summary>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="mat">Custom <see cref="T:UnityEngine.Material" /> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="T:UnityEngine.Material" /> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="T:UnityEngine.Material" /> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="color">
        <see cref="T:UnityEngine.Color" /> that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.</param>
      <param name="mat">Custom <see cref="T:UnityEngine.Material" /> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="T:UnityEngine.Texture" /> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="color">
        <see cref="T:UnityEngine.Color" /> that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.</param>
    </member>
    <member name="M:UnityEngine.Graphics.ExecuteCommandBuffer(UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Execute a command buffer.</para>
        <para>All commands in the buffer will be executed immediately.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />.</para>
      </summary>
      <param name="buffer">The buffer to execute.</param>
    </member>
    <member name="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.RenderTexture)">
      <summary>
        <para>Set random write target for Shader Model 5.0 level pixel shaders.</para>
        <para>Shader Model 5.0 level pixel shaders can write into arbitrary locations of some textures and buffers, called "unordered access views" (UAV) in DirectX 11. These "random write" targets are set similarly to how multiple render targets are set. You can either use a <see cref="T:UnityEngine.RenderTexture" /> with <c>enableRandomWrite</c> flag set, or a <see cref="T:UnityEngine.ComputeBuffer" /> as target.The UAV indexing varies a bit between different platforms. On DX11 the first valid UAV index is the number of active render targets. So the common case of single render target the UAV indexing will start from 1. OpenGL ES 3.1 matches this behaviour when using translated HLSL shaders. However, with hand-written GLSL shaders the indexes will match the bindings.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="uav">RenderTexture/ComputeBuffer to set as write target.</param>
      <seealso cref="M:UnityEngine.Graphics.ClearRandomWriteTargets" />
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite" />
      <seealso cref="T:UnityEngine.ComputeBuffer" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Set random write target for Shader Model 5.0 level pixel shaders.</para>
        <para>Shader Model 5.0 level pixel shaders can write into arbitrary locations of some textures and buffers, called "unordered access views" (UAV) in DirectX 11. These "random write" targets are set similarly to how multiple render targets are set. You can either use a <see cref="T:UnityEngine.RenderTexture" /> with <c>enableRandomWrite</c> flag set, or a <see cref="T:UnityEngine.ComputeBuffer" /> as target.The UAV indexing varies a bit between different platforms. On DX11 the first valid UAV index is the number of active render targets. So the common case of single render target the UAV indexing will start from 1. OpenGL ES 3.1 matches this behaviour when using translated HLSL shaders. However, with hand-written GLSL shaders the indexes will match the bindings.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="uav">RenderTexture/ComputeBuffer to set as write target.</param>
      <seealso cref="M:UnityEngine.Graphics.ClearRandomWriteTargets" />
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite" />
      <seealso cref="T:UnityEngine.ComputeBuffer" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="T:UnityEngine.RenderTexture" /> or a <see cref="T:UnityEngine.RenderBuffer" /> combination will be rendered into next.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.active" />
      <seealso cref="T:UnityEngine.RenderTexture" />
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer" />
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer" />
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount" />
    </member>
    <member name="P:UnityEngine.GUI.backgroundColor">
      <summary>
        <para>Global tinting color for all background elements rendered by the GUI.</para>
        <para>This gets multiplied by <see cref="P:UnityEngine.GUI.color" />.See Also: <see cref="P:UnityEngine.GUI.contentColor" />, <see cref="P:UnityEngine.GUI.color" />.<c>Yellow Background color applied to a button.</c></para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.changed">
      <summary>Returns true if any controls changed the value of the input data.</summary>
    </member>
    <member name="P:UnityEngine.GUI.color">
      <summary>
        <para>Global tinting color for the GUI.</para>
        <para>This will affect both backgrounds &amp; text colors.See Also: <see cref="P:UnityEngine.GUI.backgroundColor" />, <see cref="P:UnityEngine.GUI.contentColor" />.<c>Yellow Color on the GUI Controls.</c></para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.contentColor">
      <summary>
        <para>Tinting color for all text rendered by the GUI.</para>
        <para>This gets multiplied by <see cref="P:UnityEngine.GUI.color" />.See Also: <see cref="P:UnityEngine.GUI.backgroundColor" />, <see cref="P:UnityEngine.GUI.color" />.<c>Yellow content color (font) in a button.</c></para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.depth">
      <summary>
        <para>The sorting depth of the currently executing GUI behaviour.</para>
        <para>Set this to determine ordering when you have different scripts running simultaneously. GUI elements drawn with lower depth values will appear on top of elements with higher values (ie, you can think of the depth as "distance" from the camera).Note:To see this example working, you will need to create 2 scripts. Remember to name the scripts with the same name as the class names, else it will not work.<c>One Button behind the other.</c></para>
        <para>And copy this other example to another script:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.enabled">
      <summary>
        <para>Is the GUI enabled?</para>
        <para>Set this value to false to disable all GUI interaction. All controls will be draw semi-transparently, and will not respond to user input.<c>Enabled / Disabled GUI controls.</c></para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.matrix">
      <summary>The GUI transform matrix.</summary>
    </member>
    <member name="P:UnityEngine.GUI.skin">
      <summary>
        <para>The global skin to use.</para>
        <para>You can set this at any point to change the look of your GUI. If you set it to null, the skin will revert to the default Unity skin.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUI.tooltip">
      <summary>
        <para>The tooltip of the control the mouse is currently over, or which has keyboard focus. (Read Only).</para>
        <para>When you create GUI controls, you can pass in a tooltip for them. This is done by changing the content parameter to take a custom-made <see cref="T:UnityEngine.GUIContent" /> object, rather than just passing in a string to display.When the mouse is over a control with a tooltip, it sets the global GUI.tooltip value to the tooltip you pass in. If the mouse is not hovering over any control, the value is set to the control which has keyboard focus. At the end of the OnGUI code, you can make a label showing the value of GUI.tooltip<c>GUI Tooltip on th Game view appears when the mouse is over the button.</c></para>
        <para>You can use the ordering of elements to create 'hierarchical' tooltips:</para>
        <para>Tooltips can also be used to implement an OnMouseOver / OnMouseOut messaging system:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,System.String)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="text">Text to display on the group.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the group.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="content">Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="style">The style to use for the background.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="text">Text to display on the group.</param>
      <param name="style">The style to use for the background.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the group.</param>
      <param name="style">The style to use for the background.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a group. Must be matched with a call to <see cref="M:UnityEngine.GUI.EndGroup" />.</para>
        <para>When you begin a group, the coordinate system for GUI controls are set so (0,0) is the top-left corner of the group. All controls are clipped to the group. Groups can be nested - if they are, children are clipped to their parents.This is very useful when moving a bunch of GUI elements around on screen. A common use case is designing your menus to fit on a specific screen size, then centering the GUI on larger displays.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="content">Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.</param>
      <param name="style">The style to use for the background.</param>
      <seealso cref="P:UnityEngine.GUI.matrix" />
      <seealso cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />
    </member>
    <member name="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)">
      <summary>
        <para>Begin a scrolling view inside your GUI.</para>
        <para>ScrollViews let you make a smaller area on-screen look 'into' a much larger area, using scrollbars placed on the sides of the ScrollView.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,System.Boolean,System.Boolean)">
      <summary>
        <para>Begin a scrolling view inside your GUI.</para>
        <para>ScrollViews let you make a smaller area on-screen look 'into' a much larger area, using scrollbars placed on the sides of the ScrollView.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when <c>viewRect</c> is wider than <c>position</c>.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when <c>viewRect</c> is taller than <c>position</c>.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a scrolling view inside your GUI.</para>
        <para>ScrollViews let you make a smaller area on-screen look 'into' a much larger area, using scrollbars placed on the sides of the ScrollView.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a scrolling view inside your GUI.</para>
        <para>ScrollViews let you make a smaller area on-screen look 'into' a much larger area, using scrollbars placed on the sides of the ScrollView.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when <c>viewRect</c> is wider than <c>position</c>.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when <c>viewRect</c> is taller than <c>position</c>.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="text">Text to display on the box.</param>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the box.</param>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="content">Text, image and tooltip for this box.</param>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="text">Text to display on the box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.Box(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Make a graphical box.</summary>
      <param name="position">Rectangle on the screen to use for the box.</param>
      <param name="content">Text, image and tooltip for this box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.BringWindowToBack(System.Int32)">
      <summary>Bring a specific window to back of the floating windows.</summary>
      <param name="windowID">The identifier used when you created the window in the <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" /> call.</param>
    </member>
    <member name="M:UnityEngine.GUI.BringWindowToFront(System.Int32)">
      <summary>Bring a specific window to front of the floating windows.</summary>
      <param name="windowID">The identifier used when you created the window in the <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" /> call.</param>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,System.String)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="text">Text to display on the button.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)">
      <summary>
        <para>Make a window draggable.</para>
        <para>Insert a call to this function inside your window code to make a window draggable.</para>
      </summary>
      <param name="position">The part of the window that can be dragged. This is clipped to the actual window.</param>
    </member>
    <member name="M:UnityEngine.GUI.DragWindow">
      <summary>
        <para>If you want to have the entire window background to act as a drag area, use the version of DragWindow that takes no parameters and put it at the end of the window function.</para>
        <para>This will mean that any other controls will get precedence and the dragging will only be activated if nothing else has mouse focus.</para>
      </summary>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTexture(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Draw a texture within a rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.ScaleMode)">
      <summary>Draw a texture within a rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <param name="scaleMode">How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.ScaleMode,System.Boolean)">
      <summary>Draw a texture within a rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <param name="scaleMode">How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.</param>
      <param name="alphaBlend">Whether to apply alpha blending when drawing the image (enabled by default).</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.ScaleMode,System.Boolean,System.Single)">
      <summary>Draw a texture within a rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <param name="scaleMode">How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.</param>
      <param name="alphaBlend">Whether to apply alpha blending when drawing the image (enabled by default).</param>
      <param name="imageAspect">Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used. Pass in w/h for the desired aspect ratio. This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTextureWithTexCoords(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect)">
      <summary>Draw a texture within a rectangle with the given texture coordinates. Use this function for clipping or tiling the image within the given rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <param name="texCoords">How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.DrawTextureWithTexCoords(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Boolean)">
      <summary>Draw a texture within a rectangle with the given texture coordinates. Use this function for clipping or tiling the image within the given rectangle.</summary>
      <param name="position">Rectangle on the screen to draw the texture within.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display.</param>
      <param name="texCoords">How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.</param>
      <param name="alphaBlend">Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.</param>
      <seealso cref="P:UnityEngine.GUI.color" />
      <seealso cref="P:UnityEngine.GUI.contentColor" />
    </member>
    <member name="M:UnityEngine.GUI.EndGroup">
      <summary>
        <para>End a group.</para>
        <para>Should be attached with GUI.BeginGroup See Also: <see cref="M:UnityEngine.GUI.BeginGroup(UnityEngine.Rect)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUI.EndScrollView">
      <summary>Ends a scrollview started with a call to BeginScrollView.</summary>
    </member>
    <member name="M:UnityEngine.GUI.EndScrollView(System.Boolean)">
      <summary>Ends a scrollview started with a call to BeginScrollView.</summary>
    </member>
    <member name="M:UnityEngine.GUI.FocusControl(System.String)">
      <summary>Move keyboard focus to a named control.</summary>
      <param name="name">Name set using <see cref="M:UnityEngine.GUI.SetNextControlName(System.String)" />.</param>
      <seealso cref="M:UnityEngine.GUI.SetNextControlName(System.String)" />
      <seealso cref="M:UnityEngine.GUI.GetNameOfFocusedControl" />
      <seealso cref="M:UnityEditor.EditorGUI.FocusTextInControl(System.String)" />
    </member>
    <member name="M:UnityEngine.GUI.FocusWindow(System.Int32)">
      <summary>Make a window become the active window.</summary>
      <param name="windowID">The identifier used when you created the window in the <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" /> call.</param>
    </member>
    <member name="M:UnityEngine.GUI.GetNameOfFocusedControl">
      <summary>
        <para>Get the name of named control that has focus.</para>
        <para>Control names are set up by using <see cref="M:UnityEngine.GUI.SetNextControlName(System.String)" />. When a named control has focus, this function will return its name. If no control has focus or the focused control has no name set, an empty string will be returned instead.</para>
      </summary>
      <seealso cref="M:UnityEngine.GUI.SetNextControlName(System.String)" />
      <seealso cref="M:UnityEngine.GUI.FocusControl(System.String)" />
    </member>
    <member name="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.</para>
        <para>Finding extra elements:The styles of the buttons at the end of the scrollbar are searched for in the current skin by adding "leftbutton" and "rightbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the scrollbar.</param>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="leftValue">The value at the left end of the scrollbar.</param>
      <param name="rightValue">The value at the right end of the scrollbar.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
    </member>
    <member name="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.</para>
        <para>Finding extra elements:The styles of the buttons at the end of the scrollbar are searched for in the current skin by adding "leftbutton" and "rightbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the scrollbar.</param>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="leftValue">The value at the left end of the scrollbar.</param>
      <param name="rightValue">The value at the right end of the scrollbar.</param>
      <param name="style">The style to use for the scrollbar background. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
    </member>
    <member name="M:UnityEngine.GUI.HorizontalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)">
      <summary>A horizontal slider the user can drag to change a value between a min and a max.</summary>
      <param name="position">Rectangle on the screen to use for the slider.</param>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="leftValue">The value at the left end of the slider.</param>
      <param name="rightValue">The value at the right end of the slider.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUI.HorizontalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>A horizontal slider the user can drag to change a value between a min and a max.</summary>
      <param name="position">Rectangle on the screen to use for the slider.</param>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="leftValue">The value at the left end of the slider.</param>
      <param name="rightValue">The value at the right end of the slider.</param>
      <param name="slider">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying the dragging area. If left out, the <c>horizontalSlider</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="thumb">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying draggable thumb. If left out, the <c>horizontalSliderThumb</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,System.String)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="text">Text to display on the label.</param>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the label.</param>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="content">Text, image and tooltip for this label.</param>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="text">Text to display on the label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.Label(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a text or texture label on screen.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> control.Example: Draw the classic Hello World! string:<c>Text label on the Game View.</c></para>
        <para>Example: Draw a texture on-screen. Labels are also used to display textures, instead of a string, simply pass in a texture:<c>Texture Label.</c></para>
      </summary>
      <param name="position">Rectangle on the screen to use for the label.</param>
      <param name="content">Text, image and tooltip for this label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="text">Text to appear in the title-bar area of the window, if any.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="image">An image to appear in the title bar of the window, if any.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="content">GUIContent to appear in the title bar of the window, if any.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String,UnityEngine.GUIStyle)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="text">Text to appear in the title-bar area of the window, if any.</param>
      <param name="style">Style to apply to the window.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="image">An image to appear in the title bar of the window, if any.</param>
      <param name="style">Style to apply to the window.</param>
    </member>
    <member name="M:UnityEngine.GUI.ModalWindow(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>
        <para>Show a Modal Window.</para>
        <para>Similar to <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />, however the window will always be on top of all other GUI, and while displayed, is guaranteed to be sole recipient of all GUI input and events. While a ModalWindow is being displayed, other controls will not be processing input. Note that only one ModalWindow can be displayed at a time.</para>
      </summary>
      <param name="id">A unique id number.</param>
      <param name="clientRect">Position and size of the window.</param>
      <param name="func">A function which contains the immediate mode GUI code to draw the contents of your window.</param>
      <param name="content">GUIContent to appear in the title bar of the window, if any.</param>
      <param name="style">Style to apply to the window.</param>
    </member>
    <member name="M:UnityEngine.GUI.PasswordField(UnityEngine.Rect,System.String,System.Char)">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUI.PasswordField(UnityEngine.Rect,System.String,System.Char,System.Int32)">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUI.PasswordField(UnityEngine.Rect,System.String,System.Char,UnityEngine.GUIStyle)">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUI.PasswordField(UnityEngine.Rect,System.String,System.Char,System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,System.String)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="text">Text to display on the button.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.RepeatButton(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Make a button that is active as long as the user holds it down.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>True when the users clicks the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.ScrollTo(UnityEngine.Rect)">
      <summary>Scrolls all enclosing scrollviews so they try to make <c>position</c> visible.</summary>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,System.String[],System.Int32)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="texts">An array of strings to show on the grid buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,UnityEngine.Texture[],System.Int32)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="images">An array of textures on the grid buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,UnityEngine.GUIContent[],System.Int32)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,System.String[],System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="texts">An array of strings to show on the grid buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,UnityEngine.Texture[],System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="images">An array of textures on the grid buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SelectionGrid(UnityEngine.Rect,System.Int32,UnityEngine.GUIContent[],System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a grid of buttons.</summary>
      <param name="position">Rectangle on the screen to use for the grid.</param>
      <param name="selected">The index of the selected grid button.</param>
      <param name="contents">An array of text, image and tooltips for the grid button.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.SetNextControlName(System.String)">
      <summary>
        <para>Set the name of the next control.</para>
        <para>This makes the following control be registered with a given name.See Also: <see cref="M:UnityEngine.GUI.GetNameOfFocusedControl" />, <see cref="M:UnityEngine.GUI.FocusControl(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUI.TextArea(UnityEngine.Rect,System.String)">
      <summary>Make a Multi-line text area where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextArea(UnityEngine.Rect,System.String,System.Int32)">
      <summary>Make a Multi-line text area where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextArea(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Make a Multi-line text area where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="style">The style to use. If left out, the <c>textArea</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextArea(UnityEngine.Rect,System.String,System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a Multi-line text area where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textArea</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextField(UnityEngine.Rect,System.String)">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextField(UnityEngine.Rect,System.String,System.Int32)">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextField(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.TextField(UnityEngine.Rect,System.String,System.Int32,UnityEngine.GUIStyle)">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="position">Rectangle on the screen to use for the text field.</param>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,System.String)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="text">Text to display on the button.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.Texture)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,System.String,UnityEngine.GUIStyle)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>toggle</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>toggle</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Make an on/off toggle button.</summary>
      <param name="position">Rectangle on the screen to use for the button.</param>
      <param name="value">Is this button on or off?</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>toggle</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The new value of the button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,System.String[])">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the toolbar buttons.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,UnityEngine.Texture[])">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the toolbar buttons.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,UnityEngine.GUIContent[])">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,System.String[],UnityEngine.GUIStyle)">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the toolbar buttons.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,UnityEngine.Texture[],UnityEngine.GUIStyle)">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the toolbar buttons.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Toolbar(UnityEngine.Rect,System.Int32,UnityEngine.GUIContent[],UnityEngine.GUIStyle)">
      <summary>Make a toolbar.</summary>
      <param name="position">Rectangle on the screen to use for the toolbar.</param>
      <param name="selected">The index of the selected button.</param>
      <param name="contents">An array of text, image and tooltips for the toolbar buttons.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The index of the selected button.</returns>
    </member>
    <member name="M:UnityEngine.GUI.UnfocusWindow">
      <summary>Remove focus from all windows.</summary>
    </member>
    <member name="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.</para>
        <para>Finding extra elements:The styles of the buttons at the end of the scrollbar are searched for in the current skin by adding "upbutton" and "downbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the scrollbar.</param>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="topValue">The value at the top of the scrollbar.</param>
      <param name="bottomValue">The value at the bottom of the scrollbar.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
    </member>
    <member name="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.</para>
        <para>Finding extra elements:The styles of the buttons at the end of the scrollbar are searched for in the current skin by adding "upbutton" and "downbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="position">Rectangle on the screen to use for the scrollbar.</param>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="topValue">The value at the top of the scrollbar.</param>
      <param name="bottomValue">The value at the bottom of the scrollbar.</param>
      <param name="style">The style to use for the scrollbar background. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
    </member>
    <member name="M:UnityEngine.GUI.VerticalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)">
      <summary>A vertical slider the user can drag to change a value between a min and a max.</summary>
      <param name="position">Rectangle on the screen to use for the slider.</param>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="topValue">The value at the top end of the slider.</param>
      <param name="bottomValue">The value at the bottom end of the slider.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUI.VerticalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>A vertical slider the user can drag to change a value between a min and a max.</summary>
      <param name="position">Rectangle on the screen to use for the slider.</param>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="topValue">The value at the top end of the slider.</param>
      <param name="bottomValue">The value at the bottom end of the slider.</param>
      <param name="slider">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying the dragging area. If left out, the <c>horizontalSlider</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="thumb">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying draggable thumb. If left out, the <c>horizontalSliderThumb</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="text">Text to render inside the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="image">Image to render inside the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="content">GUIContent to render inside the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="text">Text to render inside the window.</param>
      <param name="style">Style information for the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="image">Image to render inside the window.</param>
      <param name="style">Style information for the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>
        <para>Make a popup window.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function that renders the GUI controls inside the window. Note: If you are using <see cref="T:UnityEngine.GUILayout" /> to place your components inside the window, you should use GUILayout.Window. Also, if <see cref="P:UnityEngine.MonoBehaviour.useGUILayout" /> is set to false then a call to GUI.Window will not have any effect, even though it is not a GUILayout function.</para>
        <para>You can use the same function to create multiple windows. Just make sure that <c>each window has its own ID</c>. Example:</para>
        <para>To stop showing a window, simply stop calling GUI.Window from inside your main OnGUI function:</para>
        <para>To make a window that gets its size from automatic GUI layouting, use GUILayout.Window. Call Ordering 	Windows need to be drawn back-to-front; windows on top of other windows need to be drawn later than the ones below them. This means that you can not count on your DoWindow functions to 	be called in any particular order. In order for this to work seamlessly, the following values are stored when you create your window (using the Window function), and retrieved when your DoWindow gets called: 		GUI.skin, GUI.enabled, GUI.color, GUI.backgroundColor, GUI.contentColor, GUI.matrix.</para>
        <para>Note that you can use the alpha component of GUI.color to fade windows in and out.</para>
      </summary>
      <param name="id">ID number for the window (can be any value as long as it is unique).</param>
      <param name="clientRect">Onscreen rectangle denoting the window's position and size.</param>
      <param name="func">Script function to display the window's contents.</param>
      <param name="title">Text displayed in the window's title bar.</param>
      <param name="style">Style information for the window.</param>
      <returns>Onscreen rectangle denoting the window's position and size.</returns>
      <seealso cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToFront(System.Int32)" />
      <seealso cref="M:UnityEngine.GUI.BringWindowToBack(System.Int32)" />
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,System.String)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="text">Text to display on the group.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the group.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="content">Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,UnityEngine.GUIStyle)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="style">The style to use for the background.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="text">Text to display on the group.</param>
      <param name="style">The style to use for the background.</param>
    </member>
    <member name="M:UnityEngine.GUI.GroupScope.#ctor(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Create a new GroupScope and begin the corresponding group.</summary>
      <param name="position">Rectangle on the screen to use for the group.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the group.</param>
      <param name="style">The style to use for the background.</param>
    </member>
    <member name="P:UnityEngine.GUI.ScrollViewScope.handleScrollWheel">
      <summary>Whether this ScrollView should handle scroll wheel events. (default: true).</summary>
    </member>
    <member name="P:UnityEngine.GUI.ScrollViewScope.scrollPosition">
      <summary>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</summary>
    </member>
    <member name="M:UnityEngine.GUI.ScrollViewScope.#ctor(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
    </member>
    <member name="M:UnityEngine.GUI.ScrollViewScope.#ctor(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,System.Boolean,System.Boolean)">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when <c>clientRect</c> is wider than <c>position</c>.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when <c>clientRect</c> is taller than <c>position</c>.</param>
    </member>
    <member name="M:UnityEngine.GUI.ScrollViewScope.#ctor(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUI.ScrollViewScope.#ctor(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle)">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="position">Rectangle on the screen to use for the ScrollView.</param>
      <param name="scrollPosition">The pixel distance that the view is scrolled in the X and Y directions.</param>
      <param name="viewRect">The rectangle used inside the scrollview.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when <c>clientRect</c> is wider than <c>position</c>.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when <c>clientRect</c> is taller than <c>position</c>.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="F:UnityEngine.GUIContent.none">
      <summary>Shorthand for empty content.</summary>
    </member>
    <member name="P:UnityEngine.GUIContent.image">
      <summary>The icon image contained.</summary>
    </member>
    <member name="P:UnityEngine.GUIContent.text">
      <summary>The text contained.</summary>
    </member>
    <member name="P:UnityEngine.GUIContent.tooltip">
      <summary>
        <para>The tooltip of this element.</para>
        <para>The tooltip associated with this content. Read GUItooltip to get the tooltip of the gui element the user is currently over.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor">
      <summary>
        <para>Constructor for GUIContent in all shapes and sizes.</para>
        <para>Build an empty GUIContent.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(System.String)">
      <summary>
        <para>Build a GUIContent object containing only text.</para>
        <para>When using the GUI, you don't need to create GUIContents for simple text strings - these two lines of code are functionally equivalent:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(UnityEngine.Texture)">
      <summary>Build a GUIContent object containing only an image.</summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(System.String,UnityEngine.Texture)">
      <summary>Build a GUIContent object containing both <c>text</c> and an image.</summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(System.String,System.String)">
      <summary>Build a GUIContent containing some <c>text</c>. When the user hovers the mouse over it, the global <see cref="P:UnityEngine.GUI.tooltip" /> is set to the <c>tooltip</c>.</summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(UnityEngine.Texture,System.String)">
      <summary>Build a GUIContent containing an image. When the user hovers the mouse over it, the global <see cref="P:UnityEngine.GUI.tooltip" /> is set to the <c>tooltip</c>.</summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(System.String,UnityEngine.Texture,System.String)">
      <summary>Build a GUIContent that contains both <c>text</c>, an <c>image</c> and has a <c>tooltip</c> defined. When the user hovers the mouse over it, the global <see cref="P:UnityEngine.GUI.tooltip" /> is set to the <c>tooltip</c>.</summary>
    </member>
    <member name="M:UnityEngine.GUIContent.#ctor(UnityEngine.GUIContent)">
      <summary>Build a GUIContent as a copy of another GUIContent.</summary>
    </member>
    <member name="M:UnityEngine.GUIElement.GetScreenRect(UnityEngine.Camera)">
      <summary>
        <para>Returns bounding rectangle of <see cref="T:UnityEngine.GUIElement" /> in screen coordinates.</para>
        <para>If no <c>camera</c> is given a camera filling the entire game window will be assumed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.GetScreenRect">
      <summary>
        <para>Returns bounding rectangle of <see cref="T:UnityEngine.GUIElement" /> in screen coordinates.</para>
        <para>If no <c>camera</c> is given a camera filling the entire game window will be assumed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.HitTest(UnityEngine.Vector3,UnityEngine.Camera)">
      <summary>
        <para>Is a point on screen inside the element?</para>
        <para>Returns true if the <c>screenPosition</c> is contained in this GUIElement. <c>screenPosition</c> is specified in screen coordinates, like the values returned by the <see cref="P:UnityEngine.Input.mousePosition" /> property. If no <c>camera</c> is given a camera filling the entire game window will be assumed.Note that if the position is inside the element, <c>true</c> will be returned even if the game object belongs to Ignore Raycast layer (normally mouse events are not sent to Ignore Raycast objects).See Also: <see cref="M:UnityEngine.GUILayer.HitTest(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.HitTest(UnityEngine.Vector3)">
      <summary>
        <para>Is a point on screen inside the element?</para>
        <para>Returns true if the <c>screenPosition</c> is contained in this GUIElement. <c>screenPosition</c> is specified in screen coordinates, like the values returned by the <see cref="P:UnityEngine.Input.mousePosition" /> property. If no <c>camera</c> is given a camera filling the entire game window will be assumed.Note that if the position is inside the element, <c>true</c> will be returned even if the game object belongs to Ignore Raycast layer (normally mouse events are not sent to Ignore Raycast objects).See Also: <see cref="M:UnityEngine.GUILayer.HitTest(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayer.HitTest(UnityEngine.Vector3)">
      <summary>
        <para>Get the GUI element at a specific screen position.</para>
        <para>Returns the <see cref="T:UnityEngine.GUIElement" /> at a specific point on screen. If <c>screenPosition</c> is inside some <see cref="T:UnityEngine.GUIElement" />, that element is returned. Returns <c>null</c> if the position is not inside any GUI element. GUI elements that belong to Ignore Raycast layer will be ignored, as if they would not exist.<c>screenPosition</c> is measured in screen coordinates, like the values returned by Input.mousePosition property.Note: GUILayer.HitTest only finds old-school GUI components (made up of the classes GUIElement, GUITexture, GUIText, GUILayer), and will not work with the "new" one (referred to as "UnityGUI" and made up of all the other GUIAnything classes, and the OnGUI() call). So if you're using UnityGUI, HitTest won't find anything.See Also: <see cref="M:UnityEngine.GUIElement.HitTest(UnityEngine.Vector3,UnityEngine.Camera)" />, <see cref="P:UnityEngine.Input.mousePosition" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,System.String)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="text">Optional text to display in the area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="image">Optional texture to display in the area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="content">Optional text, image and tooltip top display for this area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="text">Optional text to display in the area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="image">Optional texture to display in the area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin a GUILayout block of GUI controls in a fixed screen area.</para>
        <para>By default, any GUI controls made using GUILayout are placed in the top-left corner of the screen. If you want to place a series of automatically laid out controls in an arbitrary area, use GUILayout.BeginArea to define a new area for the automatic layouting system to use.See Also: <see cref="M:UnityEngine.GUILayout.EndArea" /><c>Explained Area of the example.</c></para>
        <para>This function is very useful when mixing GUILayout code. It must be matched with a call to EndArea. BeginArea / EndArea cannot be nested.</para>
      </summary>
      <param name="content">Optional text, image and tooltip top display for this area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a Horizontal control group.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a Horizontal control group.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginHorizontal(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a Horizontal control group.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
      <param name="text">Text to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a Horizontal control group.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a Horizontal control group.</para>
        <para>All controls rendered inside this element will be placed horizontally next to each other. The group must be closed with a call to EndHorizontal.<c>Horizontal Layout.</c></para>
      </summary>
      <param name="content">Text, image, and tooltip for this group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUIStyle)">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin an automatically laid out scrollview.</para>
        <para>Automatically laid out scrollviews will take whatever content you have inside them and display normally. If it doesn't fit, scrollbars will appear. A call to BeginScrollView must always be matched with a call to EndScrollView.<c>Scroll View in the Game View..</c></para>
      </summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a vertical control group.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a vertical control group.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginVertical(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a vertical control group.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
      <param name="text">Text to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a vertical control group.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Begin a vertical control group.</para>
        <para>All controls rendered inside this element will be placed vertically below each other. The group must be closed with a call to EndVertical.<c>Vertical Layout.</c></para>
      </summary>
      <param name="content">Text, image, and tooltip for this group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the box.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(System.String,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="text">Text to display on the box.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="content">Text, image and tooltip for this box.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="text">Text to display on the box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Box(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout box.</para>
        <para>This will make a box that contains static text or images but not other GUI controls. If you want to make a rectangular container for a set of GUI controls, use one of the grouping functions (<see cref="M:UnityEngine.GUILayout.BeginHorizontal(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginVertical(UnityEngine.GUILayoutOption[])" />, <see cref="M:UnityEngine.GUILayout.BeginArea(UnityEngine.Rect)" />, etc...).<c>Boxes in the Game View.</c></para>
      </summary>
      <param name="content">Text, image and tooltip for this box.</param>
      <param name="style">The style to use. If left out, the <c>box</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(System.String,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="text">Text to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Button(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a single press button. The user clicks them and something happens immediately.</summary>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the users clicks the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.EndArea">
      <summary>Close a GUILayout block started with BeginArea.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.EndHorizontal">
      <summary>Close a group started with BeginHorizontal.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.EndScrollView">
      <summary>End a scroll view begun with a call to BeginScrollView.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.EndVertical">
      <summary>Close a group started with BeginVertical.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)">
      <summary>Option passed to a control to allow or disallow vertical expansion.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)">
      <summary>Option passed to a control to allow or disallow horizontal expansion.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.FlexibleSpace">
      <summary>
        <para>Insert a flexible space element.</para>
        <para>Flexible spaces use up any leftover space in a layout. Note: This will override the GUILayout.ExpandWidth and GUILayout.ExpandHeight<c>Flexible Space in a GUILayout Area.</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.Height(System.Single)">
      <summary>
        <para>Option passed to a control to give it an absolute height.</para>
        <para>Note: This option will override the Automatic height Layout parameter<c>Fixed Height for a GUI Control.</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a horiztonal scrollbar.</para>
        <para>A scrollbar control returns a float value that represents the position of the draggable "thumb" withtin the bar. You can use the value to adjust another GUI element to reflect the scroll position. However, most scrollable views can be handled more easily using a <c>scroll view</c> control.<c>Horizontal Scrollbar in the Game View.</c></para>
        <para>The styles of the scroll buttons at the end of the bar can be located in the current skin by adding "leftbutton" and "rightbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="leftValue">The value at the left end of the scrollbar.</param>
      <param name="rightValue">The value at the right end of the scrollbar.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
      <seealso cref="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])" />
      <seealso cref="M:UnityEngine.GUILayout.VerticalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a horiztonal scrollbar.</para>
        <para>A scrollbar control returns a float value that represents the position of the draggable "thumb" withtin the bar. You can use the value to adjust another GUI element to reflect the scroll position. However, most scrollable views can be handled more easily using a <c>scroll view</c> control.<c>Horizontal Scrollbar in the Game View.</c></para>
        <para>The styles of the scroll buttons at the end of the bar can be located in the current skin by adding "leftbutton" and "rightbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="leftValue">The value at the left end of the scrollbar.</param>
      <param name="rightValue">The value at the right end of the scrollbar.</param>
      <param name="style">The style to use for the scrollbar background. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
      <seealso cref="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])" />
      <seealso cref="M:UnityEngine.GUILayout.VerticalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalSlider(System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>A horizontal slider the user can drag to change a value between a min and a max.</summary>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="leftValue">The value at the left end of the slider.</param>
      <param name="rightValue">The value at the right end of the slider.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalSlider(System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>A horizontal slider the user can drag to change a value between a min and a max.</summary>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="leftValue">The value at the left end of the slider.</param>
      <param name="rightValue">The value at the right end of the slider.</param>
      <param name="slider">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying the dragging area. If left out, the <c>horizontalSlider</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="thumb">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying draggable thumb. If left out, the <c>horizontalSliderThumb</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.Label(UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the label.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Label(System.String,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="text">Text to display on the label.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Label(UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="content">Text, image and tooltip for this label.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Label(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Label(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="text">Text to display on the label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Label(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make an auto-layout label.</para>
        <para>Labels have no user interaction, do not catch mouse clicks and are always rendered in normal style. If you want to make a control that responds visually to user input, use a <see cref="M:UnityEngine.GUILayout.Box(UnityEngine.Texture,UnityEngine.GUILayoutOption[])" /> control<c>Label in the Game View.</c></para>
      </summary>
      <param name="content">Text, image and tooltip for this label.</param>
      <param name="style">The style to use. If left out, the <c>label</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.MaxHeight(System.Single)">
      <summary>Option passed to a control to specify a maximum height.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.MaxWidth(System.Single)">
      <summary>Option passed to a control to specify a maximum width.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.MinHeight(System.Single)">
      <summary>Option passed to a control to specify a minimum height.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.MinWidth(System.Single)">
      <summary>
        <para>Option passed to a control to specify a minimum width.</para>
        <para>Note: This option will override the Automatic width Layout parameter<c>Minimum allowed width for a Window.</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.PasswordField(System.String,System.Char,UnityEngine.GUILayoutOption[])">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.PasswordField(System.String,System.Char,System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.PasswordField(System.String,System.Char,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.PasswordField(System.String,System.Char,System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a text field where the user can enter a password.</summary>
      <param name="password">Password to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maskChar">Character to mask the password with.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <returns>The edited password.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(System.String,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="text">Text to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.RepeatButton(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a repeating button. The button returns true as long as the user holds down the mouse.</summary>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>
        <c>true</c> when the holds down the mouse.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,System.String[],System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,UnityEngine.Texture[],System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,UnityEngine.GUIContent[],System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,System.String[],System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,UnityEngine.Texture[],System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the buttons.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.SelectionGrid(System.Int32,UnityEngine.GUIContent[],System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a Selection Grid.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="contents">An array of text, image and tooltips for the button.</param>
      <param name="xCount">How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Space(System.Single)">
      <summary>
        <para>Insert a space in the current layout group.</para>
        <para>The direction of the space is dependent on the layout group you're currently in when issuing the command. If in a vertical group, the space will be vertical: Note: This will override the GUILayout.ExpandWidth and GUILayout.ExpandHeight<c>Space of 20px between two buttons.</c></para>
        <para>In horizontal groups, the <c>pixels</c> are measured horizontally:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUILayout.TextArea(System.String,UnityEngine.GUILayoutOption[])">
      <summary>Make a multi-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.&amp;amp;lt;br&amp;amp;gt; See Also: <see cref="M:UnityEngine.GUILayout.Width(System.Single)" />, <see cref="M:UnityEngine.GUILayout.Height(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />, <see cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.TextArea(System.String,System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a multi-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.&amp;amp;lt;br&amp;amp;gt; See Also: <see cref="M:UnityEngine.GUILayout.Width(System.Single)" />, <see cref="M:UnityEngine.GUILayout.Height(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />, <see cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.TextArea(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a multi-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.&amp;amp;lt;br&amp;amp;gt; See Also: <see cref="M:UnityEngine.GUILayout.Width(System.Single)" />, <see cref="M:UnityEngine.GUILayout.Height(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />, <see cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.TextArea(System.String,System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a multi-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textField</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.&amp;amp;lt;br&amp;amp;gt; See Also: <see cref="M:UnityEngine.GUILayout.Width(System.Single)" />, <see cref="M:UnityEngine.GUILayout.Height(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />, <see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />, <see cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />.</param>
      <returns>The edited string.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.TextField(System.String,UnityEngine.GUILayoutOption[])">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The edited string.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.TextField(System.String,System.Int32,UnityEngine.GUILayoutOption[])">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The edited string.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.TextField(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="style">The style to use. If left out, the <c>textArea</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The edited string.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.TextField(System.String,System.Int32,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a single-line text field where the user can edit a string.</summary>
      <param name="text">Text to edit. The return value of this function should be assigned back to the string as shown in the example.</param>
      <param name="maxLength">The maximum length of the string. If left out, the user can type for ever and ever.</param>
      <param name="style">The style to use. If left out, the <c>textArea</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The edited string.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,System.String,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="text">Text to display on the button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="text">Text to display on the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toggle(System.Boolean,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make an on/off toggle button.</summary>
      <param name="value">Is the button on or off?</param>
      <param name="content">Text, image and tooltip for this button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The new value of the button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,System.String[],UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the buttons.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,UnityEngine.Texture[],UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the buttons.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,UnityEngine.GUIContent[],UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,System.String[],UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="texts">An array of strings to show on the buttons.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,UnityEngine.Texture[],UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="images">An array of textures on the buttons.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Toolbar(System.Int32,UnityEngine.GUIContent[],UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Make a toolbar.</summary>
      <param name="selected">The index of the selected button.</param>
      <param name="contents">An array of text, image and tooltips for the button.</param>
      <param name="style">The style to use. If left out, the <c>button</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The index of the selected button.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a vertical scrollbar.</para>
        <para>A scrollbar control returns a float value that represents the position of the draggable "thumb" withtin the bar. You can use the value to adjust another GUI element to reflect the scroll position. However, most scrollable views can be handled more easily using a <c>scroll view</c> control.<c>Vertical Scrollbar in the Game View.</c></para>
        <para>The styles of the scroll buttons at the end of the bar can be located in the current skin by adding "upbutton" and "downbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="topValue">The value at the top end of the scrollbar.</param>
      <param name="bottomValue">The value at the bottom end of the scrollbar.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
      <seealso cref="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])" />
      <seealso cref="M:UnityEngine.GUILayout.HorizontalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a vertical scrollbar.</para>
        <para>A scrollbar control returns a float value that represents the position of the draggable "thumb" withtin the bar. You can use the value to adjust another GUI element to reflect the scroll position. However, most scrollable views can be handled more easily using a <c>scroll view</c> control.<c>Vertical Scrollbar in the Game View.</c></para>
        <para>The styles of the scroll buttons at the end of the bar can be located in the current skin by adding "upbutton" and "downbutton" to the style name. The name of the scrollbar thumb (the thing you drag) is found by appending "thumb" to the style name.</para>
      </summary>
      <param name="value">The position between min and max.</param>
      <param name="size">How much can we see?</param>
      <param name="topValue">The value at the top end of the scrollbar.</param>
      <param name="bottomValue">The value at the bottom end of the scrollbar.</param>
      <param name="style">The style to use for the scrollbar background. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end.</returns>
      <seealso cref="M:UnityEngine.GUILayout.BeginScrollView(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])" />
      <seealso cref="M:UnityEngine.GUILayout.HorizontalScrollbar(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalSlider(System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>A vertical slider the user can drag to change a value between a min and a max.</summary>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalSlider(System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>A vertical slider the user can drag to change a value between a min and a max.</summary>
      <param name="value">The value the slider shows. This determines the position of the draggable thumb.</param>
      <param name="slider">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying the dragging area. If left out, the <c>horizontalSlider</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="thumb">The <see cref="T:UnityEngine.GUIStyle" /> to use for displaying draggable thumb. If left out, the <c>horizontalSliderThumb</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The value that has been set by the user.</returns>
    </member>
    <member name="M:UnityEngine.GUILayout.Width(System.Single)">
      <summary>Option passed to a control to give it an absolute width.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="text">Text to display as a title for the window.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display an image in the titlebar.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="content">Text, image and tooltip for this window.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="text">Text to display as a title for the window.</param>
      <param name="style">An optional style to use for the window. If left out, the <c>window</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display an image in the titlebar.</param>
      <param name="style">An optional style to use for the window. If left out, the <c>window</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Make a popup window that layouts its contents automatically.</para>
        <para>Windows float above normal GUI controls, feature click-to-focus and can optionally be dragged around by the end user. Unlike other controls, you need to pass them a separate function for the GUI controls to put inside the window. Here is a small example to get you started:<c>Window in the Game View.</c></para>
        <para>The screen rectangle you pass in to the function only acts as a guide. To Apply extra limits to the window, pass in some extra layout options. The ones applied here will override the size calculated. Here is a small example:</para>
      </summary>
      <param name="id">A unique ID to use for each window. This is the ID you'll use to interface to it.</param>
      <param name="screenRect">Rectangle on the screen to use for the window. The layouting system will attempt to fit the window inside it - if that cannot be done, it will adjust the rectangle to fit.</param>
      <param name="func">The function that creates the GUI <c>inside</c> the window. This function must take one parameter - the <c>id</c> of the window it's currently making GUI for.</param>
      <param name="content">Text, image and tooltip for this window.</param>
      <param name="style">An optional style to use for the window. If left out, the <c>window</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c> or the <c>screenRect</c> you pass in.</param>
      <returns>The rectangle the window is at. This can be in a different position and have a different size than the one you passed in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,System.String)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="text">Optional text to display in the area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="image">Optional texture to display in the area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,UnityEngine.GUIContent)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="content">Optional text, image and tooltip top display for this area.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,System.String,UnityEngine.GUIStyle)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="text">Optional text to display in the area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.GUIStyle)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="image">Optional texture to display in the area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.AreaScope.#ctor(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Create a new AreaScope and begin the corresponding Area.</summary>
      <param name="content">Optional text, image and tooltip top display for this area.</param>
      <param name="style">The style to use. If left out, the empty <see cref="T:UnityEngine.GUIStyle" /> (<see cref="P:UnityEngine.GUIStyle.none" />) is used, giving a transparent background.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScope.#ctor(UnityEngine.GUILayoutOption[])">
      <summary>Create a new HorizontalScope and begin the corresponding horizontal group.</summary>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScope.#ctor(UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new HorizontalScope and begin the corresponding horizontal group.</summary>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScope.#ctor(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new HorizontalScope and begin the corresponding horizontal group.</summary>
      <param name="text">Text to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScope.#ctor(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new HorizontalScope and begin the corresponding horizontal group.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.HorizontalScope.#ctor(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new HorizontalScope and begin the corresponding horizontal group.</summary>
      <param name="content">Text, image, and tooltip for this group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="P:UnityEngine.GUILayout.ScrollViewScope.handleScrollWheel">
      <summary>Whether this ScrollView should handle scroll wheel events. (default: true).</summary>
    </member>
    <member name="P:UnityEngine.GUILayout.ScrollViewScope.scrollPosition">
      <summary>The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example.</summary>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.ScrollViewScope.#ctor(UnityEngine.Vector2,System.Boolean,System.Boolean,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new ScrollViewScope and begin the corresponding ScrollView.</summary>
      <param name="scrollPosition">The position to use display.</param>
      <param name="alwaysShowHorizontal">Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.</param>
      <param name="alwaysShowVertical">Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.</param>
      <param name="horizontalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the horizontal scrollbar. If left out, the <c>horizontalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
      <param name="verticalScrollbar">Optional <see cref="T:UnityEngine.GUIStyle" /> to use for the vertical scrollbar. If left out, the <c>verticalScrollbar</c> style from the current <see cref="T:UnityEngine.GUISkin" /> is used.</param>
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScope.#ctor(UnityEngine.GUILayoutOption[])">
      <summary>Create a new VerticalScope and begin the corresponding vertical group.</summary>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScope.#ctor(UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new VerticalScope and begin the corresponding vertical group.</summary>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScope.#ctor(System.String,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new VerticalScope and begin the corresponding vertical group.</summary>
      <param name="text">Text to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScope.#ctor(UnityEngine.Texture,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new VerticalScope and begin the corresponding vertical group.</summary>
      <param name="image">
        <see cref="T:UnityEngine.Texture" /> to display on group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayout.VerticalScope.#ctor(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Create a new VerticalScope and begin the corresponding vertical group.</summary>
      <param name="content">Text, image, and tooltip for this group.</param>
      <param name="style">The style to use for background image and padding values. If left out, the background is transparent.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetAspectRect(System.Single)">
      <summary>Reserve layout space for a rectangle with a specific aspect ratio.</summary>
      <param name="aspect">The aspect ratio of the element (width / height).</param>
      <returns>The rect for the control.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetAspectRect(System.Single,UnityEngine.GUIStyle)">
      <summary>Reserve layout space for a rectangle with a specific aspect ratio.</summary>
      <param name="aspect">The aspect ratio of the element (width / height).</param>
      <param name="style">An optional style. If specified, the style's <c>padding</c> value will be added to the sizes of the returned rectangle &amp; the style's <c>margin</c> values will be used for spacing.</param>
      <returns>The rect for the control.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetAspectRect(System.Single,UnityEngine.GUILayoutOption[])">
      <summary>Reserve layout space for a rectangle with a specific aspect ratio.</summary>
      <param name="aspect">The aspect ratio of the element (width / height).</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The rect for the control.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetAspectRect(System.Single,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Reserve layout space for a rectangle with a specific aspect ratio.</summary>
      <param name="aspect">The aspect ratio of the element (width / height).</param>
      <param name="style">An optional style. If specified, the style's <c>padding</c> value will be added to the sizes of the returned rectangle &amp; the style's <c>margin</c> values will be used for spacing.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The rect for the control.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetLastRect">
      <summary>
        <para>Get the rectangle last used by GUILayout for a control.</para>
        <para>Note that this only works during the Repaint event.</para>
      </summary>
      <returns>The last used rectangle.</returns>
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(UnityEngine.GUIContent,UnityEngine.GUIStyle)">
      <summary>Reserve layout space for a rectangle for displaying some contents with a specific style.</summary>
      <param name="content">The content to make room for displaying.</param>
      <param name="style">The <see cref="T:UnityEngine.GUIStyle" /> to layout for.</param>
      <returns>A rectangle that is large enough to contain content when rendered in style.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Reserve layout space for a rectangle for displaying some contents with a specific style.</summary>
      <param name="content">The content to make room for displaying.</param>
      <param name="style">The <see cref="T:UnityEngine.GUIStyle" /> to layout for.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>A rectangle that is large enough to contain content when rendered in style.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single)">
      <summary>Reserve layout space for a rectangle with a fixed content area.</summary>
      <param name="width">The width of the area you want.</param>
      <param name="height">The height of the area you want.</param>
      <returns>The rectanlge to put your control in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,UnityEngine.GUIStyle)">
      <summary>Reserve layout space for a rectangle with a fixed content area.</summary>
      <param name="width">The width of the area you want.</param>
      <param name="height">The height of the area you want.</param>
      <param name="style">An optional <see cref="T:UnityEngine.GUIStyle" /> to layout for. If specified, the style's <c>padding</c> value will be added to your sizes &amp; its <c>margin</c> value will be used for spacing.</param>
      <returns>The rectanlge to put your control in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>Reserve layout space for a rectangle with a fixed content area.</summary>
      <param name="width">The width of the area you want.</param>
      <param name="height">The height of the area you want.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The rectanlge to put your control in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>Reserve layout space for a rectangle with a fixed content area.</summary>
      <param name="width">The width of the area you want.</param>
      <param name="height">The height of the area you want.</param>
      <param name="style">An optional <see cref="T:UnityEngine.GUIStyle" /> to layout for. If specified, the style's <c>padding</c> value will be added to your sizes &amp; its <c>margin</c> value will be used for spacing.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>The rectanlge to put your control in.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Reserve layout space for a flexible rect.</para>
        <para>The rectangle's size will be between the min &amp; max values.</para>
      </summary>
      <param name="minWidth">The minimum width of the area passed back.</param>
      <param name="maxWidth">The maximum width of the area passed back.</param>
      <param name="minHeight">The minimum width of the area passed back.</param>
      <param name="maxHeight">The maximum width of the area passed back.</param>
      <returns>A rectangle with size between minWidth &amp; maxWidth on both axes.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle)">
      <summary>
        <para>Reserve layout space for a flexible rect.</para>
        <para>The rectangle's size will be between the min &amp; max values.</para>
      </summary>
      <param name="minWidth">The minimum width of the area passed back.</param>
      <param name="maxWidth">The maximum width of the area passed back.</param>
      <param name="minHeight">The minimum width of the area passed back.</param>
      <param name="maxHeight">The maximum width of the area passed back.</param>
      <param name="style">An optional style. If specified, the style's <c>padding</c> value will be added to the sizes requested &amp; the style's <c>margin</c> values will be used for spacing.</param>
      <returns>A rectangle with size between minWidth &amp; maxWidth on both axes.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Reserve layout space for a flexible rect.</para>
        <para>The rectangle's size will be between the min &amp; max values.</para>
      </summary>
      <param name="minWidth">The minimum width of the area passed back.</param>
      <param name="maxWidth">The maximum width of the area passed back.</param>
      <param name="minHeight">The minimum width of the area passed back.</param>
      <param name="maxHeight">The maximum width of the area passed back.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>A rectangle with size between minWidth &amp; maxWidth on both axes.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single,System.Single,System.Single,UnityEngine.GUIStyle,UnityEngine.GUILayoutOption[])">
      <summary>
        <para>Reserve layout space for a flexible rect.</para>
        <para>The rectangle's size will be between the min &amp; max values.</para>
      </summary>
      <param name="minWidth">The minimum width of the area passed back.</param>
      <param name="maxWidth">The maximum width of the area passed back.</param>
      <param name="minHeight">The minimum width of the area passed back.</param>
      <param name="maxHeight">The maximum width of the area passed back.</param>
      <param name="style">An optional style. If specified, the style's <c>padding</c> value will be added to the sizes requested &amp; the style's <c>margin</c> values will be used for spacing.</param>
      <param name="options">An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the <c>style</c>.</param>
      <returns>A rectangle with size between minWidth &amp; maxWidth on both axes.</returns>
      <seealso cref="M:UnityEngine.GUILayout.Width(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.Height(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxWidth(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MinHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.MaxHeight(System.Single)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)" />
      <seealso cref="M:UnityEngine.GUILayout.ExpandHeight(System.Boolean)" />
    </member>
    <member name="P:UnityEngine.GUISettings.cursorColor">
      <summary>The color of the cursor in text fields.</summary>
    </member>
    <member name="P:UnityEngine.GUISettings.cursorFlashSpeed">
      <summary>
        <para>The speed of text field cursor flashes.</para>
        <para>This is how many flashes / second. If you set it to 0, flashing will be disabled. If you set it to -1, the flashing speed will match the system default of the end user.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISettings.doubleClickSelectsWord">
      <summary>
        <para>Should double-clicking select words in text fields.</para>
        <para>By default is set to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISettings.selectionColor">
      <summary>The color of the selection rect in text fields.</summary>
    </member>
    <member name="P:UnityEngine.GUISettings.tripleClickSelectsLine">
      <summary>
        <para>Should triple-clicking select whole text in text fields.</para>
        <para>Bu default is set to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISkin.box">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.button">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.Button(UnityEngine.Rect,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.customStyles">
      <summary>Array of GUI styles for specific needs.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.font">
      <summary>The default font to use for all styles.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalScrollbar">
      <summary>Style used by default for the background part of <see cref="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalScrollbarLeftButton">
      <summary>Style used by default for the left button on <see cref="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalScrollbarRightButton">
      <summary>Style used by default for the right button on <see cref="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalScrollbarThumb">
      <summary>Style used by default for the thumb that is dragged in <see cref="M:UnityEngine.GUI.HorizontalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalSlider">
      <summary>
        <para>Style used by default for the background part of <see cref="M:UnityEngine.GUI.HorizontalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)" /> controls.</para>
        <para>The padding property is used to determine the size of the area the thumb can be dragged within.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISkin.horizontalSliderThumb">
      <summary>
        <para>Style used by default for the thumb that is dragged in <see cref="M:UnityEngine.GUI.HorizontalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)" /> controls.</para>
        <para>The padding property is used to determine the size of the thumb.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISkin.label">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.Label(UnityEngine.Rect,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.scrollView">
      <summary>Style used by default for the background of ScrollView controls (see <see cref="M:UnityEngine.GUI.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2,UnityEngine.Rect)" />).</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.settings">
      <summary>Generic settings for how controls should behave with this skin.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.textArea">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.TextArea(UnityEngine.Rect,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.textField">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.TextField(UnityEngine.Rect,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.toggle">
      <summary>Style used by default for <see cref="M:UnityEngine.GUI.Toggle(UnityEngine.Rect,System.Boolean,System.String)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalScrollbar">
      <summary>Style used by default for the background part of <see cref="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalScrollbarDownButton">
      <summary>Style used by default for the down button on <see cref="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalScrollbarThumb">
      <summary>Style used by default for the thumb that is dragged in <see cref="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalScrollbarUpButton">
      <summary>Style used by default for the up button on <see cref="M:UnityEngine.GUI.VerticalScrollbar(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)" /> controls.</summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalSlider">
      <summary>
        <para>Style used by default for the background part of <see cref="M:UnityEngine.GUI.VerticalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)" /> controls.</para>
        <para>The padding property is used to determine the size of the area the thumb can be dragged within.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISkin.verticalSliderThumb">
      <summary>
        <para>Style used by default for the thumb that is dragged in <see cref="M:UnityEngine.GUI.VerticalSlider(UnityEngine.Rect,System.Single,System.Single,System.Single)" /> controls.</para>
        <para>The padding property is used to determine the size of the thumb.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUISkin.window">
      <summary>Style used by default for Window controls (SA <see cref="M:UnityEngine.GUI.Window(System.Int32,UnityEngine.Rect,UnityEngine.GUI.WindowFunction,System.String)" />).</summary>
    </member>
    <member name="M:UnityEngine.GUISkin.FindStyle(System.String)">
      <summary>Try to search for a <see cref="T:UnityEngine.GUIStyle" />. This functions returns NULL and does not give an error.</summary>
    </member>
    <member name="M:UnityEngine.GUISkin.GetStyle(System.String)">
      <summary>Get a named <see cref="T:UnityEngine.GUIStyle" />.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.none">
      <summary>
        <para>Shortcut for an empty GUIStyle.</para>
        <para>This style contains no decoration and just renders everything in the default font.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.active">
      <summary>Rendering settings for when the control is pressed down.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.alignment">
      <summary>Text alignment.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.border">
      <summary>
        <para>The borders of all background images.</para>
        <para>This corresponds to the border settings for GUITextures. It only affects the rendering of the background image and has no effect on positioning.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.clipping">
      <summary>What to do when the contents to be rendered is too large to fit within the area given.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.contentOffset">
      <summary>Pixel offset to apply to the content of this GUIstyle.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.fixedHeight">
      <summary>If non-0, any GUI elements rendered with this style will have the height specified here.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.fixedWidth">
      <summary>If non-0, any GUI elements rendered with this style will have the width specified here.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.focused">
      <summary>Rendering settings for when the element has keyboard focus.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.font">
      <summary>The font to use for rendering. If null, the default font for the current <see cref="T:UnityEngine.GUISkin" /> is used instead.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.fontSize">
      <summary>
        <para>The font size to use (for dynamic fonts).</para>
        <para>If this is set to a non-zero value, the font size specified in the font importer is overriden with a custom size. This is only supported for fonts set to use dynamic font rendering. Other fonts will always use the default font size.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.fontStyle">
      <summary>
        <para>The font style to use (for dynamic fonts).</para>
        <para>If this is set to a value other then normal, the font style set in the font importer is overriden with a custom style. This is only supported for fonts set to use dynamic font rendering. Other fonts will always render in normal style.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.hover">
      <summary>Rendering settings for when the mouse is hovering over the control.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.imagePosition">
      <summary>How image and text of the <see cref="T:UnityEngine.GUIContent" /> is combined.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.lineHeight">
      <summary>The height of one line of text with this style, measured in pixels. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.margin">
      <summary>
        <para>The margins between elements rendered in this style and any other GUI elements.</para>
        <para>This only has effect when using automatic layout.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.name">
      <summary>The name of this GUIStyle. Used for getting them based on name.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.normal">
      <summary>Rendering settings for when the component is displayed normally.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.onActive">
      <summary>Rendering settings for when the element is turned on and pressed down.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.onFocused">
      <summary>Rendering settings for when the element has keyboard and is turned on.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.onHover">
      <summary>Rendering settings for when the control is turned on and the mouse is hovering it.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.onNormal">
      <summary>Rendering settings for when the control is turned on.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.overflow">
      <summary>
        <para>Extra space to be added to the background image.</para>
        <para>This is used if your image has a drop shadow and you want to extend the background image beyond the rectangles specified for gui elements that use this style.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.padding">
      <summary>Space from the edge of <see cref="T:UnityEngine.GUIStyle" /> to the start of the contents.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.richText">
      <summary>Enable HTML-style tags for Text Formatting Markup.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.stretchHeight">
      <summary>Can GUI elements of this style be stretched vertically for better layout?</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.stretchWidth">
      <summary>Can GUI elements of this style be stretched horizontally for better layouting?</summary>
    </member>
    <member name="P:UnityEngine.GUIStyle.wordWrap">
      <summary>
        <para>Should the text be wordwrapped?</para>
        <para>This will cause any text contrained to be wordwrapped to fit within the width of a control.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.#ctor">
      <summary>Constructor for empty GUIStyle.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.#ctor(UnityEngine.GUIStyle)">
      <summary>Constructs GUIStyle identical to given other GUIStyle.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.CalcHeight(UnityEngine.GUIContent,System.Single)">
      <summary>How tall this element will be when rendered with <c>content</c> and a specific <c>width</c>.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)">
      <summary>
        <para>Calculate the minimum and maximum widths for this style rendered with <c>content</c>.</para>
        <para>Used by <see cref="T:UnityEngine.GUILayout" /> to handle word-wrapping elements correctly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.CalcScreenSize(UnityEngine.Vector2)">
      <summary>Calculate the size of an element formatted with this style, and a given space to content.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.CalcSize(UnityEngine.GUIContent)">
      <summary>
        <para>Calculate the size of a some content if it is rendered with this style.</para>
        <para>This function does not take wordwrapping into account. To do that, you need to determine the allocated width and then call <see cref="M:UnityEngine.GUIStyle.CalcHeight(UnityEngine.GUIContent,System.Single)" /> to figure out the wordwrapped height.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw this GUIStyle on to the screen, internal version.</para>
        <para>Draw plain GUIStyle without text nor image.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Draw the GUIStyle with a text string inside.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,UnityEngine.Texture,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Draw the GUIStyle with an image inside. If the image is too large to fit within the content area of the style it is scaled down.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,UnityEngine.GUIContent,System.Int32)">
      <summary>Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,UnityEngine.GUIContent,System.Int32,System.Boolean)">
      <summary>Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.Draw(UnityEngine.Rect,UnityEngine.GUIContent,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.DrawCursor(UnityEngine.Rect,UnityEngine.GUIContent,System.Int32,System.Int32)">
      <summary>Draw this GUIStyle with selected content.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.DrawWithTextSelection(UnityEngine.Rect,UnityEngine.GUIContent,System.Int32,System.Int32,System.Int32)">
      <summary>Draw this GUIStyle with selected content.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.GetCursorPixelPosition(UnityEngine.Rect,UnityEngine.GUIContent,System.Int32)">
      <summary>Get the pixel position of a given string index.</summary>
    </member>
    <member name="M:UnityEngine.GUIStyle.GetCursorStringIndex(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.Vector2)">
      <summary>
        <para>Get the cursor position (indexing into contents.text) when the user clicked at cursorPixelPosition.</para>
        <para>This does not respect any images inside content.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIStyleState.background">
      <summary>The background image used by GUI elements in this given state.</summary>
    </member>
    <member name="P:UnityEngine.GUIStyleState.textColor">
      <summary>The text color used by GUI elements in this state.</summary>
    </member>
    <member name="P:UnityEngine.GUIText.alignment">
      <summary>The alignment of the text.</summary>
    </member>
    <member name="P:UnityEngine.GUIText.anchor">
      <summary>The anchor of the text.</summary>
    </member>
    <member name="P:UnityEngine.GUIText.color">
      <summary>
        <para>The color used to render the text.</para>
        <para>This is the base color used to render the text. &lt;color&gt; tags in rich text markup will override this.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.font">
      <summary>The font used for the text.</summary>
    </member>
    <member name="P:UnityEngine.GUIText.fontSize">
      <summary>
        <para>The font size to use (for dynamic fonts).</para>
        <para>If this is set to a non-zero value, the font size specified in the font importer is overriden with a custom size. This is only supported for fonts set to use dynamic font rendering. Other fonts will always use the default font size.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.fontStyle">
      <summary>
        <para>The font style to use (for dynamic fonts).</para>
        <para>If this is set to a value other then normal, the font style set in the font importer is overriden with a custom style. This is only supported for fonts set to use dynamic font rendering. Other fonts will always render in normal style.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.lineSpacing">
      <summary>
        <para>The line spacing multiplier.</para>
        <para>This is multiplied with the line spacing defined in the font.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.material">
      <summary>
        <para>The <see cref="T:UnityEngine.Material" /> to use for rendering.</para>
        <para>Assing a new material to change how the rendering is handled. Change this material to change the font used for all rendering. If you assign <c>null</c> to <c>material</c>, the built-in basic font is selected.See Also: <see cref="P:UnityEngine.GUIText.font" /> variable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.pixelOffset">
      <summary>
        <para>The pixel offset of the text.</para>
        <para>The text is offset from its original position by this amount.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.richText">
      <summary>
        <para>Enable HTML-style tags for Text Formatting Markup.</para>
        <para>Supported tags are: &lt;color="htmlcolor"&gt;colored text&lt;/color&gt;, where "htmlcolor" is a html color string, like "#ff0000" or "red". &lt;b&gt;bold text&lt;/b&gt; &lt;i&gt;italic text&lt;/i&gt; &lt;size=20&gt;sized text&lt;/size&gt; These are only supported for fonts set to use dynamic font rendering, except for the 'color' tag. Note that richText in Unity is not a full html implementation. Other tags are not supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.tabSize">
      <summary>
        <para>The tab width multiplier.</para>
        <para>This is multiplied with the tab width defined in the font.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIText.text">
      <summary>The text to display.</summary>
    </member>
    <member name="P:UnityEngine.GUITexture.border">
      <summary>The border defines the number of pixels from the edge that are not affected by scale.</summary>
    </member>
    <member name="P:UnityEngine.GUITexture.color">
      <summary>The color of the GUI texture.</summary>
    </member>
    <member name="P:UnityEngine.GUITexture.pixelInset">
      <summary>
        <para>Pixel inset used for pixel adjustments for size and position.</para>
        <para>You can set the transform.localScale to Vector3.zero in order to make the GUI texture always the same pixel size.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUITexture.texture">
      <summary>The texture used for drawing.</summary>
    </member>
    <member name="P:UnityEngine.GUIUtility.hasModalWindow">
      <summary>A global property, which is true if a ModalWindow is being displayed, false otherwise.</summary>
    </member>
    <member name="P:UnityEngine.GUIUtility.hotControl">
      <summary>
        <para>The controlID of the current hot control.</para>
        <para>The hot control is one that is temporarily active. When the user mousedown's on a button, it becomes hot. No other controls are allowed to respond to mouse events while some other control is hot. once the user mouseup's, the control sets <c>hotControl</c> to 0 in order to indicate that other controls can now respond to user input.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GUIUtility.keyboardControl">
      <summary>The controlID of the control that has keyboard focus.</summary>
    </member>
    <member name="P:UnityEngine.GUIUtility.systemCopyBuffer">
      <summary>Get access to the system-wide pasteboard.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(UnityEngine.FocusType)">
      <summary>Get a unique ID for a control.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(UnityEngine.FocusType,UnityEngine.Rect)">
      <summary>Get a unique ID for a control.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(System.Int32,UnityEngine.FocusType)">
      <summary>Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(System.Int32,UnityEngine.FocusType,UnityEngine.Rect)">
      <summary>Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(UnityEngine.GUIContent,UnityEngine.FocusType)">
      <summary>Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetControlID(UnityEngine.GUIContent,UnityEngine.FocusType,UnityEngine.Rect)">
      <summary>Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.</summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GetStateObject(System.Type,System.Int32)">
      <summary>
        <para>Get a state object from a controlID.</para>
        <para>This will return a recycled state object that is unique for <c>controlID</c>. If there is none already, A new one will be created and hooked up to the ControlID.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.GUIToScreenPoint(UnityEngine.Vector2)">
      <summary>
        <para>Convert a point from GUI position to screen space.</para>
        <para>Note: In Unity the screen space y coordinate varies from zero at the top edge of the window to a maximum at the bottom edge of the window. This is different from what you might expect.See Also: GUIUtility.ScreenToGUIPoint.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.QueryStateObject(System.Type,System.Int32)">
      <summary>
        <para>Get an existing state object from a controlID.</para>
        <para>This will return a recycled state object that is unique for <c>controlID</c>. If there is none already, this funtion will return null.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.RotateAroundPivot(System.Single,UnityEngine.Vector2)">
      <summary>
        <para>Helper function to rotate the GUI around a point.</para>
        <para>Modifies GUI.matrix to rotate all GUI elements <c>angle</c> degrees around <c>pivotPoint</c>.See Also: GUI.matrix, <see cref="M:UnityEngine.GUIUtility.ScaleAroundPivot(UnityEngine.Vector2,UnityEngine.Vector2)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.ScaleAroundPivot(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Helper function to scale the GUI around a point.</para>
        <para>Modifies GUI.matrix to rotate all GUI elements <c>angle</c> degrees around <c>pivotPoint</c>.See Also: GUI.matrix, <see cref="M:UnityEngine.GUIUtility.RotateAroundPivot(System.Single,UnityEngine.Vector2)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIUtility.ScreenToGUIPoint(UnityEngine.Vector2)">
      <summary>
        <para>Convert a point from screen space to GUI position.</para>
        <para>Used for reconverting values calculated from <see cref="M:UnityEngine.GUIUtility.GUIToScreenPoint(UnityEngine.Vector2)" />Note: In Unity the screen space y coordinate varies from zero at the top edge of the window to a maximum at the bottom edge of the window. This is different from what you might expect.See Also: GUIUtility.GUIToScreenPoint.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.attitude">
      <summary>Returns the attitude (ie, orientation in space) of the device.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.enabled">
      <summary>Sets or retrieves the enabled status of this gyroscope.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.gravity">
      <summary>Returns the gravity acceleration vector expressed in the device's reference frame.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.rotationRate">
      <summary>
        <para>Returns rotation rate as measured by the device's gyroscope.</para>
        <para>The rotation rate is given as a Vector3 representing the speed of rotation around each of the three axes in radians per second. This is the value as it is reported by the gyroscope hardware - a more accurate measurement that has been processed to remove "bias" can be obtained with the <see cref="P:UnityEngine.Gyroscope.rotationRateUnbiased" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.rotationRateUnbiased">
      <summary>
        <para>Returns unbiased rotation rate as measured by the device's gyroscope.</para>
        <para>The rotation rate is given as a Vector3 representing the speed of rotation around each of the three axes in radians per second. This value has been processed to remove "bias" and give a more accurate measurement. The raw value reported by the gyroscope hardware can be obtained with the <see cref="P:UnityEngine.Gyroscope.rotationRate" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.updateInterval">
      <summary>Sets or retrieves gyroscope interval in seconds.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.userAcceleration">
      <summary>
        <para>Returns the acceleration that the user is giving to the device.</para>
        <para>The significance of this value is that the effect of gravity (which is also detected by the accelerometer) has been removed to leave just the acceleration from the user's movements.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.GetActivityIndicatorStyle">
      <summary>
        <para>Gets the current activity indicator style.</para>
        <para>See <see cref="T:UnityEngine.iOS.ActivityIndicatorStyle" /> and <see cref="T:UnityEngine.AndroidActivityIndicatorStyle" /> for the set of style options available.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color,UnityEngine.FullScreenMovieControlMode,UnityEngine.FullScreenMovieScalingMode)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle.Calling this function will pause Unity during movie playback. When playback finishes Unity will resume.The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name.On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone.For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards:H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile.MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content.You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference" />On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported.On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control.On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store" /></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
      <param name="controlMode">How the playback controls are to be displayed.</param>
      <param name="scalingMode">How the movie is to be scaled to fit the screen.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color,UnityEngine.FullScreenMovieControlMode)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle.Calling this function will pause Unity during movie playback. When playback finishes Unity will resume.The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name.On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone.For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards:H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile.MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content.You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference" />On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported.On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control.On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store" /></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
      <param name="controlMode">How the playback controls are to be displayed.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle.Calling this function will pause Unity during movie playback. When playback finishes Unity will resume.The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name.On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone.For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards:H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile.MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content.You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference" />On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported.On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control.On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store" /></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle.Calling this function will pause Unity during movie playback. When playback finishes Unity will resume.The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name.On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone.For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards:H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile.MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content.You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference" />On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported.On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control.On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store" /></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
    </member>
    <member name="M:UnityEngine.Handheld.SetActivityIndicatorStyle(UnityEngine.AndroidActivityIndicatorStyle)">
      <summary>
        <para>Sets the desired activity indicator style.</para>
        <para>Note that the change will take effect on next call to StartActivityIndicator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.StartActivityIndicator">
      <summary>
        <para>Starts os activity indicator.</para>
        <para>Please be warned that this informs os ui system to start. For actual animation to take effect you usually need to wait till the end of this frame. So if you want activity indicator to be animated during synced operation, please use coroutines.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.StopActivityIndicator">
      <summary>Stops os activity indicator.</summary>
    </member>
    <member name="M:UnityEngine.Handheld.Vibrate">
      <summary>Triggers device vibration.</summary>
    </member>
    <member name="P:UnityEngine.Hash128.isValid">
      <summary>Get if the hash value is valid or not. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.Hash128.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Construct the Hash128.</summary>
    </member>
    <member name="M:UnityEngine.Hash128.ToString">
      <summary>Convert Hash128 to string.</summary>
    </member>
    <member name="M:UnityEngine.Hash128.Parse(System.String)">
      <summary>Convert the input string to Hash128.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.angle">
      <summary>
        <para>The current angle in degrees of the joint relative to its rest position. (Read Only)</para>
        <para>The rest angle between the bodies is always zero at the beginning of the simulation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.limits">
      <summary>
        <para>Limit of angular rotation (in degrees) on the hinge joint.</para>
        <para>The joint will be limited so that the angle is always between <see cref="P:UnityEngine.JointLimits.min" /> and <see cref="P:UnityEngine.JointLimits.max" />. The joint angle is in degrees relative to the rest angle. The rest angle between the bodies is always zero at the beginning of the simulation.See Also: <see cref="P:UnityEngine.HingeJoint.useLimits" />, <see cref="T:UnityEngine.JointLimits" />.</para>
        <para>Modifying the limits does not automatically enable the limits.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.motor">
      <summary>
        <para>The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.</para>
        <para>The motor tries to reach <see cref="P:UnityEngine.JointMotor.targetVelocity" /> angular velocity in degrees per second. The motor will only be able to reach <c>targetVelocity</c>, if <see cref="P:UnityEngine.JointMotor.force" /> is sufficiently large. If the joint is spinning faster than <c>targetVelocity</c> the motor will break. A negative <c>targetVelocity</c> will make the motor spin in the opposite direction.The <c>force</c> is the maximum torque the motor can exert. If it is zero the motor is disabled.The motor will brake when it is spinning faster than <c>targetVelocity</c> only, if <see cref="P:UnityEngine.JointMotor.freeSpin" /> is false. If <c>freeSpin</c> is true the motor will not brake.See Also: <see cref="P:UnityEngine.HingeJoint.useMotor" />, <see cref="T:UnityEngine.JointMotor" />.</para>
        <para>Modifying the motor does not automatically enable the motor.Enabling the motor overrides the <see cref="P:UnityEngine.HingeJoint.spring" />, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.spring">
      <summary>
        <para>The spring attempts to reach a target angle by adding spring and damping forces.</para>
        <para>The <see cref="F:UnityEngine.JointSpring.spring" /> force attempts to reach the target angle. A larger value makes the spring reach the target position faster.The <see cref="F:UnityEngine.JointSpring.damper" /> force dampens the angular velocity. A larger value makes the spring reach the goal slower.The spring reaches for the <see cref="F:UnityEngine.JointSpring.targetPosition" /> angle in degrees relative to the rest angle. The rest angle between the bodies is always zero at the beginning of the simulation.See Also: <see cref="P:UnityEngine.HingeJoint.useSpring" />, <see cref="T:UnityEngine.JointSpring" />.</para>
        <para>Modifying the spring does not automatically enable it.Enabling the <see cref="P:UnityEngine.HingeJoint.motor" />overrides the spring, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useLimits">
      <summary>Enables the joint's <see cref="P:UnityEngine.HingeJoint.limits" />. Disabled by default.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useMotor">
      <summary>
        <para>Enables the joint's <see cref="P:UnityEngine.HingeJoint.motor" />. Disabled by default.</para>
        <para>If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useSpring">
      <summary>
        <para>Enables the joint's <see cref="P:UnityEngine.HingeJoint.spring" />. Disabled by default.</para>
        <para>If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.velocity">
      <summary>The angular velocity of the joint in degrees per second.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.jointAngle">
      <summary>The current joint angle (in degrees) with respect to the reference angle.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.jointSpeed">
      <summary>The current joint speed.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.limits">
      <summary>Limit of angular rotation (in degrees) on the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.limitState">
      <summary>Gets the state of the joint limit.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.motor">
      <summary>Parameters for the motor force applied to the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.referenceAngle">
      <summary>The angle (in degrees) referenced between the two bodies used as the constraint for the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.useLimits">
      <summary>Should limits be placed on the range of rotation?</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.useMotor">
      <summary>Should the joint be rotated automatically by a motor torque?</summary>
    </member>
    <member name="M:UnityEngine.HingeJoint2D.GetMotorTorque(System.Single)">
      <summary>Gets the motor torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor torque for.</param>
    </member>
    <member name="M:UnityEngine.HingeJoint2D.GetReactionForce(System.Single)">
      <summary>Gets the reaction force of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction force for.</param>
    </member>
    <member name="M:UnityEngine.HingeJoint2D.GetReactionTorque(System.Single)">
      <summary>Gets the reaction torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction torque for.</param>
    </member>
    <member name="P:UnityEngine.HostData.comment">
      <summary>A miscellaneous comment (can hold data).</summary>
    </member>
    <member name="P:UnityEngine.HostData.connectedPlayers">
      <summary>Currently connected players.</summary>
    </member>
    <member name="P:UnityEngine.HostData.gameName">
      <summary>The name of the game (like John Doe's Game).</summary>
    </member>
    <member name="P:UnityEngine.HostData.gameType">
      <summary>The type of the game (like "MyUniqueGameType").</summary>
    </member>
    <member name="P:UnityEngine.HostData.guid">
      <summary>The GUID of the host, needed when connecting with NAT punchthrough.</summary>
    </member>
    <member name="P:UnityEngine.HostData.ip">
      <summary>Server IP address.</summary>
    </member>
    <member name="P:UnityEngine.HostData.passwordProtected">
      <summary>Does the server require a password?</summary>
    </member>
    <member name="P:UnityEngine.HostData.playerLimit">
      <summary>Maximum players limit.</summary>
    </member>
    <member name="P:UnityEngine.HostData.port">
      <summary>Server port.</summary>
    </member>
    <member name="P:UnityEngine.HostData.useNat">
      <summary>Does this server require NAT punchthrough?</summary>
    </member>
    <member name="P:UnityEngine.HumanBone.boneName">
      <summary>
        <para>The name of the bone to which the Mecanim human bone is mapped.</para>
        <para>This is the name of the bone in the original model and also of the Transform that represents it in the Unity GameObject.See Also: humanName.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanBone.humanName">
      <summary>
        <para>The name of the Mecanim human bone to which the bone from the model is mapped.</para>
        <para>To get a list of all the available human bones from code, you should use <see cref="P:UnityEngine.HumanTrait.BoneName" />.See Also: boneName.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanBone.limit">
      <summary>
        <para>The rotation limits that define the muscle for this bone.</para>
        <para>The muscle contains the default orientation of the bone alone with the allowed limits of rotation away from the default around all three axes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.armStretch">
      <summary>
        <para>Amount by which the arm's length is allowed to stretch when using IK.</para>
        <para>Inverse Kinematics (IK) can often be handled more smoothly if a small amount of "slack" is allowed in the positions of bones relative to each other. This property controls how much slack is available in the arm joints. The value is given in world distance units in the range 0..1. For example, with the default setting of 0.05, the arm will begin to stretch when the IK goal is at 95% of the target and will stretch by 5%. The stretch is carried out by translating both the elbow and wrist transforms.The ideal value will depend on the rig and the animation but in general, a larger value will make for a smoother IK computation at the expense of more unrealistic stretching of the arm.See Also: legStretch.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.feetSpacing">
      <summary>
        <para>Modification to the minimum distance between the feet of a humanoid model.</para>
        <para>When a humanoid model has unusually large feet (a cartoon-like character, say) the meshes for the feet can sometimes interpenetrate during IK movement. The default value for <c>feetSpacing</c> is zero, but using a larger value will increase the minimum distance that is maintained between the feet and avoid interpenetration.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.hasTranslationDoF">
      <summary>
        <para>True for any human that has a translation Degree of Freedom (DoF). It is set to false by default.</para>
        <para>Translation DoF are on Spine, Chest, Neck, Shoulder and Upper Leg bones.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanDescription.human">
      <summary>
        <para>Mapping between Mecanim bone names and bone names in the rig.</para>
        <para>Each item in the array is a HumanBone object that contains a Mecanim avatar bone name, a bone name in the model (to which the Mecanim bone is mapped) and a "muscle" that specifies the bone's limits of motion. The bones can be listed in any order but there are a certain number of bones that Mecanim requires you to define; use <see cref="M:UnityEngine.HumanTrait.RequiredBone(System.Int32)" /> to get a list of all required bones.See Also: <see cref="P:UnityEngine.HumanTrait.BoneName" />, <see cref="M:UnityEngine.HumanTrait.RequiredBone(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.legStretch">
      <summary>
        <para>Amount by which the leg's length is allowed to stretch when using IK.</para>
        <para>Inverse Kinematics (IK) can often be handled more smoothly if a small amount of "slack" is allowed in the positions of bones relative to each other. This property controls how much slack is available in the leg joints. The value is given in world distance units in the range 0..1. For example, with the default setting of 0.05, the leg will begin to stretch when the IK goal is at 95% of the target and will stretch by 5%. The stretch is carried out by translating both the knee and ankle transforms.The ideal value will depend on the rig and the animation but in general, a larger value will make for a smoother IK computation at the expense of more unrealistic stretching of the leg.See Also: armStretch.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.lowerArmTwist">
      <summary>
        <para>Defines how the lower arm's roll/twisting is distributed between the elbow and wrist joints.</para>
        <para>When the lower arm needs to twist or "roll" for the IK, the rotation can be applied at the wrist or elbow joints or some twist can be applied at both. The <c>lowerArmTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the elbow and wrist. For example, a value of zero means the twist should be handled entirely at the elbow, while a value of one means it should be applied entirely at the wrist. The default value of 0.5 distributes the twisting evenly between elbow and wrist.See Also: upperArmTwist, lowerLegTwist, upperLegTwist.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.lowerLegTwist">
      <summary>
        <para>Defines how the lower leg's roll/twisting is distributed between the knee and ankle.</para>
        <para>When the lower leg needs to twist or "roll" for the IK, the rotation can be applied at the knee or ankle joints or some twist can be applied at both. The <c>lowerLegTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the knee and ankle. For example, a value of zero means the twist should be handled entirely at the knee, while a value of one means it should be applied entirely at the ankle. The default value of 0.5 distributes the twisting evenly between knee and ank;e.See Also: upperArmTwist, lowerArmTwist, upperLegTwist.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanDescription.skeleton">
      <summary>
        <para>List of bone Transforms to include in the model.</para>
        <para>This list define which transforms to include in the final avatar skeleton. Strange results can occur if a parent transform (ie, one with children in the hierarchy) is omitted from the list.See Also: SkeletonBone.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.upperArmTwist">
      <summary>
        <para>Defines how the lower arm's roll/twisting is distributed between the shoulder and elbow joints.</para>
        <para>When the upper arm needs to twist or "roll" for the IK, the rotation can be applied at the shoulder or elbow joints or some twist can be applied at both. The <c>upperArmTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the shoulder and elbow. For example, a value of zero means the twist should be handled entirely at the shoulder, while a value of one means it should be applied entirely at the elbow. The default value of 0.5 distributes the twisting evenly between shoulder and elbow.See Also: lowerArmTwist, lowerLegTwist, upperLegTwist.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.upperLegTwist">
      <summary>
        <para>Defines how the upper leg's roll/twisting is distributed between the thigh and knee joints.</para>
        <para>When the upper leg needs to twist or "roll" for the IK, the rotation can be applied at the thigh or knee joints or some twist can be applied at both. The <c>upperLegTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the thigh and knee. For example, a value of zero means the twist should be handled entirely at the thigh, while a value of one means it should be applied entirely at the knee. The default value of 0.5 distributes the twisting evenly between thigh and knee.See Also: lowerArmTwist, lowerLegTwist, upperArmTwist.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.axisLength">
      <summary>Length of the bone to which the limit is applied.</summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.center">
      <summary>
        <para>The default orientation of a bone when no muscle action is applied.</para>
        <para>The vector value represents the bone's rotation in degrees around the X, Y and Z axes relative to the initial position of the bone in the skeleton. Any muscle rotation subsequently applied to the bone will be relative to this value.If <see cref="P:UnityEngine.HumanLimit.useDefaultValues" /> is enabled, the value of <c>center</c> will be [0, 0, 0].See Also: HumanLimit.useDefaultValues.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.max">
      <summary>
        <para>The maximum rotation away from the initial value that this muscle can apply.</para>
        <para>The <see cref="P:UnityEngine.HumanLimit.center" /> property specifies the rotation of the bone when the muscle is at "rest". The <c>max</c> value specfies the maximum rotation in degrees away from the rest value that the muscle can apply. The <see cref="P:UnityEngine.HumanLimit.min" /> value specifies a similar limit but in the negative direction of rotation.The allowed range for the maximum is 0..180 degrees.See Also: HumanLimit.useDefaultValues.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.min">
      <summary>
        <para>The maximum negative rotation away from the initial value that this muscle can apply.</para>
        <para>The <see cref="P:UnityEngine.HumanLimit.center" /> property specifies the rotation of the bone when the muscle is at "rest". The <c>min</c> value specfies the maximum negative rotation in degrees away from the rest value that the muscle can apply. The <see cref="P:UnityEngine.HumanLimit.max" /> value specifies a similar limit but in the positive direction of rotation.The allowed range for the minimum is -180..0 degrees.See Also: HumanLimit.useDefaultValues.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.useDefaultValues">
      <summary>
        <para>Should this limit use the default values?</para>
        <para>You should set useDefaultValues to false if you want to use your own limit values, otherwise the defaults will override your settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.BoneCount">
      <summary>The number of human bone types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.BoneName">
      <summary>Array of the names of all human bone types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.MuscleCount">
      <summary>The number of human muscle types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.MuscleName">
      <summary>Array of the names of all human muscle types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.RequiredBoneCount">
      <summary>The number of bone types that are required by Mecanim for any human model.</summary>
    </member>
    <member name="M:UnityEngine.HumanTrait.BoneFromMuscle(System.Int32)">
      <summary>
        <para>Return the bone to which a particular muscle is connected.</para>
        <para>The bone and muscle indices used by this function are the same as those of the <see cref="P:UnityEngine.HumanTrait.BoneName" /> and <see cref="P:UnityEngine.HumanTrait.MuscleName" /> arrays respectively.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetMuscleDefaultMax(System.Int32)">
      <summary>
        <para>Get the default maximum value of rotation for a muscle in degrees.</para>
        <para>The default maximum applies to all three axes of rotation for the muscle. The indexing order for the muscles is the same as that of the <see cref="P:UnityEngine.HumanTrait.MuscleName" /> array.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetMuscleDefaultMin(System.Int32)">
      <summary>
        <para>Get the default minimum value of rotation for a muscle in degrees.</para>
        <para>The default minimum applies to all three axes of rotation for the muscle. The indexing order for the muscles is the same as that of the <see cref="P:UnityEngine.HumanTrait.MuscleName" /> array.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetParentBone(System.Int32)">
      <summary>Returns parent humanoid bone index of a bone.</summary>
      <param name="i">Humanoid bone index to get parent from.</param>
      <returns>Humanoid bone index of parent.</returns>
    </member>
    <member name="M:UnityEngine.HumanTrait.MuscleFromBone(System.Int32,System.Int32)">
      <summary>
        <para>Obtain the muscle index for a particular bone index and "degree of freedom".</para>
        <para>The indexing order of the bones is the same as that of the <see cref="P:UnityEngine.HumanTrait.BoneName" /> array.See Also: BoneName, BoneCount, MuscleName, MuscleCount.</para>
      </summary>
      <param name="i">Bone index.</param>
      <param name="dofIndex">Number representing a "degree of freedom": 0 for X-Axis, 1 for Y-Axis, 2 for Z-Axis.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.RequiredBone(System.Int32)">
      <summary>
        <para>Is the bone a member of the minimal set of bones that Mecanim requires for a human model?</para>
        <para>The indexing order of the bones is the same as that used for the <see cref="P:UnityEngine.HumanTrait.BoneName" /> array.</para>
      </summary>
      <param name="i">Index of the bone to test.</param>
    </member>
    <member name="P:UnityEngine.Input.acceleration">
      <summary>Last measured linear acceleration of a device in three-dimensional space. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.accelerationEventCount">
      <summary>Number of acceleration measurements which occurred during last frame.</summary>
    </member>
    <member name="P:UnityEngine.Input.accelerationEvents">
      <summary>Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables).</summary>
    </member>
    <member name="P:UnityEngine.Input.anyKey">
      <summary>Is any key or mouse button currently held down? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.anyKeyDown">
      <summary>
        <para>Returns true the first frame the user hits any key or mouse button. (Read Only)</para>
        <para>You should be polling this variable from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has released all keys / buttons and pressed any key / buttons again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compass">
      <summary>Property for accessing compass (handheld devices only). (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.compensateSensors">
      <summary>
        <para>This property controls if input sensors should be compensated for screen orientation.</para>
        <para>Compensated sensors are accelerometer, compass, gyroscope. Note : currently it fully affects iOS platform and partially Android platform (on Android compensation can't be turned off at the moment).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compositionCursorPos">
      <summary>
        <para>The current text input position used by IMEs to open windows.</para>
        <para>Some language IMEs such as Japanese will open windows while the user is typing text, to aid the user in picking the correct input strings. These windows are expected to pop up at the current cursor position, so the IME needs to know where input is displayed. When using Unity's built in GUI system for text input, Unity will take care of setting the cursor position for the IME. However, if you wish to implement your own GUI for text input, you need to set this to the current text input position for IME windows to show up correctly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compositionString">
      <summary>
        <para>The current IME composition string being typed by the user.</para>
        <para>In some languages such as Chinese, Japanese or Korean, text is input by typing multiple keys to generate one or multiple characters. These characters are visually composed on the screen as the user types. When using Unity's built in GUI system for text input, Unity will take care of displaying the composition strings as the users types. If you want to implement your own GUI, however, you need to take care of displaying the string at the current cursor position. The composition string is only updated when IME compositing is used. See <see cref="P:UnityEngine.Input.imeCompositionMode" /> for more info.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.deviceOrientation">
      <summary>Device physical orientation as reported by OS. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.gyro">
      <summary>Returns default gyroscope.</summary>
    </member>
    <member name="P:UnityEngine.Input.imeCompositionMode">
      <summary>
        <para>Controls enabling and disabling of IME input composition.</para>
        <para>Some languages use complex input methods which involve opening windows to insert characters. Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text. By default, Unity will enable IME composition when in text fields, and disable it otherwise. However, when you want to implement your own input GUI, you may want to have control over this yourself, which is possible using the imeCompositionMode property. Set it to <c>Auto</c> for the default behavior, or <c>On</c> or <c>Off</c> to explicitly enable or disable IME composition.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.imeIsSelected">
      <summary>
        <para>Does the user have an IME keyboard input source selected?</para>
        <para>This returns true if the users keyboard is currently configured for IME input, and false otherwise. Since users of asian languages can typically turn IME conversion on or off using a keystroke, it is useful to provide some visual indication of IME being enabled. This can be done by checking Input.imeIsSelected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.inputString">
      <summary>
        <para>Returns the keyboard input entered this frame. (Read Only)</para>
        <para>Only ASCII characters are contained in the <c>inputString</c>.The string can contain two special characters which should be handled: Character <c>"\b"</c> represents backspace. Character <c>"\n"</c> represents return or enter.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.location">
      <summary>Property for accessing device location (handheld devices only). (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.mousePosition">
      <summary>
        <para>The current mouse position in pixel coordinates. (Read Only)</para>
        <para>The bottom-left of the screen or window is at (0, 0). The top-right of the screen or window is at (Screen.width, Screen.height).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.mouseScrollDelta">
      <summary>The current mouse scroll delta. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.multiTouchEnabled">
      <summary>Property indicating whether the system handles multiple touches.</summary>
    </member>
    <member name="P:UnityEngine.Input.simulateMouseWithTouches">
      <summary>
        <para>Enables/Disables mouse simulation with touches. By default this option is enabled.</para>
        <para>If enabled, up to three concurrent touches are translated to state on the respective mouse buttons (example: a two-finger tap will be equal to a right-button mouse click).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.touchCount">
      <summary>Number of touches. Guaranteed not to change throughout the frame. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.touches">
      <summary>
        <para>Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables).</para>
        <para>Each entry represents a status of a finger touching the screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.touchSupported">
      <summary>
        <para>Returns whether the device on which application is currently running supports touch input.</para>
        <para>Rather than checking the platform, use this property to determine whether your game should expect touch input, as some platforms can support multiple input methods.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetAccelerationEvent(System.Int32)">
      <summary>Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables).</summary>
    </member>
    <member name="M:UnityEngine.Input.GetAxis(System.String)">
      <summary>
        <para>Returns the value of the virtual axis identified by <c>axisName</c>.</para>
        <para>The value will be in the range -1...1 for keyboard and joystick input. If the axis is setup to be delta mouse movement, the mouse delta is multiplied by the axis sensitivity and the range is not -1...1.This is frame-rate independent; you do not need to be concerned about varying frame-rates when using this value.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetAxisRaw(System.String)">
      <summary>
        <para>Returns the value of the virtual axis identified by <c>axisName</c> with no smoothing filtering applied.</para>
        <para>The value will be in the range -1...1 for keyboard and joystick input. Since input is not smoothed, keyboard input will always be either -1, 0 or 1. This is useful if you want to do all smoothing of keyboard input processing yourself.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButton(System.String)">
      <summary>
        <para>Returns true while the virtual button identified by <c>buttonName</c> is held down.</para>
        <para>Think auto fire - this will return true as long as the button is held down.Use this only when implementing events that trigger an action, eg, shooting a weapon. Use <see cref="M:UnityEngine.Input.GetAxis(System.String)" /> for input that controls continuous movement.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButtonDown(System.String)">
      <summary>
        <para>Returns true during the frame the user pressed down the virtual button identified by <c>buttonName</c>.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has released the key and pressed it again.Use this only when implementing action like events IE: shooting a weapon. Use Input.GetAxis for any kind of movement behaviour.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButtonUp(System.String)">
      <summary>
        <para>Returns true the first frame the user releases the virtual button identified by <c>buttonName</c>.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has pressed the button and released it again.Use this only when implementing action like events IE: shooting a weapon. Use Input.GetAxis for any kind of movement behaviour.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetJoystickNames">
      <summary>
        <para>Returns an array of strings describing the connected joysticks.</para>
        <para>This can be useful in user input configuration screens - this way, instead of showing labels like "Joystick 1", you can show more meaningful names like "Logitech WingMan". To read values from different joysticks, you need to assign respective axes for the number of joysticks you want to support in the Input Manager.The position of a joystick in this array corresponds to the joystick number, i.e. the name in position 0 of this array is for the joystick that feeds data into 'Joystick 1' in the Input Manager, the name in position 1 corresponds to 'Joystick 2', and so on. Note that some entries in the array may be blank if no device is connected for that joystick number.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKey(System.String)">
      <summary>
        <para>Returns true while the user holds down the key identified by <c>name</c>. Think auto fire.</para>
        <para>For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKey(UnityEngine.KeyCode)">
      <summary>Returns true while the user holds down the key identified by the <c>key</c><see cref="T:UnityEngine.KeyCode" /> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyDown(System.String)">
      <summary>
        <para>Returns true during the frame the user starts pressing down the key identified by <c>name</c>.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has released the key and pressed it again.For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode)">
      <summary>Returns true during the frame the user starts pressing down the key identified by the <c>key</c><see cref="T:UnityEngine.KeyCode" /> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyUp(System.String)">
      <summary>
        <para>Returns true during the frame the user releases the key identified by <c>name</c>.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has pressed the key and released it again.For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode)">
      <summary>Returns true during the frame the user releases the key identified by the <c>key</c><see cref="T:UnityEngine.KeyCode" /> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButton(System.Int32)">
      <summary>
        <para>Returns whether the given mouse button is held down.</para>
        <para>
          <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButtonDown(System.Int32)">
      <summary>
        <para>Returns true during the frame the user pressed the given mouse button.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has released the mouse button and pressed it again. <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButtonUp(System.Int32)">
      <summary>
        <para>Returns true during the frame the user releases the given mouse button.</para>
        <para>You need to call this function from the <see href="MonoBehaviour.Update" cref="Update" /> function, since the state gets reset each frame. It will not return true until the user has pressed the mouse button and released it again. <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetTouch(System.Int32)">
      <summary>Returns object representing status of a specific touch. (Does not allocate temporary variables).</summary>
    </member>
    <member name="M:UnityEngine.Input.IsJoystickPreconfigured(System.String)">
      <summary>
        <para>Determine whether a particular joystick model has been preconfigured by Unity. (Linux-only).</para>
        <para>Preconfigured joysticks report indices for buttons and axes in the following order. Buttons: A, B, X, Y, left bumper, right bumper, select, start, guide, left stick press, right stick press Axes: left stick x, left stick y, left trigger, right stick x, right stick y, right trigger, dpad horizontal, dpad vertical.</para>
      </summary>
      <param name="joystickName">The name of the joystick to check (returned by <see cref="M:UnityEngine.Input.GetJoystickNames" />).</param>
      <returns>True if the joystick layout has been preconfigured; false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Input.ResetInputAxes">
      <summary>
        <para>Resets all input. After ResetInputAxes all axes return to 0 and all buttons return to 0 for one frame.</para>
        <para>This can be useful when respawning the player and you don't want any input from keys that might still be held down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.anchor">
      <summary>
        <para>The Position of the anchor around which the joints motion is constrained.</para>
        <para>The Position is defined in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.autoConfigureConnectedAnchor">
      <summary>
        <para>Should the <c>connectedAnchor</c> be calculated automatically?</para>
        <para>If this is enabled, then the <c>connectedAnchor</c> property will be calculated automatically to match the global position of the <c>anchor</c> property. This is the default behavior. If this is disabled, you can configure the position of the connected anchor using the <c>connectedAnchor</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.axis">
      <summary>
        <para>The Direction of the axis around which the body is constrained.</para>
        <para>The Axis is defined in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.breakForce">
      <summary>
        <para>The force that needs to be applied for this joint to break.</para>
        <para>The force might come from collisions with other objects, forces applied with <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" /> or from other joints. The break force can be set to <see cref="F:UnityEngine.Mathf.Infinity" /> to render the joint unbreakable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.breakTorque">
      <summary>
        <para>The torque that needs to be applied for this joint to break.</para>
        <para>The torque might come from collisions with other objects, forces applied with <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" /> or from other joints. The break torque can be set to <see cref="F:UnityEngine.Mathf.Infinity" /> to render the joint unbreakable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.connectedAnchor">
      <summary>
        <para>Position of the anchor relative to the connected Rigidbody.</para>
        <para>If <c>Joint.autoConfigureConnectedAnchor</c> is not enabled, then this will be used to set the position of the anchor on the connected rigidbody. The position is given in local coordinates of the connected rigidbody, or in world coordinates if there is no connected rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.connectedBody">
      <summary>
        <para>A reference to another rigidbody this joint connects to.</para>
        <para>If not set then the joint connects the object to a fixed point in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.enableCollision">
      <summary>Enable collision between bodies connected with the joint.</summary>
    </member>
    <member name="P:UnityEngine.Joint.enablePreprocessing">
      <summary>
        <para>Toggle preprocessing for this joint.</para>
        <para>This flag has a connection with rigidbodies that have some of their rotational degrees of freedom frozed. The common example is a 2D game that uses 3D rigidbodies with some of their translational and rotational degrees of freedom frozen.Rigidbody rotations freezing is internally implemented by setting an infinite inertia around those frozen axes so that the body does not rotate because it's very resistant to. This approach has some nice properties: most significantly it lets such bodies to correctly go to sleep as opposed to the approach where we would cancel out the rotations around the frozen axes as a post-solver step.However the downside is that very stiff solver constraints can be generated when such bodies are connected with joints. When the flag is set, PhysX would ignore constraints that produce huge impulses generating only a small change in velocity. Whilst it may reduce the overall accuracy of the joint simulation, it's been proven to help with overconstrained configurations like in the 2D case.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.connectedBody">
      <summary>
        <para>The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component).</para>
        <para>If this property is set to null then the joint attaches to a fixed point in space rather than another Rigidbody2D.See Also: <see cref="T:UnityEngine.Rigidbody2D" /> class, <c>collideConnected</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.enableCollision">
      <summary>Should rigid bodies connected with this joint collide?</summary>
    </member>
    <member name="P:UnityEngine.JointAngleLimits2D.max">
      <summary>Upper angular limit of rotation.</summary>
    </member>
    <member name="P:UnityEngine.JointAngleLimits2D.min">
      <summary>Lower angular limit of rotation.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.maximumForce">
      <summary>Amount of force applied to push the object toward the defined direction.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.mode">
      <summary>Whether the drive should attempt to reach position, velocity, both or nothing.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.positionDamper">
      <summary>Resistance strength against the Position Spring. Only used if <c>mode</c> includes Position.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.positionSpring">
      <summary>Strength of a rubber-band pull toward the defined direction. Only used if <c>mode</c> includes Position.</summary>
    </member>
    <member name="P:UnityEngine.JointLimits.bounceMinVelocity">
      <summary>
        <para>The minimum impact velocity which will cause the joint to bounce.</para>
        <para>This can lead to jittering and performance problems. Setting this very high will cause to joint to never bounce.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.bounciness">
      <summary>Determines the size of the bounce when the joint hits it's limit. Also known as restitution.</summary>
    </member>
    <member name="P:UnityEngine.JointLimits.contactDistance">
      <summary>
        <para>Distance inside the limit value at which the limit will be considered to be active by the solver.</para>
        <para>Setting this low can cause jittering, but runs fast. Setting high can deduce jittering, but runs the solver more often. (0 = use defaults)For translational joints the unit is meters. For rotational joints the unit is degrees. Pipeline: .</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.max">
      <summary>
        <para>The upper angular limit (in degrees) of the joint.</para>
        <para>When the joint angle or position is above it, the joint will exert forces to constrain it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.min">
      <summary>
        <para>The lower angular limit (in degrees) of the joint.</para>
        <para>When the joint angle or position is below it, the joint will exert forces to constrain it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointMotor.force">
      <summary>The motor will apply a force.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor.freeSpin">
      <summary>If <c>freeSpin</c> is enabled the motor will only accelerate but never slow down.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor.targetVelocity">
      <summary>The motor will apply a force up to <c>force</c> to achieve <c>targetVelocity</c>.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor2D.maxMotorTorque">
      <summary>The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor2D.motorSpeed">
      <summary>The desired speed for the Rigidbody2D to reach as it moves with the joint.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.damper">
      <summary>The damper force uses to dampen the spring.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.spring">
      <summary>The spring forces used to reach the target position.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.targetPosition">
      <summary>
        <para>The target position the joint attempts to reach.</para>
        <para>In the case of a <see cref="T:UnityEngine.HingeJoint" /> the target position is the target angle in degrees.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.angle">
      <summary>
        <para>The world angle (in degrees) along which the suspension will move.</para>
        <para>This provides 2D constrained motion similar to a SliderJoint2D. This is typically how suspension works in the real world.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.dampingRatio">
      <summary>
        <para>The amount by which the suspension spring force is reduced in proportion to the movement speed.</para>
        <para>The suspension spring will oscillate with a certain frequency as forces are added and removed from it. The higher the damping ratio, the quicker the oscillation will die down to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.frequency">
      <summary>
        <para>The frequency at which the suspension spring oscillates.</para>
        <para>The suspension spring will oscillate with a certain frequency as forces are added and removed from it. A <c>damping ratio</c> can be set to cause this oscillation to die down over time.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointTranslationLimits2D.max">
      <summary>Maximum distance the Rigidbody2D object can move from the Slider Joint's anchor.</summary>
    </member>
    <member name="P:UnityEngine.JointTranslationLimits2D.min">
      <summary>Minimum distance the Rigidbody2D object can move from the Slider Joint's anchor.</summary>
    </member>
    <member name="P:UnityEngine.Keyframe.inTangent">
      <summary>Describes the tangent when approaching this point from the previous point in the curve.</summary>
    </member>
    <member name="P:UnityEngine.Keyframe.outTangent">
      <summary>Describes the tangent when leaving this point towards the next point in the curve.</summary>
    </member>
    <member name="P:UnityEngine.Keyframe.time">
      <summary>
        <para>The time of the keyframe.</para>
        <para>In a 2D graph you could think of this as the x-value.See Also: <see cref="P:UnityEngine.Keyframe.value" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Keyframe.value">
      <summary>
        <para>The value of the curve at keyframe.</para>
        <para>In a 2D graph you could think of this as the y-value.See Also: <see cref="P:UnityEngine.Keyframe.time" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Keyframe.#ctor(System.Single,System.Single)">
      <summary>Create a keyframe.</summary>
    </member>
    <member name="M:UnityEngine.Keyframe.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Create a keyframe.</summary>
    </member>
    <member name="P:UnityEngine.LayerMask.value">
      <summary>Converts a layer mask value to an integer value.</summary>
    </member>
    <member name="M:UnityEngine.LayerMask.GetMask(System.String[])">
      <summary>Given a set of layer names as defined by either a Builtin or a User Layer in the Tags and Layers manager, returns the equivalent layer mask for all of them.</summary>
      <param name="layerNames">List of layer names to convert to a layer mask.</param>
      <returns>The layer mask created from the <c>layerNames</c>.</returns>
    </member>
    <member name="M:UnityEngine.LayerMask.LayerToName(System.Int32)">
      <summary>Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the Tags and Layers manager.</summary>
    </member>
    <member name="M:UnityEngine.LayerMask.NameToLayer(System.String)">
      <summary>Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the Tags and Layers manager.</summary>
    </member>
    <member name="P:UnityEngine.LensFlare.brightness">
      <summary>
        <para>The strength of the flare.</para>
        <para>This controls the size and brightness of the flare elements.See Also: Lens flare component, flare assets.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LensFlare.color">
      <summary>
        <para>The color of the flare.</para>
        <para>This controls the color of some flare elements (the ones that have <c>use light color</c> enabled).See Also: Lens flare component, flare assets.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LensFlare.fadeSpeed">
      <summary>The fade speed of the flare.</summary>
    </member>
    <member name="P:UnityEngine.LensFlare.flare">
      <summary>The flare asset to use.</summary>
    </member>
    <member name="P:UnityEngine.Light.alreadyLightmapped">
      <summary>
        <para>Has the light already been lightmapped.</para>
        <para>When manually assembling a lightmapped scene set this property appropriately, so that the light doesn't affect lightmapped objects twice, but at the same time affects dynamic objects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.areaSize">
      <summary>The size of the area light. Editor only.</summary>
    </member>
    <member name="P:UnityEngine.Light.bounceIntensity">
      <summary>
        <para>The multiplier that defines the strength of the bounce lighting.</para>
        <para>0 means no bounce light (only direct lighting) will be produced. 1 is physically correct behaviour and the default. The intensity of indirect lighting scales the same with the intensity of the light. A value larger than 1 means an artificially high amount of bounce light will be emitted.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.color">
      <summary>
        <para>The color of the light.</para>
        <para>To modify the light intensity you change light's color luminance. Lights always add illumination, so a light with a black color is the same as no light at all.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.commandBufferCount">
      <summary>Number of command buffers set up on this light (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Light.cookie">
      <summary>
        <para>The cookie texture projected by the light.</para>
        <para>If the cookie is a cube map, the light will become a <see cref="F:UnityEngine.LightType.Point" /> light. Note that cookies are only displayed for pixel lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.cookieSize">
      <summary>The size of a directional light's cookie.</summary>
    </member>
    <member name="P:UnityEngine.Light.cullingMask">
      <summary>
        <para>This is used to light certain objects in the scene selectively.</para>
        <para>A <see cref="T:UnityEngine.GameObject" /> will only be illuminated by a light if that light's <c>cullingMask/</c> includes the layer chosen for the GameObject (ie, the mask bit for the layer must be set to 1 for the object to receive any light).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.flare">
      <summary>The flare asset to use for this light.</summary>
    </member>
    <member name="P:UnityEngine.Light.intensity">
      <summary>
        <para>The Intensity of a light is multiplied with the Light color.</para>
        <para>The value can be between 0 and 8. This allows you to create over bright lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.range">
      <summary>The range of the light.</summary>
    </member>
    <member name="P:UnityEngine.Light.renderMode">
      <summary>
        <para>How to render the light.</para>
        <para>This can be LightRenderMode.Auto, LightRenderMode.ForceVertex or LightRenderMode.ForcePixel.Pixel lights render slower but look better, especially on not very highly tesselated geometry. Some effects (e.g. bumpmapping) are only displayed for pixel lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowBias">
      <summary>
        <para>Shadow mapping constant bias.</para>
        <para>Shadow caster surfaces are pushed by this world-space amount away from the light, to help prevent self-shadowing ("shadow acne") artifacts.See Also: <see cref="P:UnityEngine.Light.shadows" />, <see cref="P:UnityEngine.Light.shadowNormalBias" /> properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowNormalBias">
      <summary>
        <para>Shadow mapping normal-based bias.</para>
        <para>Shadow caster surfaces are pushed inwards along their normals by this amount, to help prevent self-shadowing ("shadow acne") artifacts. Units of normal-based bias are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well.Larger values prevent shadow acne better, at expense of making shadow shape smaller than the object actually is.Currently normal-based bias is only implemented for directional lights; it has no effect for other light types.See Also: <see cref="P:UnityEngine.Light.shadows" />, <see cref="P:UnityEngine.Light.shadowBias" /> properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadows">
      <summary>How this light casts shadows</summary>
    </member>
    <member name="P:UnityEngine.Light.shadowStrength">
      <summary>Strength of light's shadows.</summary>
    </member>
    <member name="P:UnityEngine.Light.spotAngle">
      <summary>
        <para>The angle of the light's spotlight cone in degrees.</para>
        <para>This is used primarily for <see cref="F:UnityEngine.LightType.Spot" /> lights and has no effect for <see cref="F:UnityEngine.LightType.Point" /> lights See Also: Light component.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.type">
      <summary>The type of the light.</summary>
    </member>
    <member name="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Add a command buffer to be executed at a specified place.</para>
        <para>Multiple command buffers can be set to execute at the same light event (or even the same buffer can be added multiple times). To remove command buffer from execution, use <see cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
    </member>
    <member name="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)">
      <summary>Get command buffers to be executed at a specified place.</summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <returns>Array of command buffers.</returns>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer" />
      <seealso cref="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />
    </member>
    <member name="M:UnityEngine.Light.RemoveAllCommandBuffers">
      <summary>Remove all command buffers set on this light.</summary>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer" />
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)" />
    </member>
    <member name="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Remove command buffer from execution at a specified place.</para>
        <para>If the same buffer is added multiple times on this light event, all occurrences of it will be removed.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)" />, <see cref="M:UnityEngine.Light.RemoveAllCommandBuffers" />, <see cref="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
    </member>
    <member name="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)">
      <summary>
        <para>Remove command buffers from execution at a specified place.</para>
        <para>This function removes all command buffers set on the specified light event.See Also: <see cref="T:UnityEngine.Rendering.CommandBuffer" />, <see cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)" />, <see cref="M:UnityEngine.Light.RemoveAllCommandBuffers" />.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
    </member>
    <member name="P:UnityEngine.LightmapData.lightmapFar">
      <summary>Lightmap storing the full incoming light.</summary>
    </member>
    <member name="P:UnityEngine.LightmapData.lightmapNear">
      <summary>Lightmap storing only the indirect incoming light.</summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightmaps">
      <summary>Lightmap array.</summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightmapsMode">
      <summary>
        <para>Non-directional, Directional or Directional Specular lightmaps rendering mode.</para>
        <para>You can continue reading here if you want to know what the different lightmap modes does.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightProbes">
      <summary>
        <para>Holds all data needed by the light probes.</para>
        <para>It can be swapped to a different pre-baked one at runtime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeGroup.probePositions">
      <summary>
        <para>Editor only function to access and modify probe positions.</para>
        <para>Probe positions are specified in local space relative to the parent object.At runtime this function will return an empty Vector3 array and setting it will have no effect.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbes.bakedProbes">
      <summary>Coefficients of baked light probes.</summary>
    </member>
    <member name="P:UnityEngine.LightProbes.cellCount">
      <summary>
        <para>The number of cells space is divided into (Read Only).</para>
        <para>This includes both interior cells (tetrahedra) and outer space cells.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbes.count">
      <summary>The number of light probes (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.LightProbes.positions">
      <summary>Positions of the baked light probes (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.LightProbes.GetInterpolatedProbe(UnityEngine.Vector3,UnityEngine.Renderer,UnityEngine.Rendering.SphericalHarmonicsL2@)">
      <summary>
        <para>Returns an interpolated probe for the given position for both realtime and baked light probes combined.</para>
        <para>Renderer is only needed to speed up the search for the current tetrahedron, as it caches the index of the tetrahedron it was in the last frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.useWorldSpace">
      <summary>
        <para>If enabled, the lines are defined in world space.</para>
        <para>This means the object's position is ignored, and the lines are rendered around world origin.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LineRenderer.SetColors(UnityEngine.Color,UnityEngine.Color)">
      <summary>Set the line color at the start and at the end.</summary>
    </member>
    <member name="M:UnityEngine.LineRenderer.SetPosition(System.Int32,UnityEngine.Vector3)">
      <summary>Set the position of the vertex in the line.</summary>
      <seealso cref="M:UnityEngine.LineRenderer.SetVertexCount(System.Int32)" />
    </member>
    <member name="M:UnityEngine.LineRenderer.SetVertexCount(System.Int32)">
      <summary>Set the number of line segments.</summary>
      <seealso cref="M:UnityEngine.LineRenderer.SetPosition(System.Int32,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.LineRenderer.SetWidth(System.Single,System.Single)">
      <summary>Set the line width at the start and at the end.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.altitude">
      <summary>Geographical device location altitude.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.horizontalAccuracy">
      <summary>Horizontal accuracy of the location.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.latitude">
      <summary>Geographical device location latitude.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.longitude">
      <summary>Geographical device location latitude.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.timestamp">
      <summary>Timestamp (in seconds since 1970) when location was last time updated.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.verticalAccuracy">
      <summary>Vertical accuracy of the location.</summary>
    </member>
    <member name="P:UnityEngine.LocationService.isEnabledByUser">
      <summary>
        <para>Specifies whether location service is enabled in user settings.</para>
        <para>You should check this property before starting location updates to determine if the user has location services enabled for the current device.On iOS, if this property is false and you start location updates anyway, the CoreLocation framework prompts the user with a confirmation panel asking whether location services should be reenabled. The user can enable or disable location services altogether from the Settings application by toggling the switch in Settings&gt;General&gt;LocationServices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LocationService.lastData">
      <summary>
        <para>Last measured device geographical location.</para>
        <para>Before accessing this property, make sure location service was started via <c>Input.location.Start()</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LocationService.status">
      <summary>
        <para>Returns location service status.</para>
        <para>For the details about the return value please refer to documentation of <c>LocationServiceStatus</c> enumeration.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start(System.Single,System.Single)">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start(System.Single)">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Stop">
      <summary>Stops location service updates. This could be useful for saving battery life.</summary>
    </member>
    <member name="F:UnityEngine.LOD.fadeTransitionWidth">
      <summary>Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.</summary>
    </member>
    <member name="F:UnityEngine.LOD.renderers">
      <summary>List of renderers for this LOD level.</summary>
    </member>
    <member name="F:UnityEngine.LOD.screenRelativeTransitionHeight">
      <summary>The screen relative height to use for the transition [0-1].</summary>
    </member>
    <member name="M:UnityEngine.LOD.#ctor(System.Single,UnityEngine.Renderer[])">
      <summary>Construct a LOD.</summary>
      <param name="screenRelativeTransitionHeight">The screen relative height to use for the transition [0-1].</param>
      <param name="renderers">An array of renderers to use for this LOD level.</param>
    </member>
    <member name="P:UnityEngine.LODGroup.crossFadeAnimationDuration">
      <summary>The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.animateCrossFading">
      <summary>Specify if the cross-fading should be animated by time. The animation duration is specified globally as <see cref="P:UnityEngine.LODGroup.crossFadeAnimationDuration" />.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.enabled">
      <summary>Enable / Disable the LODGroup - Disabling will turn off all renderers.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.fadeMode">
      <summary>The LOD fade mode used.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.localReferencePoint">
      <summary>The local reference point against which the LOD distance is calculated.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.lodCount">
      <summary>The number of LOD levels.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.size">
      <summary>The size of the LOD object in local space.</summary>
    </member>
    <member name="M:UnityEngine.LODGroup.GetLODs">
      <summary>Returns the array of LODs.</summary>
      <returns>The LOD array.</returns>
    </member>
    <member name="M:UnityEngine.LODGroup.RecalculateBounds">
      <summary>Recalculate the bounding region for the LODGroup (Relatively slow, do not call often).</summary>
    </member>
    <member name="M:UnityEngine.LODGroup.SetLODs(UnityEngine.LOD[])">
      <summary>Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.</summary>
      <param name="lods">The LODs to use for this group.</param>
    </member>
    <member name="P:UnityEngine.MasterServer.dedicatedServer">
      <summary>
        <para>Report this machine as a dedicated server.</para>
        <para>If running as a server the connection count defines the player count and this is reported when registering on the master server. By default the master server assumes this instance is not a dedicated server and thus the player count is incremented by one (to account for the \"client\" running on the server). If this is not desired this variable can be set to false and then only the connection count is reported in the host data as the player count.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.ipAddress">
      <summary>
        <para>The IP address of the master server.</para>
        <para>By default this is a server run by Unity Technologies.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.port">
      <summary>
        <para>The connection port of the master server.</para>
        <para>By default this is a server run by Unity Technologies.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.updateRate">
      <summary>
        <para>Set the minimum update rate for master server host information update.</para>
        <para>Normally host updates are only sent if something in the host information has changed (like connected players). The update rate defines the minimum amount of time which may elapse between host updates. The default value is 60 seconds minimum update rate (where a check is made for changes). So if one host update is sent and then some field changes 10 seconds later then the update will possibly sent 50 seconds later (at the next change check). If this is set to 0 then no updates are sent, only initial registration information.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MasterServer.ClearHostList">
      <summary>
        <para>Clear the host list which was received by MasterServer.PollHostList.</para>
        <para>Useful if you want to update the list and want to make sure you don't use the older data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MasterServer.PollHostList">
      <summary>
        <para>Check for the latest host list received by using MasterServer.RequestHostList.</para>
        <para>You can clear the current host list with MasterServer.ClearHostList. That way you can be sure that the list returned by is up to date.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MasterServer.RegisterHost(System.String,System.String,System.String)">
      <summary>
        <para>Register this server on the master server.</para>
        <para>If the master server address information has not been changed the default Unity master server will be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MasterServer.RequestHostList(System.String)">
      <summary>
        <para>Request a host list from the master server.</para>
        <para>The list is available through MasterServer.PollHostList when it has arrived.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MasterServer.UnregisterHost">
      <summary>
        <para>Unregister this server from the master server.</para>
        <para>Does nothing if the server is not registered or has already unregistered.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MatchTargetWeightMask.positionXYZWeight">
      <summary>Position XYZ weight.</summary>
    </member>
    <member name="P:UnityEngine.MatchTargetWeightMask.rotationWeight">
      <summary>Rotation weight.</summary>
    </member>
    <member name="M:UnityEngine.MatchTargetWeightMask.#ctor(UnityEngine.Vector3,System.Single)">
      <summary>MatchTargetWeightMask contructor.</summary>
      <param name="positionXYZWeight">Position XYZ weight.</param>
      <param name="rotationWeight">Rotation weight.</param>
    </member>
    <member name="P:UnityEngine.Material.color">
      <summary>
        <para>The main material's color.</para>
        <para>The same as using <see cref="M:UnityEngine.Material.GetColor(System.String)" /> or <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" /> with <c>"_Color"</c> name.See Also: <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Material.GetColor(System.String)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.globalIlluminationFlags">
      <summary>
        <para>Defines how the material should interact with lightmaps and lightprobes.</para>
        <para>A custom shader GUI will usually set these values based on user input.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTexture">
      <summary>
        <para>The material's texture.</para>
        <para>The same as using <see cref="M:UnityEngine.Material.GetTexture(System.String)" /> or <see cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)" /> with <c>"_MainTex"</c> name.See Also: <see cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)" />, <see cref="M:UnityEngine.Material.GetTexture(System.String)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTextureOffset">
      <summary>
        <para>The texture offset of the main texture.</para>
        <para>The same as using <see cref="M:UnityEngine.Material.GetTextureOffset(System.String)" /> or <see cref="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)" /> with <c>"_MainTex"</c> name.See Also: <see cref="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)" />, <see cref="M:UnityEngine.Material.GetTextureOffset(System.String)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTextureScale">
      <summary>
        <para>The texture scale of the main texture.</para>
        <para>The same as using <see cref="M:UnityEngine.Material.GetTextureScale(System.String)" /> or <see cref="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)" /> with <c>"_MainTex"</c> name.See Also: <see cref="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)" />, <see cref="M:UnityEngine.Material.GetTextureScale(System.String)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.passCount">
      <summary>
        <para>How many passes are in this material (Read Only).</para>
        <para>This is mostly used in direct drawing code using <see cref="T:UnityEngine.GL" /> class. For example, Image Effects use materials for implementing screen post-processing. For each pass in the material they activate the pass (see <see cref="M:UnityEngine.Material.SetPass(System.Int32)" /> for an example) and draw a fullscreen quad.See Also: <see cref="M:UnityEngine.Material.SetPass(System.Int32)" /> function, <see cref="T:UnityEngine.GL" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.renderQueue">
      <summary>
        <para>Render queue of this material.</para>
        <para>By default materials use render queue of the shader it uses. You can override the render queue used using this variable. Note that once render queue is set on the material, it stays at that value, even if shader is later changed to be different.Render queue number should be positive to work properly; or -1 to use the render queue from the shader.See Also: <see cref="P:UnityEngine.Shader.renderQueue" />, RenderQueue tag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.shader">
      <summary>The shader used by the material.</summary>
    </member>
    <member name="P:UnityEngine.Material.shaderKeywords">
      <summary>Additional shader keywords set by this material.</summary>
    </member>
    <member name="M:UnityEngine.Material.CopyPropertiesFromMaterial(UnityEngine.Material)">
      <summary>
        <para>Copy properties from other material into this material.</para>
        <para>This function copies property values (both serialized and set at runtime), as well as shader keywords, render queue and global illumination flags from the other material. Material's shader is not changed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.DisableKeyword(System.String)">
      <summary>
        <para>Unset a shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Material.DisableKeyword(System.String)" />), or globally set shader keywords (<see cref="M:UnityEngine.Shader.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />).See Also: <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" />, <see cref="P:UnityEngine.Material.shaderKeywords" />, Accessing Materials via Script, multiple shader program variants.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.EnableKeyword(System.String)">
      <summary>
        <para>Set a shader keyword that is enabled by this material.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Material.DisableKeyword(System.String)" />), or globally set shader keywords (<see cref="M:UnityEngine.Shader.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />).See Also: <see cref="M:UnityEngine.Material.DisableKeyword(System.String)" />, <see cref="P:UnityEngine.Material.shaderKeywords" />, Accessing Materials via Script, multiple shader program variants.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetColor(System.String)">
      <summary>
        <para>Get a named color value.</para>
        <para>Many shaders use more than one color. Use GetColor to get the <c>propertyName</c> color.Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="P:UnityEngine.Material.color" /> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/glossy/vertexlit shaders). <c>"_Emission"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).See Also: <see cref="P:UnityEngine.Material.color" /> property, <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetColor(System.Int32)">
      <summary>
        <para>Get a named color value.</para>
        <para>Many shaders use more than one color. Use GetColor to get the <c>propertyName</c> color.Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="P:UnityEngine.Material.color" /> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/glossy/vertexlit shaders). <c>"_Emission"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).See Also: <see cref="P:UnityEngine.Material.color" /> property, <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetFloat(System.String)">
      <summary>Get a named float value.</summary>
      <seealso cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)" />
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)" />
    </member>
    <member name="M:UnityEngine.Material.GetFloat(System.Int32)">
      <summary>Get a named float value.</summary>
      <seealso cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)" />
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)" />
    </member>
    <member name="M:UnityEngine.Material.GetInt(System.String)">
      <summary>
        <para>Get a named integer value.</para>
        <para>This function is just an alias to <see cref="M:UnityEngine.Material.GetFloat(System.String)" /> that casts the resulting value to an integer.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetInt(System.Int32)">
      <summary>
        <para>Get a named integer value.</para>
        <para>This function is just an alias to <see cref="M:UnityEngine.Material.GetFloat(System.String)" /> that casts the resulting value to an integer.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetMatrix(System.String)">
      <summary>
        <para>Get a named matrix value from the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.See Also: <see cref="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetMatrix(System.Int32)">
      <summary>
        <para>Get a named matrix value from the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.See Also: <see cref="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTag(System.String,System.Boolean,System.String)">
      <summary>
        <para>Get the value of material's shader tag.</para>
        <para>If the material's shader does not define the tag, <c>defaultValue</c> is returned.If <c>searchFallbacks</c> is <c>true</c> then this function will look for tag in all subshaders and all fallbacks. If <c>seachFallbacks</c> is <c>false</c> then only the currently used subshader will be queried for the tag.Using <c>GetTag</c> without searching through fallbacks makes it possible to detect which subshader is currently being used: add a custom tag to each subshader with different value, and query the value at run time. For example, Unity water uses this function to detect when the shader falls back to non-reflective one, and turns off reflection camera in that case.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTexture(System.String)">
      <summary>
        <para>Get a named texture.</para>
        <para>Many shaders use more than one texture. Use GetTexture to get the <c>propertyName</c> texture.Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTexture" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTexture" /> property, <see cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTexture(System.Int32)">
      <summary>
        <para>Get a named texture.</para>
        <para>Many shaders use more than one texture. Use GetTexture to get the <c>propertyName</c> texture.Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTexture" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTexture" /> property, <see cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTextureOffset(System.String)">
      <summary>
        <para>Gets the placement offset of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTextureOffset" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTextureOffset" /> property, <see cref="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTextureScale(System.String)">
      <summary>
        <para>Gets the placement scale of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTextureScale" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTextureScale" /> property, <see cref="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetVector(System.String)">
      <summary>
        <para>Get a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>GetVector</c> does exactly the same as <see cref="M:UnityEngine.Material.GetColor(System.String)" /> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color).See Also: <see cref="M:UnityEngine.Material.GetColor(System.String)" />, <see cref="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetVector(System.Int32)">
      <summary>
        <para>Get a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>GetVector</c> does exactly the same as <see cref="M:UnityEngine.Material.GetColor(System.String)" /> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color).See Also: <see cref="M:UnityEngine.Material.GetColor(System.String)" />, <see cref="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.HasProperty(System.String)">
      <summary>Checks if material's shader has a property of a given name.</summary>
    </member>
    <member name="M:UnityEngine.Material.HasProperty(System.Int32)">
      <summary>Checks if material's shader has a property of a given name.</summary>
    </member>
    <member name="M:UnityEngine.Material.IsKeywordEnabled(System.String)">
      <summary>Is the shader keyword enabled on this material?</summary>
      <seealso cref="M:UnityEngine.Material.EnableKeyword(System.String)" />
      <seealso cref="M:UnityEngine.Material.DisableKeyword(System.String)" />
    </member>
    <member name="M:UnityEngine.Material.Lerp(UnityEngine.Material,UnityEngine.Material,System.Single)">
      <summary>
        <para>Interpolate properties between two materials.</para>
        <para>Makes all color and float values of a material be interpolated from <c>start</c> to <c>end</c>, based on <c>t</c>. When <c>t</c> is 0, all values are taken from <c>start</c>. When <c>t</c> is 1, all values are taken from <c>end</c>.Most often you want the materials that are interpolated between to be the same (use the same shaders and textures) except for colors and floats. Then you use <c>Lerp</c> to blend between them.See Also: Materials.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>Set a <see cref="T:UnityEngine.ComputeBuffer" /> value.</summary>
    </member>
    <member name="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Set a named color value.</para>
        <para>Many shaders use more than one color. Use SetColor to change the <c>propertyName</c> color.When setting color values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="P:UnityEngine.Material.color" /> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/vertexlit shaders). <c>"_Emission"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).See Also: <see cref="P:UnityEngine.Material.color" />, <see cref="M:UnityEngine.Material.GetColor(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Set a named color value.</para>
        <para>Many shaders use more than one color. Use SetColor to change the <c>propertyName</c> color.When setting color values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="P:UnityEngine.Material.color" /> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/vertexlit shaders). <c>"_Emission"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).See Also: <see cref="P:UnityEngine.Material.color" />, <see cref="M:UnityEngine.Material.GetColor(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetFloat(System.String,System.Single)">
      <summary>
        <para>Set a named float value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.See Also: <see cref="M:UnityEngine.Material.GetFloat(System.String)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Set a named float value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.See Also: <see cref="M:UnityEngine.Material.GetFloat(System.String)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetInt(System.String,System.Int32)">
      <summary>
        <para>Set a named integer value.When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.</para>
        <para>This function is just an alias to <see cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)" /> that casts the passed value to a float.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetInt(System.Int32,System.Int32)">
      <summary>
        <para>Set a named integer value.When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.</para>
        <para>This function is just an alias to <see cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)" /> that casts the passed value to a float.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a named matrix for the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.See Also: <see cref="M:UnityEngine.Material.GetMatrix(System.String)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a named matrix for the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.See Also: <see cref="M:UnityEngine.Material.GetMatrix(System.String)" />, Materials, ShaderLab documentation, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetOverrideTag(System.String,System.String)">
      <summary>
        <para>Sets an override tag/value on the material.</para>
        <para>Will set a tag/value on the material that overrides the value of said tag from the shader. This can be used to make sure replacement shaders (such as rendering DepthNormals) work even if the original shader only supports a certain render type. For example if a shader only supports a specific render type but renders in many ways using keywords, SetOverrideTag can be used fom a custom material inspector to ensure that the material renders correctly even if the shader is replaced.</para>
      </summary>
      <param name="tag">Name of the tag to set.</param>
      <param name="val">Name of the value to set. Empty string to clear the override flag.</param>
    </member>
    <member name="M:UnityEngine.Material.SetPass(System.Int32)">
      <summary>
        <para>Activate the given <c>pass</c> for rendering.</para>
        <para>Pass indices start from zero and go up to (but not including) <see cref="P:UnityEngine.Material.passCount" />.This is mostly used in direct drawing code using <see cref="T:UnityEngine.GL" /> class. For example, Image Effects use materials for implementing screen post-processing. For each pass in the material they activate the pass and draw a fullscreen quad.If SetPass returns false, you should not render anything. This is typically the case for special pass types that aren't meant for rendering, like GrabPass.</para>
      </summary>
      <param name="pass">Shader pass number to setup.</param>
      <returns>If false is returned, no rendering should be done.</returns>
      <seealso cref="P:UnityEngine.Material.passCount" />
      <seealso cref="T:UnityEngine.GL" />
    </member>
    <member name="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Set a named texture.</para>
        <para>Many shaders use more than one texture. Use SetTexture to change the <c>propertyName</c> texture.When setting textures on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTexture" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTexture" /> property, <see cref="M:UnityEngine.Material.GetTexture(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Set a named texture.</para>
        <para>Many shaders use more than one texture. Use SetTexture to change the <c>propertyName</c> texture.When setting textures on materials using the Standard Shader, you should be aware that you may need to use <see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTexture" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTexture" /> property, <see cref="M:UnityEngine.Material.GetTexture(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)">
      <summary>
        <para>Sets the placement offset of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTextureOffset" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTextureOffset" /> property, <see cref="M:UnityEngine.Material.GetTextureOffset(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)">
      <summary>
        <para>Sets the placement scale of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="P:UnityEngine.Material.mainTextureScale" /> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.See Also: <see cref="P:UnityEngine.Material.mainTextureScale" /> property, <see cref="M:UnityEngine.Material.GetTextureScale(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>SetVector</c> does exactly the same as <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" /> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color).See Also: <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Material.GetVector(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Set a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>SetVector</c> does exactly the same as <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" /> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color).See Also: <see cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Material.GetVector(System.String)" />, <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MaterialPropertyBlock.isEmpty">
      <summary>Is the material property block empty? (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Add a color material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddColor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Add a color material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddColor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddFloat(System.String,System.Single)">
      <summary>
        <para>Add a float material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddFloat.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddFloat(System.Int32,System.Single)">
      <summary>
        <para>Add a float material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddFloat.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a matrix material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a matrix material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Add a texture material property.</para>
        <para>Note that texture properties in the MaterialPropertyBlock will not work with fixed-function shaders.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Add a texture material property.</para>
        <para>Note that texture properties in the MaterialPropertyBlock will not work with fixed-function shaders.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Add a vector material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddVector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.AddVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Add a vector material property.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are adding properties with the same name repeatedly, use Shader.PropertyToID to get unique identifier for the name, and pass the identifier to AddVector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.Clear">
      <summary>
        <para>Clear material property values.</para>
        <para>Graphics.DrawMesh copies the passed property block, so the most efficient way of using it is to create one block and reuse it for all DrawMesh calls. Use <see cref="M:UnityEngine.MaterialPropertyBlock.Clear" /> to clear block's values, and <see cref="M:UnityEngine.MaterialPropertyBlock.AddFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.AddVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.AddColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.AddMatrix(System.String,UnityEngine.Matrix4x4)" /> to add values.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloat(System.String)">
      <summary>
        <para>Get a float from the property block.</para>
        <para>Returns zero if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloat(System.Int32)">
      <summary>
        <para>Get a float from the property block.</para>
        <para>Returns zero if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrix(System.String)">
      <summary>
        <para>Get a matrix from the property block.</para>
        <para>Returns identity matrix if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrix(System.Int32)">
      <summary>
        <para>Get a matrix from the property block.</para>
        <para>Returns identity matrix if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetTexture(System.String)">
      <summary>
        <para>Get a texture from the property block.</para>
        <para>Returns null if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetTexture(System.Int32)">
      <summary>
        <para>Get a texture from the property block.</para>
        <para>Returns null if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVector(System.String)">
      <summary>
        <para>Get a vector from the property block.</para>
        <para>Returns zero vector if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVector(System.Int32)">
      <summary>
        <para>Get a vector from the property block.</para>
        <para>Returns zero vector if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Set a color property.</para>
        <para>Adds a property to the block. If a color property with the given name already exists, the old value is replaced.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are changing properties with the same name repeatedly, use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to get unique identifier for the name, and pass the identifier to SetColor.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Set a color property.</para>
        <para>Adds a property to the block. If a color property with the given name already exists, the old value is replaced.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are changing properties with the same name repeatedly, use <see cref="M:UnityEngine.Shader.PropertyToID(System.String)" /> to get unique identifier for the name, and pass the identifier to SetColor.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      <summary>
        <para>Set a float property.</para>
        <para>Adds a property to the block. If a float property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Set a float property.</para>
        <para>Adds a property to the block. If a float property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a matrix property.</para>
        <para>Adds a property to the block. If a matrix property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a matrix property.</para>
        <para>Adds a property to the block. If a matrix property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Set a texture property.</para>
        <para>Adds a property to the block. If a texture property with the given name already exists, the old value is replaced.Note that texture properties in the MaterialPropertyBlock will not work with fixed-function shaders.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Set a texture property.</para>
        <para>Adds a property to the block. If a texture property with the given name already exists, the old value is replaced.Note that texture properties in the MaterialPropertyBlock will not work with fixed-function shaders.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector property.</para>
        <para>Adds a property to the block. If a vector property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector property.</para>
        <para>Adds a property to the block. If a vector property with the given name already exists, the old value is replaced.See Also: <see cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Deg2Rad">
      <summary>
        <para>Degrees-to-radians conversion constant (Read Only).</para>
        <para>This is equal to <c>(PI * 2) / 360</c>.See Also: <see cref="F:UnityEngine.Mathf.Rad2Deg" /> constant.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Epsilon">
      <summary>
        <para>A tiny floating point value (Read Only).</para>
        <para>The smallest value that a float can have different from zero.With the following rules: - anyValue + Epsilon = anyValue - anyValue - Epsilon = anyValue - 0 + Epsilon = Epsilon - 0 - Epsilon = -EpsilonA value Between any number and Epsilon will result in an arbitrary number due to truncating errors.See Also: Mathf.Approximately.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Infinity">
      <summary>A representation of positive infinity (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.Mathf.NegativeInfinity">
      <summary>A representation of negative infinity (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.Mathf.PI">
      <summary>The infamous <c>3.14159265358979...</c> value (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.Mathf.Rad2Deg">
      <summary>
        <para>Radians-to-degrees conversion constant (Read Only).</para>
        <para>This is equal to <c>360 / (PI * 2)</c>.See Also: <see cref="F:UnityEngine.Mathf.Deg2Rad" /> constant.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Abs(System.Single)">
      <summary>Returns the absolute value of <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Abs(System.Int32)">
      <summary>Returns the absolute value of <c>value</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Acos(System.Single)">
      <summary>Returns the arc-cosine of <c>f</c> - the angle in radians whose cosine is <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Approximately(System.Single,System.Single)">
      <summary>
        <para>Compares two floating point values if they are similar.</para>
        <para>Due to floating point imprecision it is not recommended to compare floats using the equal operator. eg. 1.0 == 10.0 / 10.0 might not return true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Asin(System.Single)">
      <summary>Returns the arc-sine of <c>f</c> - the angle in radians whose sine is <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Atan(System.Single)">
      <summary>Returns the arc-tangent of <c>f</c> - the angle in radians whose tangent is <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Atan2(System.Single,System.Single)">
      <summary>
        <para>Returns the angle in radians whose <see cref="M:UnityEngine.Mathf.Tan(System.Single)" /> is <c>y/x</c>.</para>
        <para>Return value is the angle between the x-axis and a 2D vector starting at zero and terminating at (x,y).Note that this function takes account of the cases where x is zero and returns the correct angle rather than throwing a division by zero exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Ceil(System.Single)">
      <summary>Returns the smallest integer greater to or equal to <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.CeilToInt(System.Single)">
      <summary>Returns the smallest integer greater to or equal to <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp(System.Single,System.Single,System.Single)">
      <summary>Clamps a value between a minimum float and maximum float value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp(System.Int32,System.Int32,System.Int32)">
      <summary>Clamps value between min and max and returns value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp01(System.Single)">
      <summary>Clamps value between 0 and 1 and returns value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.ClosestPowerOfTwo(System.Int32)">
      <summary>Returns the closest power of two value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Cos(System.Single)">
      <summary>Returns the cosine of angle <c>f</c> in radians.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.DeltaAngle(System.Single,System.Single)">
      <summary>Calculates the shortest difference between two given angles given in degrees.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Exp(System.Single)">
      <summary>Returns e raised to the specified power.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Floor(System.Single)">
      <summary>Returns the largest integer smaller to or equal to <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.FloorToInt(System.Single)">
      <summary>Returns the largest integer smaller to or equal to <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.GammaToLinearSpace(System.Single)">
      <summary>Converts the given value from gamma to linear color space.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.InverseLerp(System.Single,System.Single,System.Single)">
      <summary>Calculates the linear parameter t that produces the interpolant <c>value</c> within the range [a, b].</summary>
      <seealso cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)" />
    </member>
    <member name="M:UnityEngine.Mathf.IsPowerOfTwo(System.Int32)">
      <summary>Returns true if the value is power of two.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)">
      <summary>
        <para>Linearly interpolates between <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1].When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)" />
      <seealso cref="M:UnityEngine.Mathf.LerpAngle(System.Single,System.Single,System.Single)" />
    </member>
    <member name="M:UnityEngine.Mathf.LerpAngle(System.Single,System.Single,System.Single)">
      <summary>
        <para>Same as <see cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)" /> but makes sure the values interpolate correctly when they wrap around 360 degrees.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1]. Variables <c>a</c> and <c>b</c> are assumed to be in degrees.</para>
      </summary>
      <seealso cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)" />
    </member>
    <member name="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)">
      <summary>
        <para>Linearly interpolates between <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>The parameter <c>t</c> is not clamped and values outside the range [0, 1] will result in a return value outside the range [<c>a</c>, <c>b</c>].When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.LinearToGammaSpace(System.Single)">
      <summary>Converts the given value from linear to gamma color space.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log(System.Single,System.Single)">
      <summary>Returns the logarithm of a specified number in a specified base.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log(System.Single)">
      <summary>Returns the natural (base e) logarithm of a specified number.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log10(System.Single)">
      <summary>Returns the base 10 logarithm of a specified number.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Single,System.Single)">
      <summary>Returns largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Single[])">
      <summary>Returns largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Int32,System.Int32)">
      <summary>Returns the largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Int32[])">
      <summary>Returns the largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Single,System.Single)">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Single[])">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Int32,System.Int32)">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Int32[])">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.MoveTowards(System.Single,System.Single,System.Single)">
      <summary>
        <para>Moves a value <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds <c>maxDelta</c>. Negative values of <c>maxDelta</c> pushes the value away from <c>target</c>.</para>
      </summary>
      <param name="current">The current value.</param>
      <param name="target">The value to move towards.</param>
      <param name="maxDelta">The maximum change that should be applied to the value.</param>
    </member>
    <member name="M:UnityEngine.Mathf.MoveTowardsAngle(System.Single,System.Single,System.Single)">
      <summary>
        <para>Same as <see cref="M:UnityEngine.Mathf.MoveTowards(System.Single,System.Single,System.Single)" /> but makes sure the values interpolate correctly when they wrap around 360 degrees.</para>
        <para>Variables <c>current</c> and <c>target</c> are assumed to be in degrees. For optimization reasons, negative values of <c>maxDelta</c> are not supported and may cause oscillation. To push <c>current</c> away from a target angle, add 180 to that angle instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.NextPowerOfTwo(System.Int32)">
      <summary>Returns the next power of two value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.PerlinNoise(System.Single,System.Single)">
      <summary>
        <para>Generate 2D Perlin noise.</para>
        <para>Perlin noise is a pseudo-random pattern of float values generated across a 2D plane (although the technique does generalise to three or more dimensions, this is not implemented in Unity). The noise does not contain a completely random value at each point but rather consists of "waves" whose values gradually increase and decrease across the pattern. The noise can be used as the basis for texture effects but also for animation, generating terrain heightmaps and many other things.<c>Perlin noise sampled in the range 0..10 (the greyscale values represent values from 0..1)</c>Any point in the plane can be sampled by passing the appropriate X and Y coordinates. The same coordinates will always return the same sample value but the plane is essentially infinite so it is easy to avoid repetition by choosing a random area to sample from.</para>
        <para>Although the noise plane is two-dimensional, it is easy to use just a single one-dimensional line through the pattern, say for animation effects.</para>
        <para>Note: It is possible for the return value to slightly exceed 1.0f. You may need to clamp the return value if the 0.0 to 1.0 range is important to you.</para>
      </summary>
      <param name="x">X-coordinate of sample point.</param>
      <param name="y">Y-coordinate of sample point.</param>
      <returns>Value between 0.0 and 1.0.</returns>
    </member>
    <member name="M:UnityEngine.Mathf.PingPong(System.Single,System.Single)">
      <summary>
        <para>PingPongs the value t, so that it is never larger than length and never smaller than 0.</para>
        <para>The returned value will move back and forth between 0 and <c>length</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Pow(System.Single,System.Single)">
      <summary>Returns <c>f</c> raised to power <c>p</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Repeat(System.Single,System.Single)">
      <summary>
        <para>Loops the value t, so that it is never larger than length and never smaller than 0.</para>
        <para>This is similar to the modulo operator but it works with floating point numbers. For example, using 3.0 for <c>t</c> and 2.5 for <c>length</c>, the result would be 0.5. With <c>t</c> = 5 and <c>length</c> = 2.5, the result would be 0.0. Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Round(System.Single)">
      <summary>
        <para>Returns <c>f</c> rounded to the nearest integer.</para>
        <para>If the number ends in .5 so it is halfway between two integers, one of which is even and the other odd, the even number is returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.RoundToInt(System.Single)">
      <summary>
        <para>Returns <c>f</c> rounded to the nearest integer.</para>
        <para>If the number ends in .5 so it is halfway between two integers, one of which is even and the other odd, the even number is returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sign(System.Single)">
      <summary>
        <para>Returns the sign of <c>f</c>.</para>
        <para>Return value is 1 when <c>f</c> is positive or zero, -1 when <c>f</c> is negative.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sin(System.Single)">
      <summary>Returns the sine of angle <c>f</c> in radians.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothStep(System.Single,System.Single,System.Single)">
      <summary>
        <para>Interpolates between <c>min</c> and <c>max</c> with smoothing at the limits.</para>
        <para>This function interpolates between <c>min</c> and <c>max</c> in a similar way to <see cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)" />. However, the interpolation will gradually speed up from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sqrt(System.Single)">
      <summary>Returns square root of <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Tan(System.Single)">
      <summary>Returns the tangent of angle <c>f</c> in radians.</summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.identity">
      <summary>
        <para>Returns the identity matrix (Read Only).</para>
        <para>This is a matrix that effectively does nothing when applied. It has 1s in the main diagonal and 0s in all other elements:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.zero">
      <summary>
        <para>Returns a matrix with all elements set to zero (Read Only).</para>
        <para>The matrix looks like this:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.inverse">
      <summary>
        <para>The inverse of this matrix (Read Only).</para>
        <para>Inverted matrix is such that if multiplied by the original would result in <see cref="P:UnityEngine.Matrix4x4.identity" /> matrix.If some matrix transforms vectors in a particular way, then the inverse matrix can transform them back. For example, Transform's <see cref="P:UnityEngine.Transform.worldToLocalMatrix" /> and <see cref="P:UnityEngine.Transform.localToWorldMatrix" /> are inverses of each other.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.isIdentity">
      <summary>Is this the identity matrix?</summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.transpose">
      <summary>
        <para>Returns the transpose of this matrix (Read Only).</para>
        <para>The transposed matrix is the one that has columns exchanged with rows of the original (i.e. flipped along main diagonal). So, if the original matrix looks like.</para>
        <para>...the transposed matrix will be.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.GetColumn(System.Int32)">
      <summary>
        <para>Get a column of the matrix.</para>
        <para>The i-th column is returned as a <see cref="T:UnityEngine.Vector4" />. <c>i</c> must be from 0 to 3 inclusive.See Also: <see cref="M:UnityEngine.Matrix4x4.SetColumn(System.Int32,UnityEngine.Vector4)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.GetRow(System.Int32)">
      <summary>
        <para>Returns a row of the matrix.</para>
        <para>The i-th row is returned as a <see cref="T:UnityEngine.Vector4" />. <c>i</c> must be from 0 to 3 inclusive.See Also: <see cref="M:UnityEngine.Matrix4x4.SetRow(System.Int32,UnityEngine.Vector4)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a position by this matrix (generic).</para>
        <para>Returns a position <c>v</c> transformed by the current fully arbitrary matrix. If the matrix is a regular 3D transformation matrix, it is much faster to use <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)" /> instead. <c>MultiplyPoint</c> is slower, but can handle projective transformations as well.See Also: <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)" />, <see cref="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a position by this matrix (fast).</para>
        <para>Returns a position <c>v</c> transformed by the current transformation matrix. This function is a faster version of <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)" />; but it can only handle regular 3D transformations. <c>MultiplyPoint</c> is slower, but can handle projective transformations as well.See Also: <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)" />, <see cref="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a direction by this matrix.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)" />; but it transforms directions and not positions. When transforming a direction, only the rotation part of the matrix is taken into account.See Also: <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)" />, <see cref="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetColumn(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a column of the matrix.</para>
        <para>You use this to build transformation matrices using right, up and forward vectors:</para>
        <para>The i-th column is set from <c>v</c>. <c>i</c> must be from 0 to 3 inclusive.See Also: <see cref="M:UnityEngine.Matrix4x4.GetColumn(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetRow(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a row of the matrix.</para>
        <para>The i-th row is set from <c>v</c>. <c>i</c> must be from 0 to 3 inclusive.See Also: <see cref="M:UnityEngine.Matrix4x4.GetRow(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>
        <para>Sets this matrix to a translation, rotation and scaling matrix.</para>
        <para>The current matrix is modified so that places things at position <c>pos</c>, oriented in rotation <c>q</c> and scaled by <c>s</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.ToString">
      <summary>Returns a nicely formatted string for this matrix.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.ToString(System.String)">
      <summary>Returns a nicely formatted string for this matrix.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Ortho(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Creates an orthogonal projection matrix.</para>
        <para>The returned matrix is such that views <c>left</c> to <c>right</c>, <c>bottom</c> to <c>top</c> area, with <c>zNear</c> and <c>zFar</c> depth clipping planes.If you want to use orthogonal for pixel-correct rendering, it is better to use <see cref="M:UnityEngine.GL.LoadPixelMatrix" />, as that would apply proper half-texel offsets for Direct3D renderer.See Also: <see cref="M:UnityEngine.GL.LoadPixelMatrix" />, <see cref="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)" />, <see cref="P:UnityEngine.GUI.matrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Perspective(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Creates a perspective projection matrix.</para>
        <para>
          <c>fov</c> is the vertical field-of-view in degrees of the perspective matrix, <c>aspect</c> is the aspect ratio (width divided by height). <c>zNear</c> and <c>zFar</c> set up the depth clipping planes.See Also: <see cref="M:UnityEngine.GL.LoadPixelMatrix" />, <see cref="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)" />, <see cref="P:UnityEngine.GUI.matrix" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      <summary>
        <para>Creates a scaling matrix.</para>
        <para>Returned matrix is such that scales along coordinate axes by a vector <c>v</c>. The matrix looks like this:</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>
        <para>Creates a translation, rotation and scaling matrix.</para>
        <para>The returned matrix is such that places things at position <c>pos</c>, oriented in rotation <c>q</c> and scaled by <c>s</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.operator *(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
      <summary>
        <para>Multiplies two matrices.</para>
        <para>The returned result is <c>lhs</c> * <c>rhs</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.operator *(UnityEngine.Matrix4x4,UnityEngine.Vector4)">
      <summary>Transforms a <see cref="T:UnityEngine.Vector4" /> by a matrix.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.bindposes">
      <summary>
        <para>The bind poses. The bind pose at each index refers to the bone with the same index.</para>
        <para>The bind pose is the inverse of inverse transformation matrix of the bone, when the bone is in the bind pose.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.blendShapeCount">
      <summary>Returns BlendShape count on this mesh.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.boneWeights">
      <summary>
        <para>The bone weights of each vertex.</para>
        <para>The size of the array is either the same as vertexCount or empty.Each vertex can be affected by up to 4 different bones. All 4 bone weights should sum up to 1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.bounds">
      <summary>
        <para>The bounding volume of the mesh.</para>
        <para>This is the axis-aligned bounding box of the mesh in its local space (that is, not affected by the transform). Note that the <see cref="P:UnityEngine.Renderer.bounds" /> property is similar but returns the bounds in world space.See Also: <see cref="T:UnityEngine.Bounds" /> class, <see cref="P:UnityEngine.Renderer.bounds" /></para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.colors">
      <summary>
        <para>Vertex colors of the mesh.</para>
        <para>If no vertex colors are available an empty array will be returned.</para>
        <para>For performance reasons, consider using <see cref="P:UnityEngine.Mesh.colors32" /> instead. This will avoid byte-to-float conversions in colors, as well as use less temporary memory.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.colors32">
      <summary>
        <para>Vertex colors of the mesh.</para>
        <para>Same as <see cref="P:UnityEngine.Mesh.colors" />, except using <see cref="T:UnityEngine.Color32" /> structure which is better for performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.isReadable">
      <summary>
        <para>Returns state of the Read/Write Enabled checkbox when model was imported.</para>
        <para>For a dynamic Mesh created from script, always returns true.Meshes not marked readable will throw an error on accessing any data arrays from script at runtime. Access is allowed in Unity's editor outside of the game and rendering loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.normals">
      <summary>
        <para>The normals of the mesh.</para>
        <para>If the mesh contains no normals an empty array will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.subMeshCount">
      <summary>The number of submeshes. Every material has a separate triangle list.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.tangents">
      <summary>
        <para>The tangents of the mesh.</para>
        <para>Tangents are mostly used in bump-mapped shaders. A tangent is a unit length vector that follows mesh surface along horizontal (U) texture direction. Tangents in Unity are represented as <see cref="T:UnityEngine.Vector4" />, with <c>x,y,z</c> components defining the vector, and <c>w</c> used to flip the binormal if needed.Unity calculates the other surface vector (binormal) by taking a cross product between normal and tangent, and multiplying result by tangent.w. Thus <c>w</c> should always be 1 or -1.You should calculate tangents yourself if you plan to use bump-mapped shaders on the mesh. Assign tangents after assigning <see cref="P:UnityEngine.Mesh.normals" /> or using <see cref="M:UnityEngine.Mesh.RecalculateNormals" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.triangles">
      <summary>
        <para>An array containing all triangles in the mesh.</para>
        <para>The array is a list of triangles that contains indices into the vertex array. The size of the triangle array must always be a multiple of 3. Vertices can be shared by simply indexing into the same vertex. If the mesh contains multiple sub meshes (materials) the triangle list will contain all triangles of all submeshes. When you assign triangle array, <see cref="P:UnityEngine.Mesh.subMeshCount" /> is set to 1. If you want to have multiple sub meshes, use <see cref="P:UnityEngine.Mesh.subMeshCount" /> and <see cref="M:UnityEngine.Mesh.SetTriangles(System.Int32)" />.It is recommended to assign a the triangle array after assigning the vertex array in order to avoid out of bounds errors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv">
      <summary>The base texture coordinates of the mesh.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv2">
      <summary>The second texture coordinate set of the mesh, if present.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv3">
      <summary>The third texture coordinate set of the mesh, if present.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv4">
      <summary>The fourth texture coordinate set of the mesh, if present.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.vertexCount">
      <summary>Returns the number of vertices in the mesh (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Mesh.vertices">
      <summary>
        <para>Returns a copy of the vertex positions or assigns a new vertex positions array.</para>
        <para>The number of vertices in the mesh is changed by assigning a vertex array with a different number of vertices. Note that if you resize the vertex array then all other vertex attributes (normals, colors, tangents, UVs) will be automatically resized too. RecalculateBounds will automatically be invoked if no vertices have been assigned to the mesh when setting the vertices.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.#ctor">
      <summary>Creates an empty mesh.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.Clear(System.Boolean)">
      <summary>
        <para>Clears all vertex data and all triangle indices.</para>
        <para>You should call this function before rebuilding <see cref="P:UnityEngine.Mesh.triangles" /> array.</para>
        <para>Default behaviour of this function keeps the existing vertex layout: if the mesh had tangent vectors and vertex colors, for example, then the tangents and colors will be part of mesh data once you fill in new vertex data. If you want to completely clear the mesh and start with an empty vertex layout, pass false for <c>keepVertexLayout</c> parameter. Alternatively, assigning an empty array to any mesh component will also remove it from the vertex layout.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.Clear">
      <summary>
        <para>Clears all vertex data and all triangle indices.</para>
        <para>You should call this function before rebuilding <see cref="P:UnityEngine.Mesh.triangles" /> array.</para>
        <para>Default behaviour of this function keeps the existing vertex layout: if the mesh had tangent vectors and vertex colors, for example, then the tangents and colors will be part of mesh data once you fill in new vertex data. If you want to completely clear the mesh and start with an empty vertex layout, pass false for <c>keepVertexLayout</c> parameter. Alternatively, assigning an empty array to any mesh component will also remove it from the vertex layout.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean,System.Boolean)">
      <summary>
        <para>Combines several meshes into this mesh.</para>
        <para>Combining meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the meshes will be combined to a single submesh. Otherwise each mesh will go into a different submesh. If all meshes share the same material, set this to true. If <c>useMatrices</c> is false, the transform matrices in <see cref="T:UnityEngine.CombineInstance" /> structs will be ignored.</para>
      </summary>
      <param name="combine">Descriptions of the meshes to combine.</param>
      <param name="mergeSubMeshes">Should all meshes be combined into a single submesh?</param>
      <param name="useMatrices">Should the transforms supplied in the CombineInstance array be used or ignored?</param>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean)">
      <summary>
        <para>Combines several meshes into this mesh.</para>
        <para>Combining meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the meshes will be combined to a single submesh. Otherwise each mesh will go into a different submesh. If all meshes share the same material, set this to true. If <c>useMatrices</c> is false, the transform matrices in <see cref="T:UnityEngine.CombineInstance" /> structs will be ignored.</para>
      </summary>
      <param name="combine">Descriptions of the meshes to combine.</param>
      <param name="mergeSubMeshes">Should all meshes be combined into a single submesh?</param>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[])">
      <summary>
        <para>Combines several meshes into this mesh.</para>
        <para>Combining meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the meshes will be combined to a single submesh. Otherwise each mesh will go into a different submesh. If all meshes share the same material, set this to true. If <c>useMatrices</c> is false, the transform matrices in <see cref="T:UnityEngine.CombineInstance" /> structs will be ignored.</para>
      </summary>
      <param name="combine">Descriptions of the meshes to combine.</param>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeName(System.Int32)">
      <summary>Returns name of BlendShape by given index.</summary>
      <seealso cref="P:UnityEngine.Mesh.blendShapeCount" />
    </member>
    <member name="M:UnityEngine.Mesh.GetIndices(System.Int32)">
      <summary>
        <para>Returns the index buffer for the submesh.</para>
        <para>The layout of indices depends on the topology of a submesh, for example for triangular mesh each triangle will result in three indices.See Also: <see cref="P:UnityEngine.Mesh.subMeshCount" />, <see cref="M:UnityEngine.Mesh.GetTopology(System.Int32)" />, <see cref="T:UnityEngine.MeshTopology" /> enum.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.GetTopology(System.Int32)">
      <summary>Gets the topology of a submesh.</summary>
      <seealso cref="T:UnityEngine.MeshTopology" />
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32)" />
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32)">
      <summary>
        <para>Returns the triangle list for the submesh.</para>
        <para>A submesh is simply a separate triangle list. When the mesh renderer uses multiple materials, you should ensure that there are as many submeshes as materials.See Also: <see cref="P:UnityEngine.Mesh.subMeshCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.MarkDynamic">
      <summary>
        <para>Optimize mesh for frequent updates.</para>
        <para>Call this before assigning vertices to get better performance when continually updating mesh. Internally this will make the mesh use "dynamic buffers" in the underlying graphics API, which are more efficient when mesh data changes often.See Also: <see cref="P:UnityEngine.Mesh.vertices" />, <see cref="P:UnityEngine.Mesh.normals" />, <see cref="P:UnityEngine.Mesh.triangles" />, <see cref="M:UnityEngine.Mesh.UploadMeshData(System.Boolean)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.Optimize">
      <summary>
        <para>Optimizes the mesh for display.</para>
        <para>This operation might take a while but will make the geometry displayed be faster. You should use it if you generate a mesh from scratch procedurally and you want to trade better runtime performance against higher load time. Internally it optimizes the triangles for vertex cache locality. For imported models you should never call this as the import pipeline already does it for you.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.RecalculateBounds">
      <summary>
        <para>Recalculate the bounding volume of the mesh from the vertices.</para>
        <para>After modifying vertices you should call this function to ensure the bounding volume is correct. Assigning <see cref="P:UnityEngine.Mesh.triangles" /> will automatically Recalculate the bounding volume.</para>
        <para>Note: The bounds of a <see cref="T:UnityEngine.SkinnedMeshRenderer" /> can only be changed by setting the <see cref="P:UnityEngine.SkinnedMeshRenderer.localBounds" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.RecalculateNormals">
      <summary>
        <para>Recalculates the normals of the mesh from the triangles and vertices.</para>
        <para>After modifying the vertices it is often useful to update the normals to reflect the change. Normals are calculated from all shared vertices. Imported meshes sometimes don't share all vertices. For example a vertex at a uv seam will be split into two vertices. Thus the RecalculateNormals function will create normals that are not smooth at the uv seam. Also note that RecalculateNormals does not generate tangents automatically thus bumpmap shaders will not work with the mesh after calling RecalculateNormals. You can provide your own tangents however.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetColors">
      <summary>Vertex colors of the mesh.</summary>
      <seealso cref="P:UnityEngine.Mesh.colors" />
      <seealso cref="P:UnityEngine.Mesh.colors32" />
    </member>
    <member name="M:UnityEngine.Mesh.SetColors">
      <summary>Vertex colors of the mesh.</summary>
      <seealso cref="P:UnityEngine.Mesh.colors" />
      <seealso cref="P:UnityEngine.Mesh.colors32" />
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Sets the index buffer for the submesh.</para>
        <para>A submesh is simply a separate indices array. When the mesh renderer uses multiple materials, you should ensure that there are as many submeshes as materials.<see cref="M:UnityEngine.Mesh.SetTriangles(System.Int32)" /> and ::triangles always make the mesh be composed of triangles faces. Using SetIndices you can create a mesh that's made out of lines or points, see <see cref="T:UnityEngine.MeshTopology" /> enum.See Also: <see cref="P:UnityEngine.Mesh.subMeshCount" />, <see cref="T:UnityEngine.MeshTopology" /> enum.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetNormals">
      <summary>Set the normals of the mesh.</summary>
      <seealso cref="P:UnityEngine.Mesh.normals" />
    </member>
    <member name="M:UnityEngine.Mesh.SetTangents">
      <summary>Set the tangents of the mesh.</summary>
      <seealso cref="P:UnityEngine.Mesh.tangents" />
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32)">
      <summary>
        <para>Sets the triangle list for the submesh.</para>
        <para>A submesh is simply a separate triangle list. When the mesh renderer uses multiple materials, you should ensure that there are as many submeshes as materials.It is recommended to assign a the triangle array after assigning the vertex array in order to avoid out of bounds errors.See Also: <see cref="P:UnityEngine.Mesh.subMeshCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32[],System.Int32)">
      <summary>
        <para>Sets the triangle list for the submesh.</para>
        <para>A submesh is simply a separate triangle list. When the mesh renderer uses multiple materials, you should ensure that there are as many submeshes as materials.It is recommended to assign a the triangle array after assigning the vertex array in order to avoid out of bounds errors.See Also: <see cref="P:UnityEngine.Mesh.subMeshCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetUVs(System.Int32)">
      <summary>
        <para>Set the UV's for a given chanel.</para>
        <para>Sets the UV's for a channel. Can either be Vector2, Vector3, or Vector4 list.</para>
      </summary>
      <param name="channel">The UV Channel (0 Indexed).</param>
    </member>
    <member name="M:UnityEngine.Mesh.SetUVs(System.Int32)">
      <summary>
        <para>Set the UV's for a given chanel.</para>
        <para>Sets the UV's for a channel. Can either be Vector2, Vector3, or Vector4 list.</para>
      </summary>
      <param name="channel">The UV Channel (0 Indexed).</param>
    </member>
    <member name="M:UnityEngine.Mesh.SetUVs(System.Int32)">
      <summary>
        <para>Set the UV's for a given chanel.</para>
        <para>Sets the UV's for a channel. Can either be Vector2, Vector3, or Vector4 list.</para>
      </summary>
      <param name="channel">The UV Channel (0 Indexed).</param>
    </member>
    <member name="M:UnityEngine.Mesh.SetVertices">
      <summary>Assigns a new vertex positions array.</summary>
      <seealso cref="P:UnityEngine.Mesh.vertices" />
    </member>
    <member name="M:UnityEngine.Mesh.UploadMeshData(System.Boolean)">
      <summary>
        <para>Upload previously done mesh modifications to the graphics API.</para>
        <para>When creating or modifying a mesh from code (using <see cref="P:UnityEngine.Mesh.vertices" />, <see cref="P:UnityEngine.Mesh.normals" />, <see cref="P:UnityEngine.Mesh.triangles" /> etc. properties), internally the mesh data is marked as "modified" and is sent to the graphics API next time the mesh is rendered.You can call UploadMeshData to immediately send the modified data to the graphics API, to avoid a possible hiccup later. Passing <c>true</c> in <c>markNoLogerReadable</c> argument makes mesh data not be readable from the script anymore, and frees up system memory copy of the data.See Also: <see cref="P:UnityEngine.Mesh.vertices" />, <see cref="P:UnityEngine.Mesh.normals" />, <see cref="P:UnityEngine.Mesh.triangles" />, <see cref="M:UnityEngine.Mesh.MarkDynamic" />.</para>
      </summary>
      <param name="markNoLogerReadable">Frees up system memory copy of mesh data when set to <c>true</c>.</param>
    </member>
    <member name="P:UnityEngine.MeshCollider.convex">
      <summary>
        <para>Use a convex collider from the mesh.</para>
        <para>This means that if you have this set to true, your mesh collider wont have holes or entrances. Convex meshes can collide with other convex colliders and non-convex meshes. Thus convex mesh colliders are suitable on rigidibodies, if you really need more detailed colliders than what the primitive colliders provide you with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.sharedMesh">
      <summary>The mesh object used for collision detection.</summary>
    </member>
    <member name="P:UnityEngine.MeshFilter.mesh">
      <summary>
        <para>Returns the instantiated <see cref="T:UnityEngine.Mesh" /> assigned to the mesh filter.</para>
        <para>If no mesh is assigned to the mesh filter a new mesh will be created and assigned.If a mesh is assigned to the mesh filter already, then first query of <c>mesh</c> property will create a duplicate of it, and this copy will be returned. Further queries of <c>mesh</c> property will return this duplicated mesh instance. Once <c>mesh</c> property is queried, link to the original shared mesh is lost and MeshFilter.sharedMesh property becomes an alias to <c>mesh</c>. If you want to avoid this automatic mesh duplication, use MeshFilter.sharedMesh instead.By using <c>mesh</c> property you can modify the mesh for a single object only. The other objects that used the same mesh will not be modified.It is your responsibility to destroy the automatically instantiated mesh when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the mesh but it is usually only called when loading a new level.Consider <c>mesh</c> property as a shortcut for the following code:</para>
        <para>Which is called on first query of <c>mesh</c> property.Note: If <see cref="T:UnityEngine.MeshFilter" /> is a part of an asset object, quering <c>mesh</c> property is not allowed and only asset mesh can be assigned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshFilter.sharedMesh">
      <summary>
        <para>Returns the shared mesh of the mesh filter.</para>
        <para>It is recommended to use this function only for reading mesh data and not for writing, since you might modify imported assets and all objects that use this mesh will be affected. Also, be aware that is not possible to undo the changes done to this mesh.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshRenderer.additionalVertexStreams">
      <summary>
        <para>Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer.</para>
        <para>This is used for the UVs for realtime lightmaps, but could also be used for vertex painting tools, etc. For example, if the primary mesh doesn't contain the <see cref="P:UnityEngine.Mesh.colors" /> channel, the colors from additionalVertexStreams are used. If the primary mesh contains the colors channel and the additionalVertexStreams mesh also has colors, then colors from additionalVertexStreams are used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Microphone.devices">
      <summary>
        <para>A list of available microphone devices, identified by name.</para>
        <para>You can use the name with the <see cref="M:UnityEngine.Microphone.Start(System.String,System.Boolean,System.Int32,System.Int32)" /> and <see cref="M:UnityEngine.Microphone.End(System.String)" /> functions to specify which microphone you wish to start/stop recording.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Microphone.End(System.String)">
      <summary>
        <para>Stops recording.</para>
        <para>If you pass a null or empty string for the device name then the default microphone will be used. You can get a list of available microphone devices from the <see cref="P:UnityEngine.Microphone.devices" /> property.</para>
      </summary>
      <param name="deviceName">The name of the device.</param>
    </member>
    <member name="M:UnityEngine.Microphone.GetDeviceCaps(System.String,System.Int32@,System.Int32@)">
      <summary>
        <para>Get the frequency capabilities of a device.</para>
        <para>Passing null or an empty string for the device name will select the default device. You can use the <see cref="P:UnityEngine.Microphone.devices" /> property to get a list of all available microphones.When a value of zero is returned in the <c>minFreq</c> and <c>maxFreq</c> parameters, this indicates that the device supports any frequency.</para>
      </summary>
      <param name="deviceName">The name of the device.</param>
      <param name="minFreq">Returns the minimum sampling frequency of the device.</param>
      <param name="maxFreq">Returns the maximum sampling frequency of the device.</param>
    </member>
    <member name="M:UnityEngine.Microphone.GetPosition(System.String)">
      <summary>
        <para>Get the position in samples of the recording.</para>
        <para>If you pass a null or empty string for the device name then the default microphone will be used. You can get a list of available microphone devices from the <see cref="P:UnityEngine.Microphone.devices" /> property.You can use this to control latency. If you want a 30ms latency, poll GetPosition() until 30ms (in samples) has gone and then start the audio.</para>
      </summary>
      <param name="deviceName">The name of the device.</param>
    </member>
    <member name="M:UnityEngine.Microphone.IsRecording(System.String)">
      <summary>
        <para>Query if a device is currently recording.</para>
        <para>If you pass a null or empty string for the device name then the default microphone will be used. You can get a list of available microphone devices from the <see cref="P:UnityEngine.Microphone.devices" /> property.</para>
      </summary>
      <param name="deviceName">The name of the device.</param>
    </member>
    <member name="M:UnityEngine.Microphone.Start(System.String,System.Boolean,System.Int32,System.Int32)">
      <summary>
        <para>Start Recording with device.</para>
        <para>If you pass a null or empty string for the device name then the default microphone will be used. You can get a list of available microphone devices from the <see cref="P:UnityEngine.Microphone.devices" /> property. You can find the range of sample rates supported by a microphone using the <see cref="M:UnityEngine.Microphone.GetDeviceCaps(System.String,System.Int32@,System.Int32@)" /> property.Note that if you want to use the Microphone class in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before calling any Microphone methods.</para>
      </summary>
      <param name="deviceName">The name of the device.</param>
      <param name="loop">Indicates whether the recording should continue recording if lengthSec is reached, and wrap around and record from the beginning of the AudioClip.</param>
      <param name="lengthSec">Is the length of the AudioClip produced by the recording.</param>
      <param name="frequency">The sample rate of the AudioClip produced by the recording.</param>
      <returns>The function returns null if the recording fails to start.</returns>
    </member>
    <member name="P:UnityEngine.MonoBehaviour.useGUILayout">
      <summary>
        <para>Disabling this lets you skip the GUI layout phase.</para>
        <para>It can only be used if you do not use GUI.Window and GUILayout inside of this OnGUI call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.CancelInvoke">
      <summary>Cancels all Invoke calls on this MonoBehaviour.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.CancelInvoke(System.String)">
      <summary>Cancels all Invoke calls with name <c>methodName</c> on this behaviour.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.Invoke(System.String,System.Single)">
      <summary>Invokes the method <c>methodName</c> in time seconds.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.InvokeRepeating(System.String,System.Single,System.Single)">
      <summary>Invokes the method <c>methodName</c> in <c>time</c> seconds, then repeatedly every <c>repeatRate</c> seconds.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.IsInvoking(System.String)">
      <summary>Is any invoke on <c>methodName</c> pending?</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.IsInvoking">
      <summary>Is any invoke pending on this MonoBehaviour?</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.Collections.IEnumerator)">
      <summary>
        <para>Starts a coroutine.</para>
        <para>The execution of a coroutine can be paused at any point using the yield statement. The yield return value specifies when the coroutine is resumed. Coroutines are excellent when modelling behaviour over several frames. Coroutines have virtually no performance overhead. StartCoroutine function always returns immediately, however you can yield the result. This will wait until the coroutine has finished execution.When using JavaScript it is not necessary to use StartCoroutine, the compiler will do this for you. When writing C# code you must call StartCoroutine.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.String,System.Object)">
      <summary>
        <para>Starts a coroutine named <c>methodName</c>.</para>
        <para>In most cases you want to use the StartCoroutine variation above. However StartCoroutine using a string method name allows you to use <see cref="M:UnityEngine.MonoBehaviour.StopCoroutine(System.String)" /> with a specific method name. The downside is that the string version has a higher runtime overhead to start the coroutine and you can pass only one parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.String)">
      <summary>
        <para>Starts a coroutine named <c>methodName</c>.</para>
        <para>In most cases you want to use the StartCoroutine variation above. However StartCoroutine using a string method name allows you to use <see cref="M:UnityEngine.MonoBehaviour.StopCoroutine(System.String)" /> with a specific method name. The downside is that the string version has a higher runtime overhead to start the coroutine and you can pass only one parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopAllCoroutines">
      <summary>Stops all coroutines running on this behaviour.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopCoroutine(System.String)">
      <summary>Stops the first coroutine named <c>methodName</c>, or the coroutine stored in <c>routine</c> running on this behaviour.</summary>
      <param name="methodName">Name of coroutine.</param>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopCoroutine(System.Collections.IEnumerator)">
      <summary>Stops the first coroutine named <c>methodName</c>, or the coroutine stored in <c>routine</c> running on this behaviour.</summary>
      <param name="routine">Name of the function in code.</param>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.print(System.Object)">
      <summary>Logs message to the Unity Console (identical to <see cref="M:UnityEngine.Debug.Log(System.Object)" />).</summary>
      <seealso cref="M:UnityEngine.Debug.Log(System.Object)" />
      <seealso cref="M:UnityEngine.Debug.LogWarning(System.Object)" />
      <seealso cref="M:UnityEngine.Debug.LogError(System.Object)" />
    </member>
    <member name="P:UnityEngine.MovieTexture.audioClip">
      <summary>
        <para>Returns the <see cref="T:UnityEngine.AudioClip" /> belonging to the MovieTexture.</para>
        <para>Note that this is a special <see cref="T:UnityEngine.AudioClip" /> which will always play its audio synchronized to the movie. If you attach a Movie's audioClip to a source in the editor, it will start playing automatically when the movie is playing, Otherwise you'll have to start it manually when you start the movie. The clip can only be attached to one single <see cref="T:UnityEngine.AudioSource" />.See Also: <see cref="M:UnityEngine.MovieTexture.Play" />, <see cref="P:UnityEngine.WWW.movie" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MovieTexture.duration">
      <summary>
        <para>The time, in seconds, that the movie takes to play back completely.</para>
        <para>Note that duration is only available once the movie has started. Until then duration will return -1. If you need to know the duration of a movie before it is played, consider extracting this information offline and creating a text asset. You can then look up the duration given the movie name.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MovieTexture.isPlaying">
      <summary>Returns whether the movie is playing or not.</summary>
    </member>
    <member name="P:UnityEngine.MovieTexture.isReadyToPlay">
      <summary>
        <para>If the movie is downloading from a web site, this returns if enough data has been downloaded so playback should be able to start without interruptions.</para>
        <para>For movies not associated with a web stream, this value always returns true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MovieTexture.loop">
      <summary>Set this to true to make the movie loop.</summary>
    </member>
    <member name="M:UnityEngine.MovieTexture.Pause">
      <summary>Pauses playing the movie.</summary>
    </member>
    <member name="M:UnityEngine.MovieTexture.Play">
      <summary>
        <para>Starts playing the movie.</para>
        <para>Note that a running MovieTexture will use a lot of CPU power, and it will continue running until it is manually stopped or a new level is loaded.Also note that MovieTextures does not behave exactly the same as for example audio clips. When you call the Play() method on a MovieTexture, it is the Asset that will start playing, and not a particular instance of the movie. This means that if you have for example several planes in your scene, all having the same MovieTexture set as their materials texture, when you call Play() on one of them, every instance of the Movie will start playing.See Also: <see cref="M:UnityEngine.MovieTexture.Stop" />, <see cref="P:UnityEngine.MovieTexture.audioClip" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MovieTexture.Stop">
      <summary>Stops playing the movie, and rewinds it to the beginning.</summary>
    </member>
    <member name="F:UnityEngine.NavMesh.AllAreas">
      <summary>
        <para>Area mask constant that includes all NavMesh areas.</para>
        <para>The mask can be used in query functions, such as <see cref="M:UnityEngine.NavMesh.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.NavMeshHit@,System.Int32)" />, to indicate that all NavMesh area types are accepted.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMesh.avoidancePredictionTime">
      <summary>
        <para>Describes how far in the future the agents predict collisions for avoidance.</para>
        <para>The larger the value, the earlier the agents will start to avoid each other if they are on collision course. The value is measured in seconds. Default value is 2.0, a good range for tuning is between 0.5 and 5.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMesh.pathfindingIterationsPerFrame">
      <summary>
        <para>The maximum amount of nodes processed each frame in the asynchronous pathfinding process.</para>
        <para>The pathfinder expands only a certain amount of nodes (NavMesh polygons) each frame while doing path finding. This allows the game to run smoothly without hiccups when long paths or large number of request are being processed at the same time, the flip side is that it can take number of frames for a path request to complete.The iteration count only affects asyncronous pathfinding which used when setting NavMesh Agent destination using <see cref="M:UnityEngine.NavMeshAgent.SetDestination(UnityEngine.Vector3)" /> or <see cref="P:UnityEngine.NavMeshAgent.destination" />.Increasing this value will cause the paths to be processed faster, but can cause some hiccups in frame rate. Default value is 100, a good range for tuning is between 50 and 500.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMesh.CalculatePath(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32,UnityEngine.NavMeshPath)">
      <summary>
        <para>Calculate a path between two points and store the resulting path.</para>
        <para>This function can be used to plan a path ahead of time to avoid a delay in gameplay when the path is needed. Another use is to check if a target position is reachable before moving the agent.In contrast to <see cref="M:UnityEngine.NavMeshAgent.SetDestination(UnityEngine.Vector3)" />, which is asyncronous call, this function calculates the path immeditely. This can be costly operation for very long paths and can cause hiccup in the frame rate. It is recommended to do only a few path finds per frame, for example when evaluating distances to cover points.The returned path can be used to set the path for an agent using <see cref="M:UnityEngine.NavMeshAgent.SetPath(UnityEngine.NavMeshPath)" />. The agent needs to be close the starting point for the set path to work.</para>
      </summary>
      <param name="sourcePosition">The initial position of the path requested.</param>
      <param name="targetPosition">The final position of the path requested.</param>
      <param name="areaMask">A bitfield mask specifying which NavMesh areas can be passed when calculating a path.</param>
      <param name="path">The resulting path.</param>
      <returns>True if a either a complete or partial path is found and false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.NavMesh.CalculateTriangulation">
      <summary>
        <para>Calculates triangulation of the current navmesh.</para>
        <para>Calculates and returns a simple triangulation of the current navmesh - containing the vertices, triangle indices and navmesh layers.The returned mesh contains only the triangles used for pathfinding. It does not contain the detail that is used to place the agents on the walkable surface. This can be noticeable on locations with curved surfaces.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMesh.FindClosestEdge(UnityEngine.Vector3,UnityEngine.NavMeshHit@,System.Int32)">
      <summary>
        <para>Locate the closest NavMesh edge from a point on the NavMesh.</para>
        <para>The returned <see cref="T:UnityEngine.NavMeshHit" /> object contains the position and details of the nearest point on the nearest edge of the navmesh. This can be used to query how much extra space there is around the agent.</para>
      </summary>
      <param name="sourcePosition">The origin of the distance query.</param>
      <param name="hit">Holds the properties of the resulting location.</param>
      <param name="areaMask">A bitfield mask specifying which NavMesh areas can be passed when finding the nearest edge.</param>
      <returns>True if a nearest edge is found.</returns>
    </member>
    <member name="M:UnityEngine.NavMesh.GetAreaCost(System.Int32)">
      <summary>
        <para>Gets the cost for path finding over geometry of the area type.</para>
        <para>The value applies to all agents unless you the value has been customized per agent by calling <see cref="M:UnityEngine.NavMeshAgent.SetAreaCost(System.Int32,System.Single)" />.You can use <see cref="M:UnityEngine.NavMesh.GetAreaFromName(System.String)" /> to find the area index based on the name of the <see cref="T:UnityEngine.NavMesh" /> area type.See also: • Areas and Costs – to learn how to use different Area types.</para>
      </summary>
      <param name="areaIndex">Index of the area to get.</param>
    </member>
    <member name="M:UnityEngine.NavMesh.GetAreaFromName(System.String)">
      <summary>Returns the area index for a named NavMesh area type.</summary>
      <param name="areaName">Name of the area to look up.</param>
      <returns>Index if the specified are, or -1 if no area found.</returns>
    </member>
    <member name="M:UnityEngine.NavMesh.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.NavMeshHit@,System.Int32)">
      <summary>
        <para>Trace a line between two points on the NavMesh.</para>
        <para>The source and destination points are first mapped on the NavMesh, then a ray is traced from the source point towards the target. If the ray hits a NavMesh boundary, the function returns true and the hit data is filled. If the path from the source to target is unobstructed, the function returns false.This function can be used to check if an agent can walk unobstructed between two points on the NavMesh. For example if you character has an evasive dodge move which needs space, you can shoot a ray from the characters location to multiple directions to find a spot where the character can dodge to.The <see cref="M:UnityEngine.NavMesh.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.NavMeshHit@,System.Int32)" /> is different from physics ray cast because it works on “2.5D”, on the NavMesh. The difference to physics raycast is that the NavMesh version can detect all kind of navigation obstructions, such as holes in the ground, and it can also climb up slopes, if the area is navigable.</para>
        <para>If you are looking for to find the nearest point on the <see cref="T:UnityEngine.NavMesh" /> you should use physics raycast to find a point in the world, see Move to Click Point example.</para>
      </summary>
      <param name="sourcePosition">The origin of the ray.</param>
      <param name="targetPosition">The end of the ray.</param>
      <param name="hit">Holds the properties of the ray cast resulting location.</param>
      <param name="areaMask">A bitfield mask specifying which NavMesh areas can be passed when tracing the ray.</param>
      <returns>True if the ray is terminated before reaching target position. Otherwise returns false.</returns>
    </member>
    <member name="M:UnityEngine.NavMesh.SamplePosition(UnityEngine.Vector3,UnityEngine.NavMeshHit@,System.Single,System.Int32)">
      <summary>
        <para>Finds the closest point on NavMesh within specified range.</para>
        <para>The function samples the NavMesh to find the closest point on the NavMesh. The closest point is returned based on distance to the query point. The function does not check for obstruction in the world. For example, you the sourcePosition is on the ceiling, a point on the second floor will be returned (if there is NavMesh there), instead of floor position on the first floor.The function can get quite expensive if the search radius is really big. A good starting point for the maxDistance is 2 times the agent height.If you are trying to find a random point on the NavMesh, it is better to use recommended radius and do try multiple times instead of using one very large radius.</para>
      </summary>
      <param name="sourcePosition">The origin of the sample query.</param>
      <param name="hit">Holds the properties of the resulting location.</param>
      <param name="maxDistance">Sample within this distance from sourcePosition.</param>
      <param name="areaMask">A mask specifying which NavMesh areas are allowed when finding the nearest point.</param>
      <returns>True if a nearest point is found.</returns>
    </member>
    <member name="M:UnityEngine.NavMesh.SetAreaCost(System.Int32,System.Single)">
      <summary>
        <para>Sets the cost for finding path over geometry of the area type on all agents.</para>
        <para>This will replace any custom area costs on all agents, and set the default cost for new agents that are created after calling the function. The cost must be larger than 1.0.You can use <see cref="M:UnityEngine.NavMesh.GetAreaFromName(System.String)" /> to find the area index based on the name of the NavMesh area type.</para>
      </summary>
      <param name="areaIndex">Index of the area to set.</param>
      <param name="cost">New cost.</param>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.acceleration">
      <summary>
        <para>The maximum acceleration of an agent as it follows a path, given in units / sec^2.</para>
        <para>An agent does not follow precisely the line segments of the path calculated by the navigation system but rather uses the waypoints along the path as intermediate destinations. This value is the maximum amount by which the agent can accelerate while moving towards the next waypoint.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.angularSpeed">
      <summary>
        <para>Maximum turning speed in (deg/s) while following a path.</para>
        <para>This is the maximum rate at which the agent can turn as it rounds the "corner" defined by a waypoint. The actual turning circle is also influenced by the speed of the agent on approach and also the maximum acceleration.See Also: acceleration, velocity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.areaMask">
      <summary>
        <para>Specifies which NavMesh areas are passable. Changing <c>areaMask</c> will make the path stale (see <see cref="P:UnityEngine.NavMeshAgent.isPathStale" />).</para>
        <para>This is a bitfield.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.autoBraking">
      <summary>
        <para>Should the agent brake automatically to avoid overshooting the destination point?</para>
        <para>If the agent needs to land close to the destination point then it will typically need to brake to avoid overshooting or endless "orbiting" around the target zone. If this property is set to true, the agent will brake automatically as it nears the destination.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.autoRepath">
      <summary>
        <para>Should the agent attempt to acquire a new path if the existing path becomes invalid?</para>
        <para>A new path calculation is also attempted aquired if the agent reaches the end of a partial and stale path.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.autoTraverseOffMeshLink">
      <summary>
        <para>Should the agent move across OffMeshLinks automatically?</para>
        <para>Off-mesh links are used to connect disjoint regions of the NavMesh. Usually, a character should be able to pass through or <c>traverse</c> a link automatically, which will happen if this property is set to true. However, it can also be set to false in cases where special control over movement is needed.See Also: <see cref="P:UnityEngine.NavMeshAgent.isOnOffMeshLink" />, <see cref="M:UnityEngine.NavMeshAgent.CompleteOffMeshLink" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.avoidancePriority">
      <summary>
        <para>The avoidance priority level.</para>
        <para>When the agent is performing avoidance, agents of lower priority are ignored. The valid range is from 0 to 99 where: Most important = 0. Least important = 99. Default = 50.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.baseOffset">
      <summary>The relative vertical displacement of the owning <see cref="T:UnityEngine.GameObject" />.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.currentOffMeshLinkData">
      <summary>
        <para>The current <see cref="T:UnityEngine.OffMeshLinkData" />.</para>
        <para>In the case that this agent is not on an OffMeshLink the <see cref="T:UnityEngine.OffMeshLinkData" /> is marked as invalid.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.desiredVelocity">
      <summary>The desired velocity of the agent including any potential contribution from avoidance. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.destination">
      <summary>
        <para>Gets or attempts to set the destination of the agent in world-space units.</para>
        <para>Getting:Returns the destination set for this agent.• If a destination is set but the path is not yet processed the position returned will be valid navmesh position that's closest to the previously set position. • If the agent has no path or requested path - returns the agents position on the navmesh. • If the agent is not mapped to the navmesh (e.g. scene has no navmesh) - returns a position at infinity.Setting:Requests the agent to move to the valid navmesh position that's closest to the requested destination.• The path result may not become available until after a few frames. Use <see cref="P:UnityEngine.NavMeshAgent.pathPending" /> to query for outstanding results. • If it's not possible to find a valid nearby navmesh position (e.g. scene has no navmesh) no path is requested. Use <see cref="M:UnityEngine.NavMeshAgent.SetDestination(UnityEngine.Vector3)" /> and check return value if you need to handle this case explicitly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.hasPath">
      <summary>
        <para>Does the agent currently have a path? (Read Only)</para>
        <para>This property will be true if the agent has a path calculated to the desired destination and false otherwise.See Also: pathPending.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.height">
      <summary>The height of the agent for purposes of passing under obstacles, etc.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.isOnNavMesh">
      <summary>
        <para>Is the agent currently bound to the navmesh? (Read Only)</para>
        <para>This property is true if the agent, for some reason, could not bind to the navmesh. E.g. if scene has no navmesh.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.isOnOffMeshLink">
      <summary>
        <para>Is the agent currently positioned on an OffMeshLink? (Read Only)</para>
        <para>This property is useful when <see cref="P:UnityEngine.NavMeshAgent.autoTraverseOffMeshLink" /> is false and custom movement is needed when crossing the link.See Also: <see cref="P:UnityEngine.NavMeshAgent.autoTraverseOffMeshLink" />, <see cref="M:UnityEngine.NavMeshAgent.CompleteOffMeshLink" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.isPathStale">
      <summary>
        <para>Is the current path stale. (Read Only)</para>
        <para>When true, the path may no longer be valid or optimal. This flag will be set if: there are any changes to the <see cref="P:UnityEngine.NavMeshAgent.areaMask" />, if any <see cref="T:UnityEngine.OffMeshLink" /> is enabled or disabled, or if the costs for the NavMeshAreas have been changed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.nextOffMeshLinkData">
      <summary>
        <para>The next <see cref="T:UnityEngine.OffMeshLinkData" /> on the current path.</para>
        <para>In the case that the current path does not contain an OffMeshLink the <see cref="T:UnityEngine.OffMeshLinkData" /> is marked as invalid.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.nextPosition">
      <summary>
        <para>Gets or sets the simulation position of the navmesh agent.</para>
        <para>The position vector is in world space coordinates and units.The nextPosition is coupled to <see cref="P:UnityEngine.Transform.position" />. In the default case the navmesh agent's Transform position will match the internal simulation position at the time the script Update function is called. This coupling can be turned on and off by setting <see cref="P:UnityEngine.NavMeshAgent.updatePosition" />.When <see cref="P:UnityEngine.NavMeshAgent.updatePosition" /> is true, the <see cref="P:UnityEngine.Transform.position" /> reflects the simulated position, when false the position of the transform and the navmesh agent is not synchronized, and you'll see a difference between the two in general. When <see cref="P:UnityEngine.NavMeshAgent.updatePosition" /> is turned back on, the <see cref="P:UnityEngine.Transform.position" /> will be immediately move to match nextPosition.By setting nextPosition you can directly control where the internal agent position should be. The agent will be moved towards the position, but is constrained by the navmesh connectivity and boundaries. As such it will be useful only if the positions are continuously updated and assessed.</para>
        <para>Additionally it can be useful to control the agent position directly - especially if the GO transform is controlled by something else - e.g. animator, physics, scripted or input.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.obstacleAvoidanceType">
      <summary>
        <para>The level of quality of avoidance.</para>
        <para>This property lets you trade off the precision of obstacle avoidance againt the processor load required to achieve it. The exact quality/performance values will depend heavily on the complexity of the scene but as a general rule, faster performance can be achieved at the cost of quality and vice versa.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.path">
      <summary>
        <para>Property to get and set the current path.</para>
        <para>This property can be useful for GUI, debugging and other purposes to get the points of the path calculated by the navigation system. Additionally, a path created from user code can be set for the agent to follow in the usual way. An example of this might be a patrol route designed for coverage rather than optimal distance between two points.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.pathPending">
      <summary>Is a path in the process of being computed but not yet ready? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.pathStatus">
      <summary>The status of the current path (complete, partial or invalid).</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.radius">
      <summary>
        <para>The avoidance radius for the agent.</para>
        <para>This is the agent's "personal space" within which obstacles and other agents should not pass.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.remainingDistance">
      <summary>
        <para>The distance between the agent's position and the destination on the current path. (Read Only)</para>
        <para>If the remaining distance is unknown then this will have a value of infinity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.speed">
      <summary>
        <para>Maximum movement speed when following a path.</para>
        <para>An agent will typically need to speed up and slow down as it follows a path (eg, it will slow down to make a tight turn). The speed is often limited by the length of a path segment and the time taken to accelerate and brake, but the speed will not exceed the value set by this property even on a long, straight path.See Also: desiredVelocity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.steeringTarget">
      <summary>
        <para>Get the current steering target along the path. (Read Only)</para>
        <para>This is typically the next corner along the path or the end point of the path.Unless the agent is moving on an <see cref="T:UnityEngine.OffMeshLink" />, there is a straight path between the agent and the steeringTarget.When approaching an <see cref="T:UnityEngine.OffMeshLink" /> for traversal - the value is the position where the agent will enter the link. While agent is traversing an <see cref="T:UnityEngine.OffMeshLink" /> the value is the position where the agent will leave the link.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.stoppingDistance">
      <summary>
        <para>Stop within this distance from the target position.</para>
        <para>It is seldom possible to land <c>exactly</c> at the target point, so this property can be used to set an acceptable radius within which the agent should stop. A larger stopping distance will give the agent more room for manoeuvre at the end of the path and might avoid sudden braking, turning or other unconvincing AI behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.updatePosition">
      <summary>
        <para>Gets or sets whether the transform position is synchronized with the simulated agent position. The default value is true.</para>
        <para>When true: changing the transform position will affect the simulated position and vice-versa.When false: the simulated position will not be applied to the transform position and vice-versa.Setting <see cref="P:UnityEngine.NavMeshAgent.updatePosition" /> to false can be used to enable explicit control of the transform position via script. This allows you to use the agent's simulated position to drive another component, which in turn sets the transform position (eg. animation with root motion or physics).When enabling the <see cref="P:UnityEngine.NavMeshAgent.updatePosition" /> (from previously being disabled), the transform will be moved to the simulated position. This way the agent stays constrained to the navmesh surface.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.updateRotation">
      <summary>Should the agent update the transform orientation?</summary>
    </member>
    <member name="P:UnityEngine.NavMeshAgent.velocity">
      <summary>
        <para>Access the current velocity of the <see cref="T:UnityEngine.NavMeshAgent" /> component, or set a velocity to control the agent manually.</para>
        <para>Reading the variable will return the current velocity of the agent based on the crowd simulation.Setting the variable will override the simulation (including: moving towards destination, collision avoidance, and acceleration control) and command the NavMesh Agent to move using the specific velocity directly. When the agent is controlled using a velocity, its movement is still constrained on the NavMesh.Setting the velocity directly can be used for implementing player characters which are moving on NavMesh and affecting the rest of the simulated crowd. In addition, setting priority to high (a small value is higher priority), will make other simulated agents to avoid the player controlled agent even more eagerly.It is recommended to set the velocity each frame when controlling the agent manually, and if releasing the control to the simulation, set the velocity to zero. If agent’s velocity is set to some value and then stopped updating it, the simulation will pick up from there and the agent will slowly decelerate (assuming no destination is set).Note that reading the velocity will always return value from the simulation. If you set the value, the effect will show up in the next update. Since the returned velocity comes from the simulation (including avoidance and collision handling), it can be different than the one you set.The velocity is specified in distance units per second (same as physics), and represented in global coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.ActivateCurrentOffMeshLink(System.Boolean)">
      <summary>
        <para>Enables or disables the current off-mesh link.</para>
        <para>This function activates or deactivates the off-mesh link where the agent is currently waiting. This is useful for granting access to newly discovered areas of the game world or simulating the creation or removal of an obstacle to an area.</para>
      </summary>
      <param name="activated">Is the link activated?</param>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.CalculatePath(UnityEngine.Vector3,UnityEngine.NavMeshPath)">
      <summary>
        <para>Calculate a path to a specified point and store the resulting path.</para>
        <para>This function can be used to plan a path ahead of time to avoid a delay in gameplay when the path is needed. Another use is to check if a target position is reachable before moving the agent.</para>
      </summary>
      <param name="targetPosition">The final position of the path requested.</param>
      <param name="path">The resulting path.</param>
      <returns>True if a path is found.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.CompleteOffMeshLink">
      <summary>
        <para>Completes the movement on the current OffMeshLink.</para>
        <para>The agent will move to the closest valid navmesh position on the other end of the current OffMeshLink.CompleteOffMeshLink has no effect unless the agent is on an OffMeshLink. It is useful for implementing custom movement across OffMeshLinks.</para>
      </summary>
      <seealso cref="P:UnityEngine.NavMeshAgent.isOnOffMeshLink" />
      <seealso cref="P:UnityEngine.NavMeshAgent.autoTraverseOffMeshLink" />
    </member>
    <member name="M:UnityEngine.NavMeshAgent.FindClosestEdge(UnityEngine.NavMeshHit@)">
      <summary>
        <para>Locate the closest NavMesh edge.</para>
        <para>The returned <see cref="T:UnityEngine.NavMeshHit" /> object contains the position and details of the nearest point on the nearest edge of the Navmesh. Since an edge typically corresponds to a wall or other large object, this could be used to make a character take cover as close to the wall as possible.</para>
      </summary>
      <param name="hit">Holds the properties of the resulting location.</param>
      <returns>True if a nearest edge is found.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.GetAreaCost(System.Int32)">
      <summary>
        <para>Gets the cost for path calculation when crossing area of a particular type.</para>
        <para>The cost of a path is the amount of "difficulty" involved in calculating it - the shortest path may not be the best if it passes over difficult ground, such as mud, snow, etc. Different types of areas are denoted by navmesh areas in Unity. The cost of a particular area is given in cost units per distance unit. Note that the cost of a path applies to the pathfinding only and does not automatically affect the movement speed of the agent when following the path. Indeed, the path's cost may denote other factors such as danger (safe but long path through a minefield) or visibility (long path that keeps a character in the shadows).</para>
      </summary>
      <param name="areaIndex">Area Index.</param>
      <returns>Current cost for specified area index.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.Move(UnityEngine.Vector3)">
      <summary>
        <para>Apply relative movement to current position.</para>
        <para>If the agent has a path it will be adjusted.</para>
      </summary>
      <param name="offset">The relative movement vector.</param>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.Raycast(UnityEngine.Vector3,UnityEngine.NavMeshHit@)">
      <summary>
        <para>Trace a straight path towards a target postion in the NavMesh without moving the agent.</para>
        <para>This function follows the path of a "ray" between the agent's position and the specified target position. If an obstruction is encountered along the line then a true value is returned and the position and other details of the obstructing object are stored in the <c>hit</c> parameter. This can be used to check if there is a clear shot or line of sight between a character and a target object. This function is preferable to the similar <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" /> because the line tracing is performed in a simpler way using the navmesh and has a lower processing overhead.</para>
      </summary>
      <param name="targetPosition">The desired end position of movement.</param>
      <param name="hit">Properties of the obstacle detected by the ray (if any).</param>
      <returns>True if there is an obstacle between the agent and the target position, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.ResetPath">
      <summary>
        <para>Clears the current path.</para>
        <para>When the path is cleared, the agent will not start looking for a new path until SetDestination is called.Note that if the agent is on an OffMeshLink when this function is called, it will complete the link immediately.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.Resume">
      <summary>
        <para>Resumes the movement along the current path after a pause.</para>
        <para>See <see cref="M:UnityEngine.NavMeshAgent.Stop" /> for how to pause movement along the current path.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.SamplePathPosition(System.Int32,System.Single,UnityEngine.NavMeshHit@)">
      <summary>
        <para>Sample a position along the current path.</para>
        <para>This function looks ahead a specified distance along the current path. Details of the mesh at that position are then returned in a <see cref="T:UnityEngine.NavMeshHit" /> object. This could be used, for example, to check the type of surface that lies ahead before the character gets there - a character could raise his gun above his head if he is about to wade through water, say.</para>
      </summary>
      <param name="areaMask">A bitfield mask specifying which NavMesh areas can be passed when tracing the path.</param>
      <param name="maxDistance">Terminate scanning the path at this distance.</param>
      <param name="hit">Holds the properties of the resulting location.</param>
      <returns>True if terminated before reaching the position at maxDistance, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.SetAreaCost(System.Int32,System.Single)">
      <summary>
        <para>Sets the cost for traversing over areas of the area type.</para>
        <para>If you enable or disable the agent then the cost will be reset to the default layer cost.</para>
      </summary>
      <param name="areaIndex">Area cost.</param>
      <param name="areaCost">New cost for the specified area index.</param>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.SetDestination(UnityEngine.Vector3)">
      <summary>
        <para>Sets or updates the destination thus triggering the calculation for a new path.</para>
        <para>Note that the path may not become available until after a few frames later. While the path is being computed, <see cref="P:UnityEngine.NavMeshAgent.pathPending" /> will be true. If a valid path becomes available then the agent will resume movement.</para>
      </summary>
      <param name="target">The target point to navigate to.</param>
      <returns>True if the destination was requested successfully, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.SetPath(UnityEngine.NavMeshPath)">
      <summary>
        <para>Assign a new path to this agent.</para>
        <para>If the path is succesfully assigned the agent will resume movement toward the new target. If the path cannot be assigned the path will be cleared (see <see cref="M:UnityEngine.NavMeshAgent.ResetPath" />).</para>
      </summary>
      <param name="path">New path to follow.</param>
      <returns>True if the path is succesfully assigned.</returns>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.Stop">
      <summary>
        <para>Stop movement of this agent along its current path.</para>
        <para>See <see cref="M:UnityEngine.NavMeshAgent.Resume" /> for how to resume movement after stopping.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMeshAgent.Warp(UnityEngine.Vector3)">
      <summary>
        <para>Warps agent to the provided position.</para>
        <para>Returns true if successful, otherwise returns false.</para>
      </summary>
      <param name="newPosition">New position to warp the agent to.</param>
      <returns>True if agent is successfully warped, otherwise false.</returns>
    </member>
    <member name="P:UnityEngine.NavMeshHit.distance">
      <summary>Distance to the point of hit.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshHit.hit">
      <summary>Flag set when hit.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshHit.mask">
      <summary>Mask specifying NavMesh area at point of hit.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshHit.normal">
      <summary>Normal at the point of hit.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshHit.position">
      <summary>Position of hit.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.carveOnlyStationary">
      <summary>
        <para>Should this obstacle be carved when it is constantly moving?</para>
        <para>When this property is enabled, the obstacle will carve a hole only when it is stationary. There will be no hole carved when the object is moving. See <see cref="P:UnityEngine.NavMeshObstacle.carving" /> for full description of different carving behaviors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.carving">
      <summary>
        <para>Should this obstacle make a cut-out in the navmesh.</para>
        <para>When enabled, this changes the navmesh by cutting out a hole. The shape of the hole is based on the size and shape set on <see cref="T:UnityEngine.NavMeshObstacle" /> and the navmesh bake settings for radius and height.When the obstacle moves, the carved hole will also move but to reduce CPU overhead the hole is only recalculated when necessary. The recalculation logic has two options: 1) carve when stationary, 2) carve when moved."Carve when stationary" is the default behavior and is used when <see cref="P:UnityEngine.NavMeshObstacle.carveOnlyStationary" /> is set to true. The obstacle is treated as moving when it has moved more than the distance set by <see cref="P:UnityEngine.NavMeshObstacle.carvingMoveThreshold" />. At this time, the carved hole is removed. When the obstacle has stopped moving, and has been stationary more than <see cref="P:UnityEngine.NavMeshObstacle.carvingTimeToStationary" /> seconds, the obstacles is treated stationary and carving is updated again. While the obstacle is moving, the agents will avoid it using the collision avoidance, but will not plan paths around it. This mode is generally the best choice in terms of performance. It is good match when the game object is controlled by physics (i.e. crates and barrels)."Carve when moved" behavior is used when <see cref="P:UnityEngine.NavMeshObstacle.carveOnlyStationary" /> is set to false. In this mode the carved hole is updated when the obstacle has moved more than the distance set by <see cref="P:UnityEngine.NavMeshObstacle.carvingMoveThreshold" />. This mode is well suited for large slowly moving obstacles, for example a tank that is being avoided by infantry.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.carvingMoveThreshold">
      <summary>
        <para>Threshold distance for updating a moving carved hole (when carving is enabled).</para>
        <para>If the <see cref="T:UnityEngine.NavMeshObstacle" /> has moved a distance shorter than the threshold since last carving then the navmesh will not be updated.See Also: <see cref="P:UnityEngine.NavMeshObstacle.carving" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.carvingTimeToStationary">
      <summary>
        <para>Time to wait until obstacle is treated as stationary (when carving and carveOnlyStationary are enabled).</para>
        <para>If the <see cref="T:UnityEngine.NavMeshObstacle" /> has been moving, and becomes still, We wait <c>carvingTimeToStationary</c> time until the obstacle is treated stationary by the carving system. See <see cref="P:UnityEngine.NavMeshObstacle.carving" /> for full description of different carving behaviors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.center">
      <summary>The center of the obstacle, measured in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.height">
      <summary>Height of the obstacle's cylinder shape.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.radius">
      <summary>Radius of the obstacle's capsule shape.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.shape">
      <summary>Shape of the obstacle.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.size">
      <summary>
        <para>The size of the obstacle, measured in the object's local space.</para>
        <para>The size will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshObstacle.velocity">
      <summary>Velocity at which the obstacle moves around the NavMesh.</summary>
    </member>
    <member name="P:UnityEngine.NavMeshPath.corners">
      <summary>
        <para>Corner points of the path. (Read Only)</para>
        <para>Also known as "waypoints", the corners define the places along a path where it changes direction (ie, the path consists of a number of straight-line moves between corners).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NavMeshPath.status">
      <summary>
        <para>Status of the path. (Read Only)</para>
        <para>This reports whether the path reaches to the target, partway to the target or is completely invalid.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NavMeshPath.#ctor">
      <summary>NavMeshPath constructor.</summary>
    </member>
    <member name="M:UnityEngine.NavMeshPath.ClearCorners">
      <summary>Erase all corner points from path.</summary>
    </member>
    <member name="M:UnityEngine.NavMeshPath.GetCornersNonAlloc(UnityEngine.Vector3[])">
      <summary>
        <para>Calculate the corners for the path.</para>
        <para>This function is similar to the <see cref="P:UnityEngine.NavMeshPath.corners" /> property except that the results are returned in the supplied array.Note that this function expects the supplied array to have at least 2 elements.</para>
      </summary>
      <param name="results">Array to store path corners.</param>
      <returns>The number of corners along the path - including start and end points.</returns>
    </member>
    <member name="F:UnityEngine.NavMeshTriangulation.areas">
      <summary>
        <para>NavMesh area indices for the navmesh triangulation.</para>
        <para>Contains one element for each triangle.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NavMeshTriangulation.indices">
      <summary>
        <para>Triangle indices for the navmesh triangulation.</para>
        <para>Contains 3 integers for each triangle. These integers refer to the vertices array.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NavMeshTriangulation.vertices">
      <summary>
        <para>Vertices for the navmesh triangulation.</para>
        <para>Vertices are referenced by the indices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.connections">
      <summary>
        <para>All connected players.</para>
        <para>On a client this contains only the server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.connectionTesterIP">
      <summary>The IP address of the connection tester used in Network.TestConnection.</summary>
    </member>
    <member name="P:UnityEngine.Network.connectionTesterPort">
      <summary>The port of the connection tester used in Network.TestConnection.</summary>
    </member>
    <member name="P:UnityEngine.Network.incomingPassword">
      <summary>
        <para>Set the password for the server (for incoming connections).</para>
        <para>This must be matched in the Network.Connect routine on the clients. Pass "" to specify no password (this is default).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.isClient">
      <summary>Returns true if your peer type is client.</summary>
    </member>
    <member name="P:UnityEngine.Network.isMessageQueueRunning">
      <summary>
        <para>Enable or disable the processing of network messages.</para>
        <para>If this is disabled no RPC call execution or network view synchronization takes place. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.isServer">
      <summary>Returns true if your peer type is server.</summary>
    </member>
    <member name="P:UnityEngine.Network.logLevel">
      <summary>
        <para>Set the log level for network messages (default is Off).</para>
        <para>For a description of the different log levels have a look at the <see cref="T:UnityEngine.NetworkLogLevel" /> enum.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.maxConnections">
      <summary>
        <para>Set the maximum amount of connections/players allowed.</para>
        <para>Setting it to 0 means no new connections can be made but the existing ones stay connected. Setting it to -1 means the maximum connections count is set to the same number of current open connections. In that case, if a players drops then the slot is still open for him. This cannot be set higher than the connection count given in Network.InitializeServer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.minimumAllocatableViewIDs">
      <summary>
        <para>Get or set the minimum number of ViewID numbers in the ViewID pool given to clients by the server.</para>
        <para>The ViewID pools are given to each player as he connects and are refreshed with new numbers if the player runs out. The server and clients should be in sync regarding this value. Setting this higher only on the server has the effect that he sends more view ID numbers to clients, than they really want. Setting this higher only on clients means they request more view IDs more often, for example twice in a row, as the pools received from the server don't contain enough numbers. The default value is 100.If a game instantiates a lot of new objects over the network on each client, like more than 100 network intantiations per minute, then this value should be set higher.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.natFacilitatorIP">
      <summary>
        <para>The IP address of the NAT punchthrough facilitator.</para>
        <para>Usually this is the same as the Master Server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.natFacilitatorPort">
      <summary>The port of the NAT punchthrough facilitator.</summary>
    </member>
    <member name="P:UnityEngine.Network.peerType">
      <summary>The status of the peer type, i.e. if it is disconnected, connecting, server or client.</summary>
    </member>
    <member name="P:UnityEngine.Network.player">
      <summary>Get the local <see cref="T:UnityEngine.NetworkPlayer" /> instance.</summary>
    </member>
    <member name="P:UnityEngine.Network.proxyIP">
      <summary>The IP address of the proxy server.</summary>
    </member>
    <member name="P:UnityEngine.Network.proxyPassword">
      <summary>
        <para>Set the proxy server password.</para>
        <para>It is possible to make your own custom proxy server. In that case you might want to password protect it and then your Unity players must set this value appropriately.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.proxyPort">
      <summary>The port of the proxy server.</summary>
    </member>
    <member name="P:UnityEngine.Network.sendRate">
      <summary>The default send rate of network updates for all Network Views.</summary>
    </member>
    <member name="P:UnityEngine.Network.time">
      <summary>
        <para>Get the current network time (seconds).</para>
        <para>This can, for example, be used to compare with the time returned in <see cref="T:UnityEngine.NetworkMessageInfo" />. The example script needs to be attached to an object with a network view and have the network view observe the script. It measures the time it took to send a message which synchronizes the X postion value of the objects transform.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.useProxy">
      <summary>
        <para>Indicate if proxy support is needed, in which case traffic is relayed through the proxy server.</para>
        <para>The proxy server is a solution to connectivity problems with servers as well as clients. When a machine has an non NAT punchthrough capable router his connectivity options are limited. A game cannot be hosted as nobody external can connect to him (only clients on the local network can). By using the proxy server the machine can be fully connectable but with the extra cost of having all traffic relayed through another server. A non NAT punchthrough capable client can connect to any server through the proxy server, as long as the proxy server is set up properly.Unity Technologies does not provide a proxy server for public use, so to use this feature you will need to set up your own proxy server. Of course it is advisable to set up a proxy server with a public IP address and a lot of available bandwidth.When running as a client, just enabling Network.useProxy is all you have to do. Connect to the server as usual with Network.Connect(). All traffic will be relayed through the proxy server. The servers external IP and internal IP still work as usual. So clients can connect to him directly without the proxy in case they are located on the same network.When running as a server OnServerInitialized(NetworkPlayer) returns a NetworkPlayer structure which indicates what the game servers relayed IP/port is, i.e. what port the proxy server allocated to the game server. This is the IP/port others can use to connect to. When connecting to the server, the clients don't treat the server any differently than other servers. Technically speaking, they don't need to know at all that the game server is getting help from a proxy server. When using the master server you can no longer only rely on the IP/port he registers for servers when using proxy support. The proxy server IP address and port which the server is using can be placed in the comment field of the data sent to the master server. A client which received host information from the master server can peek into the comment field and find out if he can use an alternative IP/port for that host.IMPORTANT: You should never enable proxy support for both the server and the client connecting to him. Unexpected things are bound to happen.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.AllocateViewID">
      <summary>
        <para>Query for the next available network view ID number and allocate it (reserve).</para>
        <para>This number can then be assigned to the network view of an instantiated object. The example below demonstrates a simple method to do this. Note that for this to work there must be a <see cref="T:UnityEngine.NetworkView" /> attached to the object which has this script and it must have the script as its observed property. There must be a Cube prefab present also with a <see cref="T:UnityEngine.NetworkView" /> which watches something (like the <see cref="T:UnityEngine.Transform" /> of the Cube). The cubePrefab variable in the script must be set to that cube prefab. This is the simplest method of using AllocateViewID intelligently. This get more complicated if there were more than one <see cref="T:UnityEngine.NetworkView" /> attached to the Cube which is to be instantiated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.CloseConnection(UnityEngine.NetworkPlayer,System.Boolean)">
      <summary>
        <para>Close the connection to another system.</para>
        <para>
          <c>target</c> defines which system to close the connection to. If we are a client the only possible connection to close is the server connection, if we are a server the target player will be kicked off. <c>sendDisconnectionNotification</c>, enables or disables notifications being sent to the other end. If disabled the connection is dropped, if not a disconnect notification is reliably sent to the remote party and there after the connection is dropped.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String,System.Int32,System.String)">
      <summary>
        <para>Connect to the specified host (ip or domain name) and server port.</para>
        <para>The parameters are the <c>IP</c> address of the host. Either a dotted IP address or a domain name. <c>remotePort</c>, which specifies the port on the remote machine to connect to. <c>password</c>, which is an optional password for the server. The password has to match the Network.incomingPassword set on the server.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String[],System.Int32,System.String)">
      <summary>
        <para>This function is exactly like Network.Connect but can accept an array of IP addresses.</para>
        <para>It can be used when the host information from a master server returns multiple internal IP addresses, then the IP data structure can be passed directly into this connect function. It actually connects to the first IP which responds to a ping (i.e. is connectable).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String,System.String)">
      <summary>
        <para>Connect to a server GUID. NAT punchthrough can only be performed this way.</para>
        <para>The host GUID value is exposed locally through the <see cref="T:UnityEngine.NetworkPlayer" /> structure. The master server also provides this in the <see cref="T:UnityEngine.HostData" /> structure.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(UnityEngine.HostData,System.String)">
      <summary>Connect to the host represented by a <see cref="T:UnityEngine.HostData" /> structure returned by the Master Server.</summary>
    </member>
    <member name="M:UnityEngine.Network.Destroy(UnityEngine.NetworkViewID)">
      <summary>
        <para>Destroy the object associated with this view ID across the network.</para>
        <para>The object is destroyed locally and remotely.Note that this does not remove any RPCs accociated with the object or NetworkViewID, these have to be explicitly removed with the <see cref="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkPlayer)" /> method.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Destroy(UnityEngine.GameObject)">
      <summary>
        <para>Destroy the object across the network.</para>
        <para>The object is destroyed locally and remotely.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.DestroyPlayerObjects(UnityEngine.NetworkPlayer)">
      <summary>
        <para>Destroy all the objects based on view IDs belonging to this player.</para>
        <para>This should only be called when running as a server. It is, for example, meant to to clean up networked objects left by a disconnected player.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Disconnect(System.Int32)">
      <summary>
        <para>Close all open connections and shuts down the network interface.</para>
        <para>The <c>timeout</c> parameter indicates how much time in milliseconds the network interface gets to signal to others that it is disconnecting. The network state, like security and password, is also reset.Note that if you set the timeout to 0 the network interface will shut down before the disconnect notification can be sent to the remote party. For a client this could mean he cannot reconnect to the server as the server thinks he is still connected (after a certain interval the connection will be detected as dropped).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Disconnect">
      <summary>
        <para>Close all open connections and shuts down the network interface.</para>
        <para>The <c>timeout</c> parameter indicates how much time in milliseconds the network interface gets to signal to others that it is disconnecting. The network state, like security and password, is also reset.Note that if you set the timeout to 0 the network interface will shut down before the disconnect notification can be sent to the remote party. For a client this could mean he cannot reconnect to the server as the server thinks he is still connected (after a certain interval the connection will be detected as dropped).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.GetAveragePing(UnityEngine.NetworkPlayer)">
      <summary>
        <para>The last average ping time to the given <c>player</c> in milliseconds.</para>
        <para>If the player can't be found -1 will be returned. Pings are automatically sent out every couple of seconds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.GetLastPing(UnityEngine.NetworkPlayer)">
      <summary>
        <para>The last ping time to the given <c>player</c> in milliseconds.</para>
        <para>If the player can't be found -1 will be returned. Pings are automatically sent out every couple of seconds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.HavePublicAddress">
      <summary>
        <para>Check if this machine has a public IP address.</para>
        <para>It checks all the network interfaces for IPv4 public addresses and returns true if one address is found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeSecurity">
      <summary>
        <para>Initializes security layer.</para>
        <para>You need to call this function on the server before calling Network.InitializeServer. Don't call this function on the client.Once your online game reaches a certain popularity people will try to cheat. You will need to account for this both at the game layer and at the network layer. Unity handles the network layer by providing secure connections if you wish to use them. * Uses AES encryption. Prevents unauthorized reads and blocks replay attacks * Adds CRCs so that data tampering can be detected. * Uses randomized, encrypted SYNCookies to prevent unauthorized logins. * Uses RSA encryption to protect the AES key. Most games will want to use secure connections. However, they add up to 15 bytes per packet and take time to compute so you may wish to limit usage to deployed games only.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeServer(System.Int32,System.Int32)">
      <summary>
        <para>Initialize the server.</para>
        <para>
          <c>connections</c> is the number of allowed incoming connections (note that this is generally not the same as the number of players). <c>listenPort</c> is the port number we want to listen to. <c>useNat</c> sets the NAT punchthrough functionality. If you want this server to be able to accept connections using NAT punchthrough, using the facilitator, set this to true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeServer(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Initialize the server.</para>
        <para>
          <c>connections</c> is the number of allowed incoming connections (note that this is generally not the same as the number of players). <c>listenPort</c> is the port number we want to listen to. <c>useNat</c> sets the NAT punchthrough functionality. If you want this server to be able to accept connections using NAT punchthrough, using the facilitator, set this to true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Network instantiate a prefab.</para>
        <para>The given prefab will be instanted on all clients in the game. Synchronization is automatically set up so there is no extra work involved. The position, rotation and network group number are given as parameters. Note that in the example below there must be something set to the playerPrefab in the Editor. You can read more about instantiations in the object reference Object.Instantiate.Internally this is a buffered RPC call. You can use Network.RemoveRPCs is with the group number to remove the call from the buffer. Alternatively you can call Network.RemoveRPCs on the first NetworkViewID in the instantiated prefab. When the instantiation occurs internally the buffered RPC message is linked to the first NetworkView of the prefab which makes this possible.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkPlayer)">
      <summary>Remove all RPC functions which belong to this player ID.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkPlayer,System.Int32)">
      <summary>Remove all RPC functions which belong to this player ID and were sent based on the given group.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkViewID)">
      <summary>Remove the RPC function calls accociated with this view ID number.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCsInGroup(System.Int32)">
      <summary>Remove all RPC functions which belong to given group number.</summary>
    </member>
    <member name="M:UnityEngine.Network.SetLevelPrefix(System.Int32)">
      <summary>
        <para>Set the level prefix which will then be prefixed to all network ViewID numbers.</para>
        <para>This offers protection to prevent old network updates from straying from into a new level from the previous level. This can be set to any number and then incremented with each new level load. This doesn't add overhead to network traffic but just diminishes the pool of network ViewID numbers a little bit. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetReceivingEnabled(UnityEngine.NetworkPlayer,System.Int32,System.Boolean)">
      <summary>
        <para>Enable or disables the reception of messages in a specific group number from a specific player.</para>
        <para>You can use the when you do not want any network messages coming in for processing at the moment, and then enable it later when you are ready. This is useful to stop network messages until a level is loaded, for example.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetSendingEnabled(System.Int32,System.Boolean)">
      <summary>
        <para>Enables or disables transmission of messages and RPC calls on a specific network group number.</para>
        <para>This can be set when you know you are not sending anything useful to other clients, such as before you have loaded you level completely. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetSendingEnabled(UnityEngine.NetworkPlayer,System.Int32,System.Boolean)">
      <summary>
        <para>Enable or disable transmission of messages and RPC calls based on target network player as well as the network group.</para>
        <para>When used on a client, the only <see cref="T:UnityEngine.NetworkPlayer" /> possible is the server.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnection(System.Boolean)">
      <summary>
        <para>Test this machines network connection.</para>
        <para>Two types of tests are performed depending on if the machine has a public IP address present or if it only has a private address (or addresses). The public IP address test is primarily for when running a server as no tests are needed for clients with public addresses. In order for the public IP test to succeed a server instance must be started. A test server will try to connect to the IP and port of the local server and thus it is shown in the server is connectable. If not then a firewall is most likely blocking the server port. A server instance needs to be running so that the test server has something to connect to.The other test is for checking NAT punchthrough capabilities. This is a valid test for both servers and clients and can be performed without any prior setup. There are 4 types of NAT test results (see <see cref="T:UnityEngine.ConnectionTesterStatus" />): __Full Cone_, Address Restricted Cone, Port restricted and Symmetric.First two types offer full NAT punchthrough support and can connect to any type. Port restricted type cannot connect to or receive a connection from symmetric type. Symmetric if worst and cannot connect to other symmetric types or port restricted type. The latter two are labelled as offering limited NAT punchthrough support.This function is asynchronous and might not return a valid result right away because the tests needs some time to complete (1-2 seconds). After test completion the test result is only returned when the function is called again, a full network test is not redone. That way it is safe to poll the function frequently. If another test is desired, like if the network connection has been altered, then the <c>forceTest</c> parameter should be passed as true.The function returns a <see cref="T:UnityEngine.ConnectionTesterStatus" /> enum.</para>
        <para>If you know both server and client NAT types you could use the following function to determine if the client can connect to the server or not.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnection">
      <summary>
        <para>Test this machines network connection.</para>
        <para>Two types of tests are performed depending on if the machine has a public IP address present or if it only has a private address (or addresses). The public IP address test is primarily for when running a server as no tests are needed for clients with public addresses. In order for the public IP test to succeed a server instance must be started. A test server will try to connect to the IP and port of the local server and thus it is shown in the server is connectable. If not then a firewall is most likely blocking the server port. A server instance needs to be running so that the test server has something to connect to.The other test is for checking NAT punchthrough capabilities. This is a valid test for both servers and clients and can be performed without any prior setup. There are 4 types of NAT test results (see <see cref="T:UnityEngine.ConnectionTesterStatus" />): __Full Cone_, Address Restricted Cone, Port restricted and Symmetric.First two types offer full NAT punchthrough support and can connect to any type. Port restricted type cannot connect to or receive a connection from symmetric type. Symmetric if worst and cannot connect to other symmetric types or port restricted type. The latter two are labelled as offering limited NAT punchthrough support.This function is asynchronous and might not return a valid result right away because the tests needs some time to complete (1-2 seconds). After test completion the test result is only returned when the function is called again, a full network test is not redone. That way it is safe to poll the function frequently. If another test is desired, like if the network connection has been altered, then the <c>forceTest</c> parameter should be passed as true.The function returns a <see cref="T:UnityEngine.ConnectionTesterStatus" /> enum.</para>
        <para>If you know both server and client NAT types you could use the following function to determine if the client can connect to the server or not.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnectionNAT(System.Boolean)">
      <summary>
        <para>Test the connection specifically for NAT punch-through connectivity.</para>
        <para>This is like Network.TestConnection except that a NAT punchthrough test is forced, even through the machine does not have a NAT address (private IP address) but a public address. See Network.TestConnection example code.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnectionNAT">
      <summary>
        <para>Test the connection specifically for NAT punch-through connectivity.</para>
        <para>This is like Network.TestConnection except that a NAT punchthrough test is forced, even through the machine does not have a NAT address (private IP address) but a public address. See Network.TestConnection example code.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.networkView">
      <summary>The <see cref="T:UnityEngine.NetworkView" /> who sent this message.</summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.sender">
      <summary>The player who sent this network message (owner).</summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.timestamp">
      <summary>
        <para>The time stamp when the Message was sent in seconds.</para>
        <para>Timestamps can be used to implement interpolation or extrapolation of continous streams of packets The timestamp is passed as a double to avoid overflow when a game is running for a long time. Internally timestamps are sent as 32 bit integers with millisecond accuracy to save bandwidth. Timestamps are automatically adjusted to be relative to Network.time. Thus Network.time - messageInfo.timeStamp is the time the packet spent in transit.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.externalIP">
      <summary>
        <para>Returns the external IP address of the network interface.</para>
        <para>This will only be populated after some external connection has been made.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.externalPort">
      <summary>
        <para>Returns the external port of the network interface.</para>
        <para>This will only be populated after some external connection has been made.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.guid">
      <summary>The GUID for this player, used when connecting with NAT punchthrough.</summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.ipAddress">
      <summary>The IP address of this player.</summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.port">
      <summary>The port of this player.</summary>
    </member>
    <member name="M:UnityEngine.NetworkPlayer.ToString">
      <summary>Returns the index number for this network player.</summary>
    </member>
    <member name="M:UnityEngine.NetworkPlayer.operator !=(UnityEngine.NetworkPlayer,UnityEngine.NetworkPlayer)">
      <summary>Returns true if two NetworkPlayers are not the same player.</summary>
    </member>
    <member name="M:UnityEngine.NetworkPlayer.operator ==(UnityEngine.NetworkPlayer,UnityEngine.NetworkPlayer)">
      <summary>Returns true if two NetworkPlayers are the same player.</summary>
    </member>
    <member name="P:UnityEngine.NetworkView.group">
      <summary>
        <para>The network group number of this network view.</para>
        <para>All network messages and RPC calls go through this group number.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkView.isMine">
      <summary>Is the network view controlled by this object?</summary>
    </member>
    <member name="P:UnityEngine.NetworkView.observed">
      <summary>The component the network view is observing.</summary>
    </member>
    <member name="P:UnityEngine.NetworkView.owner">
      <summary>The <see cref="T:UnityEngine.NetworkPlayer" /> who owns this network view.</summary>
    </member>
    <member name="P:UnityEngine.NetworkView.stateSynchronization">
      <summary>
        <para>The type of <see cref="T:UnityEngine.NetworkStateSynchronization" /> set for this network view.</para>
        <para>It is your repsonsibility to ensure that NetworkView's across all machines use the same reliability method. Do not change state reliability on the fly after state synchronization has already happened.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkView.viewID">
      <summary>The ViewID of this network view.</summary>
    </member>
    <member name="M:UnityEngine.NetworkView.SetScope(UnityEngine.NetworkPlayer,System.Boolean)">
      <summary>
        <para>Set the scope of the network view in relation to a specific network player.</para>
        <para>This can be used to implement relevant sets. Either set it to true or false depending on if you want the player to receive updates from the network view or not.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.NetworkView.Find(UnityEngine.NetworkViewID)">
      <summary>Find a network view based on a <see cref="T:UnityEngine.NetworkViewID" />.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.unassigned">
      <summary>Represents an invalid network view ID.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.isMine">
      <summary>True if instantiated by me.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.owner">
      <summary>The <see cref="T:UnityEngine.NetworkPlayer" /> who owns the <see cref="T:UnityEngine.NetworkView" />. Could be the server.</summary>
    </member>
    <member name="M:UnityEngine.NetworkViewID.ToString">
      <summary>Returns a formatted string with details on this NetworkViewID.</summary>
    </member>
    <member name="M:UnityEngine.NetworkViewID.operator !=(UnityEngine.NetworkViewID,UnityEngine.NetworkViewID)">
      <summary>Returns true if two NetworkViewIDs are not identical.</summary>
    </member>
    <member name="M:UnityEngine.NetworkViewID.operator ==(UnityEngine.NetworkViewID,UnityEngine.NetworkViewID)">
      <summary>Returns true if two NetworkViewIDs are identical.</summary>
    </member>
    <member name="P:UnityEngine.Object.hideFlags">
      <summary>Should the object be hidden, saved with the scene or modifiable by the user?</summary>
    </member>
    <member name="P:UnityEngine.Object.name">
      <summary>
        <para>The name of the object.</para>
        <para>Components share the same name with the game object and all attached components.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.GetInstanceID">
      <summary>
        <para>Returns the instance id of the object.</para>
        <para>The instance id of an object is always guaranteed to be unique.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.ToString">
      <summary>Returns the name of the game object.</summary>
    </member>
    <member name="M:UnityEngine.Object.Destroy(UnityEngine.Object,System.Single)">
      <summary>
        <para>Removes a gameobject, component or asset.</para>
        <para>The object <c>obj</c> will be destroyed now or if a time is specified <c>t</c> seconds from now. If <c>obj</c> is a <see cref="T:UnityEngine.Component" /> it will remove the component from the <see cref="T:UnityEngine.GameObject" /> and destroy it. If <c>obj</c> is a <see cref="T:UnityEngine.GameObject" /> it will destroy the <see cref="T:UnityEngine.GameObject" />, all its components and all transform children of the <see cref="T:UnityEngine.GameObject" />. Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.</para>
        <para>Destroy is inherited from the UnityEngine.Object base class. Javascript users should consider making a call to UnityEngine.Object.Destroy, rather than Object.Destroy to avoid references being resolved to the .Net System.Object class.</para>
      </summary>
      <param name="obj">The object to destroy.</param>
      <param name="t">The optional amount of time to delay before destroying the object.</param>
    </member>
    <member name="M:UnityEngine.Object.Destroy(UnityEngine.Object)">
      <summary>
        <para>Removes a gameobject, component or asset.</para>
        <para>The object <c>obj</c> will be destroyed now or if a time is specified <c>t</c> seconds from now. If <c>obj</c> is a <see cref="T:UnityEngine.Component" /> it will remove the component from the <see cref="T:UnityEngine.GameObject" /> and destroy it. If <c>obj</c> is a <see cref="T:UnityEngine.GameObject" /> it will destroy the <see cref="T:UnityEngine.GameObject" />, all its components and all transform children of the <see cref="T:UnityEngine.GameObject" />. Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.</para>
        <para>Destroy is inherited from the UnityEngine.Object base class. Javascript users should consider making a call to UnityEngine.Object.Destroy, rather than Object.Destroy to avoid references being resolved to the .Net System.Object class.</para>
      </summary>
      <param name="obj">The object to destroy.</param>
    </member>
    <member name="M:UnityEngine.Object.DestroyImmediate(UnityEngine.Object,System.Boolean)">
      <summary>
        <para>Destroys the object <c>obj</c> immediately. You are strongly recommended to use Destroy instead.</para>
        <para>This function should only be used when writing editor code since the delayed destruction will never be invoked in edit mode. In game code you should use Object.Destroy instead. Destroy is always delayed (but executed within the same frame). Use this function with care since it can destroy assets permanently! Also note that you should never iterate through arrays and destroy the elements you are iterating over. This will cause serious problems (as a general programming practice, not just in Unity).</para>
      </summary>
      <param name="obj">Object to be destroyed.</param>
      <param name="allowDestroyingAssets">Set to true to allow assets to be destoyed.</param>
    </member>
    <member name="M:UnityEngine.Object.DestroyImmediate(UnityEngine.Object)">
      <summary>
        <para>Destroys the object <c>obj</c> immediately. You are strongly recommended to use Destroy instead.</para>
        <para>This function should only be used when writing editor code since the delayed destruction will never be invoked in edit mode. In game code you should use Object.Destroy instead. Destroy is always delayed (but executed within the same frame). Use this function with care since it can destroy assets permanently! Also note that you should never iterate through arrays and destroy the elements you are iterating over. This will cause serious problems (as a general programming practice, not just in Unity).</para>
      </summary>
      <param name="obj">Object to be destroyed.</param>
    </member>
    <member name="M:UnityEngine.Object.DontDestroyOnLoad(UnityEngine.Object)">
      <summary>
        <para>Makes the object <c>target</c> not be destroyed automatically when loading a new scene.</para>
        <para>When loading a new level all objects in the scene are destroyed, then the objects in the new level are loaded. In order to preserve an object during level loading call DontDestroyOnLoad on it. If the object is a component or game object then its entire transform hierarchy will not be destroyed either.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.FindObjectOfType(System.Type)">
      <summary>
        <para>Returns the first active loaded object of Type <c>type</c>.</para>
        <para>Please note that this function is very slow. It is not recommended to use this function every frame. In most cases you can use the singleton pattern instead.See Also: Object.FindObjectsOfType.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.FindObjectsOfType(System.Type)">
      <summary>
        <para>Returns a list of all active loaded objects of Type <c>type</c>.</para>
        <para>It will return no assets (meshes, textures, prefabs, ...) or inactive objects.Please note that this function is very slow. It is not recommended to use this function every frame. In most cases you can use the singleton pattern instead.</para>
      </summary>
      <param name="type">The type of object to find.</param>
      <returns>The array of objects found matching the type specified.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="T:UnityEngine.GameObject" /> then you can also optionally specify its position and rotation (these will default to <see cref="P:UnityEngine.Vector3.zero" /> and <see cref="P:UnityEngine.Quaternion.identity" /> respectively). If you are cloning a <see cref="T:UnityEngine.Component" /> then the GameObject is is attached to will also be cloned, again with an optional position and rotation.When you clone a <see cref="T:UnityEngine.GameObject" /> or <see cref="T:UnityEngine.Component" />, all child objects and components will also be cloned with their properties set like those of the original object. However, the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent explicitly if you wish. Also, the active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.See Also: In depth Prefab Instantiate discussion.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <param name="position">Position for the new object.</param>
      <param name="rotation">Orientation of the new object.</param>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="T:UnityEngine.GameObject" /> then you can also optionally specify its position and rotation (these will default to <see cref="P:UnityEngine.Vector3.zero" /> and <see cref="P:UnityEngine.Quaternion.identity" /> respectively). If you are cloning a <see cref="T:UnityEngine.Component" /> then the GameObject is is attached to will also be cloned, again with an optional position and rotation.When you clone a <see cref="T:UnityEngine.GameObject" /> or <see cref="T:UnityEngine.Component" />, all child objects and components will also be cloned with their properties set like those of the original object. However, the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent explicitly if you wish. Also, the active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.See Also: In depth Prefab Instantiate discussion.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="T:UnityEngine.GameObject" /> then you can also optionally specify its position and rotation (these will default to <see cref="P:UnityEngine.Vector3.zero" /> and <see cref="P:UnityEngine.Quaternion.identity" /> respectively). If you are cloning a <see cref="T:UnityEngine.Component" /> then the GameObject is is attached to will also be cloned, again with an optional position and rotation.When you clone a <see cref="T:UnityEngine.GameObject" /> or <see cref="T:UnityEngine.Component" />, all child objects and components will also be cloned with their properties set like those of the original object. However, the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent explicitly if you wish. Also, the active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.See Also: In depth Prefab Instantiate discussion.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.operator !=(UnityEngine.Object,UnityEngine.Object)">
      <summary>Compares if two objects refer to a different object.</summary>
    </member>
    <member name="M:UnityEngine.Object.operator ==(UnityEngine.Object,UnityEngine.Object)">
      <summary>
        <para>Compares two object references to see if they refer to the same object.</para>
        <para>Get early out if there is no target.</para>
        <para>Be careful when comparing with <c>null</c>.e.g.</para>
        <para>Instatiating a <see cref="T:UnityEngine.GameObject" /> adds it to the scene so it's completely initialized (!destroyed). Instantiating a simple UnityEngine.Object has no such semantics, so the it stays in the 'destroyed' state which compares <c>true</c> to <c>null</c>.</para>
      </summary>
      <param name="x">The first Object.</param>
      <param name="y">The Object to compare against the first.</param>
    </member>
    <member name="P:UnityEngine.OcclusionArea.center">
      <summary>Center of the occlusion area relative to the transform.</summary>
    </member>
    <member name="P:UnityEngine.OcclusionArea.size">
      <summary>Size that the occlusion area will have.</summary>
    </member>
    <member name="P:UnityEngine.OcclusionPortal.open">
      <summary>Gets / sets the portal's open state.</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.activated">
      <summary>Is link active.</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.area">
      <summary>NavMesh area index for this OffMeshLink component.</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.autoUpdatePositions">
      <summary>
        <para>Automatically update endpoints.</para>
        <para>The OffMeshLink component will try to match endpoint transforms specified by <see cref="P:UnityEngine.OffMeshLink.startTransform" /> and <see cref="P:UnityEngine.OffMeshLink.endTransform" /> .</para>
      </summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.biDirectional">
      <summary>
        <para>Can link be traversed in both directions.</para>
        <para>When false the link can only be traversed from start to end.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.costOverride">
      <summary>
        <para>Modify pathfinding cost for the link.</para>
        <para>When the costOverride value is non-negative the cost of moving over the OffMeshLink is equivalent to the costOverride value times the Euclidean distance between OffMeshLink end points.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.endTransform">
      <summary>The transform representing link end position.</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.occupied">
      <summary>Is link occupied. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLink.startTransform">
      <summary>The transform representing link start position.</summary>
    </member>
    <member name="M:UnityEngine.OffMeshLink.UpdatePositions">
      <summary>
        <para>Explicitly update the link endpoints.</para>
        <para>Updates the OffMeshLink endpoints to match the transforms specified by the start and end transforms.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.activated">
      <summary>Is link active (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.endPos">
      <summary>Link end world position (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.linkType">
      <summary>Link type specifier (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.offMeshLink">
      <summary>
        <para>The <see cref="T:UnityEngine.OffMeshLink" /> if the link type is a manually placed Offmeshlink (Read Only).</para>
        <para>Automatically generated Jump and drop links will return null.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.startPos">
      <summary>Link start world position (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.OffMeshLinkData.valid">
      <summary>Is link valid (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Particle.angularVelocity">
      <summary>
        <para>The angular velocity of the particle.</para>
        <para>This is particle's angular velocity in degrees per second.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.color">
      <summary>
        <para>The color of the particle.</para>
        <para>Alpha channel of the color is used to fade out particles.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.energy">
      <summary>
        <para>The energy of the particle.</para>
        <para>This is the time in seconds for how long this particle will remain alive. When the energy drops below zero the the Particle will be killed.The energy is also used for UV animation: If <c>energy</c> equals Particle.startEnergy the first tile will be used. If <c>energy</c> equals 0 the last tile will be used.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.position">
      <summary>The position of the particle.</summary>
    </member>
    <member name="P:UnityEngine.Particle.rotation">
      <summary>
        <para>The rotation of the particle.</para>
        <para>This is particle's rotation in degrees.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.size">
      <summary>
        <para>The size of the particle.</para>
        <para>This is particle's size in meters in world space.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.startEnergy">
      <summary>
        <para>The starting energy of the particle.</para>
        <para>This is the total lifetime of this particle in seconds. It is set by the particle emitter, when creating the particle. This is used to calculate the color and UV animation for the particle.See Also: <see cref="P:UnityEngine.Particle.energy" />Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Particle.velocity">
      <summary>
        <para>The velocity of the particle.</para>
        <para>If there is a particle animator it will move the particle by the <c>velocity</c> every frame. The velocity is also used by the particle renderer if <c>Stretch Particles</c> is set to ParticleRenderMode.Stretch.See Also: Particles documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.autodestruct">
      <summary>
        <para>Does the <see cref="T:UnityEngine.GameObject" /> of this particle animator auto destructs?</para>
        <para>When set to <c>true</c>, the <see cref="T:UnityEngine.GameObject" /> will be destroyed when all particles disappear.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.colorAnimation">
      <summary>
        <para>Colors the particles will cycle through over their lifetime.</para>
        <para>Currently you cannot directly modify a single index of this array. Instead, you need to grab the entire array, modify it, and assign it back to the Particle Animator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.damping">
      <summary>
        <para>How much particles are slowed down every frame.</para>
        <para>A value of 1 gives no damping, while smaller values makes them slow down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.doesAnimateColor">
      <summary>Do particles cycle their color over their lifetime?</summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.force">
      <summary>The force being applied to particles every frame.</summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.localRotationAxis">
      <summary>Local space axis the particles rotate around.</summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.rndForce">
      <summary>
        <para>A random force added to particles every frame.</para>
        <para>Use this to make smoke become more alive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.sizeGrow">
      <summary>How the particle sizes grow over their lifetime.</summary>
    </member>
    <member name="P:UnityEngine.ParticleAnimator.worldRotationAxis">
      <summary>World space axis the particles rotate around.</summary>
    </member>
    <member name="P:UnityEngine.ParticleCollisionEvent.collider">
      <summary>The <see cref="T:UnityEngine.Collider" /> for the GameObject struck by the particles.</summary>
    </member>
    <member name="P:UnityEngine.ParticleCollisionEvent.intersection">
      <summary>
        <para>Intersection point of the collision in world coordinates.</para>
        <para>The intersection point is reported in world coordinates regardless of whether the particle system is simulated in local coordinates.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleCollisionEvent.normal">
      <summary>
        <para>Geometry normal at the intersection point of the collision.</para>
        <para>The normal is reported in world coordinates regardless of whether the particle system is simulated in local coordinates.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleCollisionEvent.velocity">
      <summary>
        <para>Incident velocity at the intersection point of the collision.</para>
        <para>The velocity is reported in world coordinates regardless of whether the particle system is simulated in local coordinates.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.angularVelocity">
      <summary>The angular velocity of new particles in degrees per second.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.emit">
      <summary>Should particles be automatically emitted each frame?</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.emitterVelocityScale">
      <summary>The amount of the emitter's speed that the particles inherit.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.enabled">
      <summary>
        <para>Turns the ParticleEmitter on or off.</para>
        <para>A ParticleEmitter which is not enabled will not emit any particles, and the emitted particles will not animate. So, this value allows you to pause a particle emitter.The default value is true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.localVelocity">
      <summary>The starting speed of particles along X, Y, and Z, measured in the object's orientation.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.maxEmission">
      <summary>The maximum number of particles that will be spawned every second.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.maxEnergy">
      <summary>The maximum lifetime of each particle, measured in seconds.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.maxSize">
      <summary>The maximum size each particle can be at the time when it is spawned.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.minEmission">
      <summary>The minimum number of particles that will be spawned every second.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.minEnergy">
      <summary>The minimum lifetime of each particle, measured in seconds.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.minSize">
      <summary>The minimum size each particle can be at the time when it is spawned.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.particleCount">
      <summary>The current number of particles (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.particles">
      <summary>
        <para>Returns a copy of all particles and assigns an array of all particles to be the current particles.</para>
        <para>Note that after modifying the particles array you must assign it back to the particleEmitter to see the change. Particles with energy of zero or less will be killed when assigning the particles. Thus when creating a complete new particle array, you need to set the energy of all particles explicitly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.rndAngularVelocity">
      <summary>
        <para>A random angular velocity modifier for new particles.</para>
        <para>A random value in the range of [-rndAngularVelocity, rndAngularVelocity] will be applied to all new particles, in addition to ParticleEmitter.angularVelocity See Also: <see cref="P:UnityEngine.ParticleEmitter.angularVelocity" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.rndRotation">
      <summary>If enabled, the particles will be spawned with random rotations.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.rndVelocity">
      <summary>A random speed along X, Y, and Z that is added to the velocity.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.useWorldSpace">
      <summary>If enabled, the particles don't move when the emitter moves. If false, when you move the emitter, the particles follow it around.</summary>
    </member>
    <member name="P:UnityEngine.ParticleEmitter.worldVelocity">
      <summary>The starting speed of particles in world space, along X, Y, and Z.</summary>
    </member>
    <member name="M:UnityEngine.ParticleEmitter.ClearParticles">
      <summary>Removes all particles from the particle emitter.</summary>
    </member>
    <member name="M:UnityEngine.ParticleEmitter.Emit">
      <summary>
        <para>Emit a number of particles.</para>
        <para>Makes the emitter spit out a random number of particles, as set by the <see cref="P:UnityEngine.ParticleEmitter.minEmission" /> and <see cref="P:UnityEngine.ParticleEmitter.maxEmission" /> properties.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ParticleEmitter.Emit(System.Int32)">
      <summary>Emit <c>count</c> particles immediately.</summary>
    </member>
    <member name="M:UnityEngine.ParticleEmitter.Emit(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single,UnityEngine.Color)">
      <summary>Emit a single particle with given parameters.</summary>
      <param name="pos">The position of the particle.</param>
      <param name="velocity">The velocity of the particle.</param>
      <param name="size">The size of the particle.</param>
      <param name="energy">The remaining lifetime of the particle.</param>
      <param name="color">The color of the particle.</param>
    </member>
    <member name="M:UnityEngine.ParticleEmitter.Simulate(System.Single)">
      <summary>
        <para>Advance particle simulation by given time.</para>
        <para>This is useful for pre-warming particle emitters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ParticlePhysicsExtensions.GetCollisionEvents(UnityEngine.ParticleSystem,UnityEngine.GameObject,UnityEngine.ParticleCollisionEvent[])">
      <summary>
        <para>Get the particle collision events for a GameObject. Returns the number of events written to the array.</para>
        <para>This method is typically called from <see href="MonoBehaviour.OnParticleCollision" cref="MonoBehaviour.OnParticleCollision" /> in response to a collision callback.If the array used is too short events may be truncated. To avoid this use ParticleSystem.safeCollisionEventSize to determine an appropriate array size prior the call.See Also: <see href="MonoBehaviour.OnParticleCollision" cref="MonoBehaviour.OnParticleCollision" />.</para>
      </summary>
      <param name="go">The GameObject for which to retrieve collision events.</param>
      <param name="collisionEvents">Array to write collision events to.</param>
    </member>
    <member name="M:UnityEngine.ParticlePhysicsExtensions.GetSafeCollisionEventSize(UnityEngine.ParticleSystem)">
      <summary>
        <para>Safe array size for use with ParticleSystem.GetCollisionEvents.</para>
        <para>This is guaranteed to be large enough to use with ParticleSystem.GetCollisionEvents for the current frame. GetCollisionEvents may return fewer elements for some GameObjects though.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.cameraVelocityScale">
      <summary>
        <para>How much are the particles strected depending on the <see cref="T:UnityEngine.Camera" />'s speed.</para>
        <para>Use this to make particles become large if the viewing camera has a large speed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.lengthScale">
      <summary>
        <para>How much are the particles stretched in their direction of motion.</para>
        <para>Use this to make particles always be longer than they are wide.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.maxParticleSize">
      <summary>
        <para>Clamp the maximum particle size.</para>
        <para>Particles can become very heavy on fillrate. Use this setting to make sure they don't use too much perfomance when up close to the viewer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.particleRenderMode">
      <summary>How particles are drawn.</summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.uvAnimationCycles">
      <summary>Set uv animation cycles.</summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.uvAnimationXTile">
      <summary>Set horizontal tiling count.</summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.uvAnimationYTile">
      <summary>Set vertical tiling count.</summary>
    </member>
    <member name="P:UnityEngine.ParticleRenderer.velocityScale">
      <summary>
        <para>How much are the particles strectched depending on "how fast they move".</para>
        <para>Use this to make particles get longer as their speed increases.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.duration">
      <summary>The duration of the particle system in seconds (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.emissionRate">
      <summary>The rate of emission.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.enableEmission">
      <summary>When set to false, the particle system will not emit particles.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.gravityModifier">
      <summary>Scale being applied to the gravity defined by <see cref="P:UnityEngine.Physics.gravity" />.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.isPaused">
      <summary>Is the particle system paused right now ?</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.isPlaying">
      <summary>Is the particle system playing right now ?</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.isStopped">
      <summary>Is the particle system stopped right now ?</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.loop">
      <summary>
        <para>Is the particle system looping?</para>
        <para>If you disable looping on a playing particle system, it will stop after the end of the current loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.maxParticles">
      <summary>The maximum number of particles to emit.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.particleCount">
      <summary>The current number of particles (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.playbackSpeed">
      <summary>
        <para>The playback speed of the particle system. 1 is normal playback speed.</para>
        <para>A negative playback speed is not supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.playOnAwake">
      <summary>If set to true, the particle system will automatically start playing on startup.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.randomSeed">
      <summary>Random seed used for the particle system emission. If set to 0, it will be assigned a random value on awake.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.simulationSpace">
      <summary>This selects the space in which to simulate particles. It can be either world or local space.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startColor">
      <summary>The initial color of particles when emitted.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startDelay">
      <summary>
        <para>Start delay in seconds.</para>
        <para>Use this to delay when the playback starts on the system.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startLifetime">
      <summary>The total lifetime in seconds that particles will have when emitted. When using curves, this values acts as a scale on the curve. This value is set in the particle when it is create by the particle system.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startRotation">
      <summary>
        <para>The initial rotation of particles when emitted. When using curves, this values acts as a scale on the curve.</para>
        <para>Note that the value should be given in radians.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startSize">
      <summary>The initial size of particles when emitted. When using curves, this values acts as a scale on the curve.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.startSpeed">
      <summary>The initial speed of particles when emitted. When using curves, this values acts as a scale on the curve.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.time">
      <summary>
        <para>Playback position in seconds.</para>
        <para>Use this to read current playback time or to seek to a new playback time.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Clear(System.Boolean)">
      <summary>Remove all particles in the particle system.</summary>
      <param name="withChildren">Clear all child particle systems as well.</param>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Clear">
      <summary>Remove all particles in the particle system.</summary>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Emit(System.Int32)">
      <summary>Emit <c>count</c> particles immediately.</summary>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Emit(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single,UnityEngine.Color32)">
      <summary>Emit a single particle with given parameters.</summary>
      <param name="position">The position of the particle.</param>
      <param name="velocity">The velocity of the particle.</param>
      <param name="size">The size of the particle.</param>
      <param name="lifetime">The remaining lifetime of the particle.</param>
      <param name="color">The color of the particle.</param>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Emit(UnityEngine.Particle)">
      <summary>Emit a single particle.</summary>
    </member>
    <member name="M:UnityEngine.ParticleSystem.GetParticles(UnityEngine.Particle[])">
      <summary>
        <para>Get the particles of this particle system.</para>
        <para>This method is allocation free as long the input "particles" array is preallocated once (see example below). Note that only a small part of the particles array might be used as this depends on how many particles are currently alive in the particle system when calling GetParticles().See Also: <see cref="T:UnityEngine.ParticleSystem.Particle" />, <see cref="M:UnityEngine.ParticleSystem.SetParticles(UnityEngine.Particle[],System.Int32)" />.</para>
      </summary>
      <param name="particles">Particle buffer that is used for writing particle state to. The return value is the number of particles written to this array.</param>
      <returns>The number of particles written to the input particle array (the number of particles currently alive).</returns>
    </member>
    <member name="M:UnityEngine.ParticleSystem.IsAlive(System.Boolean)">
      <summary>Does the system have any live particles (or will produce more)?</summary>
      <param name="withChildren">Check all child particle systems as well.</param>
      <returns>True if the particle system is still "alive", false if the particle system is done emitting particles and all particles are dead.</returns>
    </member>
    <member name="M:UnityEngine.ParticleSystem.IsAlive">
      <summary>Does the system have any live particles (or will produce more)?</summary>
      <returns>True if the particle system is still "alive", false if the particle system is done emitting particles and all particles are dead.</returns>
    </member>
    <member name="M:UnityEngine.ParticleSystem.Pause(System.Boolean)">
      <summary>Pauses playing the particle system.</summary>
      <param name="withChildren">Pause all child particle systems as well.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Stop(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Pause">
      <summary>Pauses playing the particle system.</summary>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Stop(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Play(System.Boolean)">
      <summary>Plays the particle system.</summary>
      <param name="withChildren">Play all child particle systems as well.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Stop(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Play">
      <summary>Plays the particle system.</summary>
      <seealso cref="M:UnityEngine.ParticleSystem.Stop(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.SetParticles(UnityEngine.Particle[],System.Int32)">
      <summary>
        <para>Set the particles of this particle system. <c>size</c> is the number of particles that is set.</para>
        <para>Setting the lifetime of a particle to a negative value will result in Shuriken removing the particle.</para>
      </summary>
      <seealso cref="M:UnityEngine.ParticleSystem.GetParticles(UnityEngine.Particle[])" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Simulate(System.Single,System.Boolean,System.Boolean)">
      <summary>Fastforwards the particle system by simulating particles over given period of time, then pauses it.</summary>
      <param name="t">Time to fastforward the particle system.</param>
      <param name="withChildren">Fastforward all child particle systems as well.</param>
      <param name="restart">Restart and start from the beginning.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Simulate(System.Single,System.Boolean)">
      <summary>Fastforwards the particle system by simulating particles over given period of time, then pauses it.</summary>
      <param name="t">Time to fastforward the particle system.</param>
      <param name="withChildren">Fastforward all child particle systems as well.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Simulate(System.Single)">
      <summary>Fastforwards the particle system by simulating particles over given period of time, then pauses it.</summary>
      <param name="t">Time to fastforward the particle system.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Stop(System.Boolean)">
      <summary>Stops playing the particle system.</summary>
      <param name="withChildren">Stop all child particle systems as well.</param>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="M:UnityEngine.ParticleSystem.Stop">
      <summary>Stops playing the particle system.</summary>
      <seealso cref="M:UnityEngine.ParticleSystem.Play(System.Boolean)" />
      <seealso cref="M:UnityEngine.ParticleSystem.Pause(System.Boolean)" />
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.angularVelocity">
      <summary>
        <para>The angular velocity of the particle.</para>
        <para>This is particle's angular velocity in degrees per second.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.color">
      <summary>
        <para>The initial color of the particle. The current color of the particle is calculated procedurally based on this value and the active color modules.</para>
        <para>Alpha channel of the color is used to fade out particles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.lifetime">
      <summary>
        <para>The lifetime of the particle.</para>
        <para>This is the time in seconds for how long this particle will remain alive. When the lifetime drops below zero the Particle will be killed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.position">
      <summary>
        <para>The position of the particle.</para>
        <para>The position is defined relative to the simulation space (ie, world space or local space) set by the simulationSpace property. You can use <see cref="M:UnityEngine.Transform.TransformPoint(UnityEngine.Vector3)" /> and <see cref="M:UnityEngine.Transform.InverseTransformPoint(UnityEngine.Vector3)" /> to convert points between local and world space as necessary.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.randomSeed">
      <summary>
        <para>The random seed of the particle.</para>
        <para>This is used to create the value used to interpolate between the two curves when random between curves is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.rotation">
      <summary>
        <para>The rotation of the particle.</para>
        <para>This is particle's rotation in degrees.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.size">
      <summary>
        <para>The initial size of the particle. The current size of the particle is calculated procedurally based on this value and the active size modules.</para>
        <para>This is particle's size in meters in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.startLifetime">
      <summary>
        <para>The starting lifetime of the particle.</para>
        <para>This is the total lifetime of this particle in seconds. It is set by the particle system when creating the particle.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystem.Particle.velocity">
      <summary>
        <para>The velocity of the particle.</para>
        <para>The particle will move by the <c>velocity</c> every frame. The velocity is also used by the <see cref="T:UnityEngine.ParticleSystemRenderer" /> if <c>Stretch Particles</c> is set to <see cref="F:UnityEngine.ParticleSystemRenderMode.Stretch" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.cameraVelocityScale">
      <summary>
        <para>How much are the particles strected depending on the <see cref="T:UnityEngine.Camera" />'s speed.</para>
        <para>Use this to make particles become large if the viewing camera has a large speed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.lengthScale">
      <summary>
        <para>How much are the particles stretched in their direction of motion.</para>
        <para>Use this to make particles always be longer than they are wide.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.maxParticleSize">
      <summary>
        <para>Clamp the maximum particle size.</para>
        <para>Particles can become very heavy on fillrate. Use this setting to make sure they don't use too much perfomance when up close to the viewer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.mesh">
      <summary>Mesh used as particle instead of billboarded texture.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.renderMode">
      <summary>How particles are drawn.</summary>
    </member>
    <member name="P:UnityEngine.ParticleSystemRenderer.velocityScale">
      <summary>
        <para>How much are the particles strectched depending on "how fast they move".</para>
        <para>Use this to make particles get longer as their speed increases.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.bounceCombine">
      <summary>
        <para>Determines how the bounciness is combined.</para>
        <para>Traditionally bounciness properties are dependent on the combination of the two materials in contact. This is however impractical in a game. Instead you can use the combine mode to tune how the bounciness values of two materials are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.bounciness">
      <summary>How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.</summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.dynamicFriction">
      <summary>
        <para>The friction used when already moving. This value has to be between 0 and 1.</para>
        <para>A value of 0 feels like ice, 1 feels like rubber.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.frictionCombine">
      <summary>
        <para>Determines how the friction is combined.</para>
        <para>Traditionally friction properties are dependent on the combination of the two materials in contact. This is however impractical in a game. Instead you can use the combine mode to tune how the friction values of two materials are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.staticFriction">
      <summary>
        <para>The friction coefficient used when an object is lying on a surface.</para>
        <para>Must be greater than or equal to zero. Natural materials will usually have a friction coefficient between 0 (no friction at all, like slippy ice) and 1 (full friction, like rubber). Values larger then 1 are possible, and may be realistic for sticky materials.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PhysicMaterial.#ctor">
      <summary>
        <para>Creates a new material.</para>
        <para>Note that although this function lets you create a new physic material from a script, it is generally easier to create and assign the material from the editor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PhysicMaterial.#ctor(System.String)">
      <summary>Creates a new material named <c>name</c>.</summary>
    </member>
    <member name="F:UnityEngine.Physics.AllLayers">
      <summary>
        <para>Layer mask constant to select all layers.</para>
        <para>This can be used in the layermask field of <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" /> and other methods to select all layers.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.bounceThreshold">
      <summary>
        <para>Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.</para>
        <para>This value is usually changed in <c>Edit-&gt;Project Settings-&gt;Physics</c> inspector instead of from scripts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.defaultContactOffset">
      <summary>
        <para>The default contact offset of the newly created colliders.</para>
        <para>Colliders whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive. Contact offset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics.DefaultRaycastLayers">
      <summary>
        <para>Layer mask constant to select default raycast layers.</para>
        <para>This can be used in the layermask field of <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" /> and other methods to select the default raycast layers. The default layers are all layers execpt for the ignore raycast layer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.gravity">
      <summary>
        <para>The gravity applied to all rigid bodies in the scene.</para>
        <para>Gravity can be turned off for an individual rigidbody using its <see cref="P:UnityEngine.Rigidbody.useGravity" /> property.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics.IgnoreRaycastLayer">
      <summary>
        <para>Layer mask constant to select ignore raycast layer.</para>
        <para>This can be used in the layermask field of <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" /> and other methods to select the "ignore raycast" layer (which does not receive raycasts by default).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.queriesHitTriggers">
      <summary>
        <para>Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default.</para>
        <para>This can be overridden on a per-query level by specifying the <c>QueryTriggerInteraction</c> parameter.See Also: <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.sleepThreshold">
      <summary>The mass-normalized energy threshold, below which objects start going to sleep.</summary>
    </member>
    <member name="P:UnityEngine.Physics.solverIterationCount">
      <summary>
        <para>The default solver iteration count permitted for any rigid bodies (default 7). Must be positive.</para>
        <para>The solverIterationCount determines how accurately joints and contacts are resolved. If you are having trouble with connected bodies oscillating and behaving erratically setting a higher solver iteration count may improve their stability (but is slower). Usually a value of 7 works very well for almost all situations.This value is usually changed in <c>Edit-&gt;Project Settings-&gt;Physics</c> inspector instead of from scripts.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a CapsuleCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a CapsuleCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a CapsuleCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a CapsuleCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a capsule cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a capsule cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a capsule cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a capsule cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="point1">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The centre of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The centre of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>
        <para>Are collisions between <c>layer1</c> and <c>layer2</c> being ignored?</para>
        <para>Returns the value set by <see cref="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)" /> or in the Physics inspector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between <c>collider1</c> and <c>collider2</c>.</para>
        <para>This is useful, say, for preventing projectiles from colliding with the object that fires them.Note that IgnoreCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.IgnoreCollision has a few limitations: 1) It is not persistent. This means ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider or attached rigidbody the IgnoreCollision state will be lost and you have to call Physics.IgnoreCollision again.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between <c>collider1</c> and <c>collider2</c>.</para>
        <para>This is useful, say, for preventing projectiles from colliding with the object that fires them.Note that IgnoreCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.IgnoreCollision has a few limitations: 1) It is not persistent. This means ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider or attached rigidbody the IgnoreCollision state will be lost and you have to call Physics.IgnoreCollision again.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between any collider in <c>layer1</c> and any collider in <c>layer2</c>.Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.</para>
        <para>You can set the default values for your project for any layer combinations in the Physics inspector.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)" />
      <seealso cref="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between any collider in <c>layer1</c> and any collider in <c>layer2</c>.Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.</para>
        <para>You can set the default values for your project for any layer combinations in the Physics inspector.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)" />
      <seealso cref="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="T:UnityEngine.RaycastHit" />
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Int32)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="T:UnityEngine.RaycastHit" />
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <seealso cref="T:UnityEngine.RaycastHit" />
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Returns an array with all colliders touching or inside the sphere.</para>
        <para>NOTE: Currently this only checks against the bounding volumes of the colliders not against the actual colliders.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Returns an array with all colliders touching or inside the sphere.</para>
        <para>NOTE: Currently this only checks against the bounding volumes of the colliders not against the actual colliders.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Returns an array with all colliders touching or inside the sphere.</para>
        <para>NOTE: Currently this only checks against the bounding volumes of the colliders not against the actual colliders.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a ray against all colliders in the scene.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update its data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against all colliders in the scene.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update its data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Casts a ray against all colliders in the scene.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update its data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Casts a ray against all colliders in the scene.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update its data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single)">
      <summary>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a Raycast will hit the collider at it's new position.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction.Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction.Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction.Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction.Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit" />
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.Note: If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single,System.Int32)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.Note: If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.Note: If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.Note: If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a SphereCast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: SphereCastAll will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a sphere cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: SphereCastAll will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a sphere cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: SphereCastAll will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a sphere cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way.Notes: SphereCastAll will not detect colliders for which the sphere overlaps the collider. If you move colliders from scripting or by animation, there needs to be at least one FixedUpdate executed so that the physics library can update it's data structures, before a sphere cast will hit the collider at it's new position.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single,System.Int32)">
      <summary>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single)">
      <summary>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single)">
      <summary>Like <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
    </member>
    <member name="F:UnityEngine.Physics2D.AllLayers">
      <summary>Layer mask constant that includes all layers.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.angularSleepTolerance">
      <summary>A rigid-body cannot sleep if its angular velocity is above this tolerance.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.baumgarteScale">
      <summary>The scale factor that controls how fast overlaps are resolved.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.baumgarteTOIScale">
      <summary>The scale factor that controls how fast TOI overlaps are resolved.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.changeStopsCallbacks">
      <summary>
        <para>Whether or not to stop reporting collision callbacks immediately if any of the objects involved in the collision are deleted/moved.</para>
        <para>During a collision callback, if either a Collider2D or Rigidbody2D that is taking part in that particular callback is deleted or moved then this property controls whether callbacks will continue for this contact or not.See Also: Collider2D, Rigidbody2D.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      <summary>
        <para>Layer mask constant that includes all layers participating in raycasts by default.</para>
        <para>The value of the mask is the bitwise complement of the <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" /> mask.See Also: <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <see cref="F:UnityEngine.Physics2D.AllLayers" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.gravity">
      <summary>Acceleration due to gravity.</summary>
    </member>
    <member name="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      <summary>
        <para>Layer mask constant for the default layer that ignores raycasts.</para>
        <para>The value of the mask is the bitwise complement of the <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" /> mask.See Also: <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.AllLayers" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.linearSleepTolerance">
      <summary>A rigid-body cannot sleep if its linear velocity is above this tolerance.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxAngularCorrection">
      <summary>The maximum angular position correction used when solving constraints. This helps to prevent overshoot.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxLinearCorrection">
      <summary>The maximum linear position correction used when solving constraints. This helps to prevent overshoot.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxRotationSpeed">
      <summary>The maximum angular speed of a rigid-body per physics update. Increasing this can cause numerical problems.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxTranslationSpeed">
      <summary>The maximum linear speed of a rigid-body per physics update. Increasing this can cause numerical problems.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.minPenetrationForPenalty">
      <summary>The minimum contact penetration radius allowed before any separation impulse force is applied. Extreme caution should be used when modifying this value as making this smaller means that polygons will have an insufficient buffer for continuous collision and making it larger may create artefacts for vertex collision.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.positionIterations">
      <summary>
        <para>The number of iterations of the physics solver when considering objects' positions.</para>
        <para>A higher number of interations will improve accuracy at the expense of processing overhead.See Also: <see cref="P:UnityEngine.Physics2D.velocityIterations" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.queriesHitTriggers">
      <summary>
        <para>Do raycasts detect Colliders configured as triggers?</para>
        <para>A Collider can be set up to act as a <c>trigger</c> which will detect other Colliders entering its volume but won't physically collide with them. Often, it is desirable to avoid detecting trigger Colliders with raycasts because they don't represent solid objects. This property lets you choose whether or not raycasts should detect triggers.See Also: <see cref="P:UnityEngine.Collider2D.isTrigger" />, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.queriesStartInColliders">
      <summary>
        <para>Do ray/line casts that start inside a collider(s) detect those collider(s)?</para>
        <para>When performing a ray/line cast, the start point can begin inside a collider. When this occurs, this property controls whether these colliders are returned or not. When set to true, such colliders are returned.See Also: <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.timeToSleep">
      <summary>The time in seconds that a rigid-body must be still before it will go to sleep.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.velocityIterations">
      <summary>
        <para>The number of iterations of the physics solver when considering objects' velocities.</para>
        <para>A higher number of interations will improve accuracy at the expense of processing overhead.See Also: <see cref="P:UnityEngine.Physics2D.positionIterations" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.velocityThreshold">
      <summary>Any collisions with a relative linear velocity below this threshold will be treated as inelastic.</summary>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="size">The size of the shape.</param>
      <param name="angle">The angle of the shape (in degrees).</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, :<see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, :<see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, :<see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function returns a <see cref="T:UnityEngine.RaycastHit2D" /> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, :<see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the box can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently.The returned <see cref="T:UnityEngine.RaycastHit2D" /> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />,, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the shape originates.</param>
      <param name="radius">The radius of the shape.</param>
      <param name="direction">Vector representing the direction of the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>Checks whether the collision detection system will ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c> or not.</summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>Should collisions between the specified layers be ignored?</summary>
      <param name="layer1">ID of first layer.</param>
      <param name="layer2">ID of second layer.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)" /> to avoid this overhead if you need to make such calls frequently.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray.This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray.Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c>.</para>
        <para>Ignoring collisions refers to any type of interaction between the selected colliders i.e. no collision or trigger interaction will occur. Collision layers are first checked to see the two layers can interact and if not then no interactions take place. Following that, ignoring specific colliders interactions will occur.IgnoreCollision has a few limitations: 1) It is not persistent. This means that the ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider the IgnoreCollision state will be lost and you have to call Physics2D.IgnoreCollision again.</para>
      </summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
      <param name="ignore">Whether collisions/triggers between <c>collider1</c> and <c>collider2</c> should be ignored or not.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)" />
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>
        <para>Makes the collision detection system ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c>.</para>
        <para>Ignoring collisions refers to any type of interaction between the selected colliders i.e. no collision or trigger interaction will occur. Collision layers are first checked to see the two layers can interact and if not then no interactions take place. Following that, ignoring specific colliders interactions will occur.IgnoreCollision has a few limitations: 1) It is not persistent. This means that the ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider the IgnoreCollision state will be lost and you have to call Physics2D.IgnoreCollision again.</para>
      </summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)" />
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      <summary>Choose whether to detect or ignore collisions between a specified pair of layers.</summary>
      <param name="layer1">ID of the first layer.</param>
      <param name="layer2">ID of the second layer.</param>
      <param name="ignore">Should collisions between these layers be ignored?</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreLayerCollision(System.Int32,System.Int32)" />
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>Choose whether to detect or ignore collisions between a specified pair of layers.</summary>
      <param name="layer1">ID of the first layer.</param>
      <param name="layer2">ID of the second layer.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreLayerCollision(System.Int32,System.Int32)" />
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouching(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>
        <para>Check whether <c>collider1</c> is touching <c>collider2</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider1">The collider to check if it is touching <c>collider2</c>.</param>
      <param name="collider2">The collider to check if it is touching <c>collider1</c>.</param>
      <returns>Whether <c>collider1</c> is touching <c>collider2</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouchingLayers(UnityEngine.Collider2D,System.Int32)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching colliders on the <c>layerMask</c>.</param>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouchingLayers(UnityEngine.Collider2D)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching colliders on the <c>layerMask</c>.</param>
      <returns>Whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and directtion.This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and directtion.This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and directtion.This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported.This function is similar to the <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make linecasts frequently.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and directtion.This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and directtion.This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and directtion.This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line.Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Check if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Check if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Check if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Check if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Check if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Check if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Check if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Check if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Check if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers.Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.See Also: <see cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point.Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" /> to avoid this overhead if you need to make the check frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" /> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.See Also: <see cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported.This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example).Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently.Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.See Also: <see cref="T:UnityEngine.LayerMask" /> class, <see cref="T:UnityEngine.RaycastHit2D" /> class, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="F:UnityEngine.Physics2D.DefaultRaycastLayers" />, <see cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer" />, <c>raycastsHitTriggers</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="P:UnityEngine.PhysicsMaterial2D.bounciness">
      <summary>
        <para>The degree of elasticity during collisions.</para>
        <para>A value of zero indicates no elasticity (ie, no bounce at all) while a value of one indicates perfect elasticity.See Also: <see cref="P:UnityEngine.PhysicMaterial.bounciness" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicsMaterial2D.friction">
      <summary>
        <para>Coefficient of friction.</para>
        <para>A value of zero indicates a surface with no friction while a value of 1 indicates maximum friction (eg, rubber).See Also: <see cref="P:UnityEngine.PhysicMaterial.staticFriction" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Ping.ip">
      <summary>The IP target of the ping.</summary>
    </member>
    <member name="P:UnityEngine.Ping.isDone">
      <summary>Has the ping function completed?</summary>
    </member>
    <member name="P:UnityEngine.Ping.time">
      <summary>This property contains the ping time result after isDone returns true.</summary>
    </member>
    <member name="M:UnityEngine.Ping.#ctor(System.String)">
      <summary>
        <para>Perform a ping to the supplied target IP address.</para>
        <para>This does not perform DNS lookups on host names so it only accepts IP addresses in dot notation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Plane.distance">
      <summary>Distance from the origin to the plane.</summary>
    </member>
    <member name="P:UnityEngine.Plane.normal">
      <summary>Normal vector of the plane.</summary>
    </member>
    <member name="M:UnityEngine.Plane.#ctor(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a plane.</para>
        <para>Resulting plane has normal <c>inNormal</c> and goes through a point <c>inPoint</c>.<c>inNormal</c> must be a normalized vector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Plane.#ctor(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Creates a plane.</para>
        <para>Resulting plane has normal <c>inNormal</c> and distance <c>d</c>.<c>inNormal</c> must be a normalized vector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Plane.#ctor(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a plane.</para>
        <para>The resulting plane goes through the given three points. The points go around clockwise as you look down on the top surface of the plane.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Plane.GetDistanceToPoint(UnityEngine.Vector3)">
      <summary>
        <para>Returns a signed distance from plane to point.</para>
        <para>The value returned is positive if the point is on the side of the plane into which the plane's normal is facing, and negative otherwise.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Plane.GetSide(UnityEngine.Vector3)">
      <summary>Is a point on the positive side of the plane?</summary>
    </member>
    <member name="M:UnityEngine.Plane.Raycast(UnityEngine.Ray,System.Single@)">
      <summary>
        <para>Intersects a ray with the plane.</para>
        <para>This function sets <c>enter</c> to the distance along the ray, where it intersects the plane. If the ray is parallel to the plane, function returns <c>false</c> and sets <c>enter</c> to zero. If the ray is pointing in the opposite direction than the plane, function returns <c>false</c> and sets <c>enter</c> to the distance along the ray (negative value).</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />
    </member>
    <member name="M:UnityEngine.Plane.SameSide(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Are two points on the same side of the plane?</summary>
    </member>
    <member name="M:UnityEngine.Plane.Set3Points(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Sets a plane using three points that lie within it. The points go around clockwise as you look down on the top surface of the plane.</summary>
      <param name="a">First point in clockwise order.</param>
      <param name="b">Second point in clockwise order.</param>
      <param name="c">Third point in clockwise order.</param>
      <seealso cref="M:UnityEngine.Plane.SetNormalAndPosition(UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Plane.SetNormalAndPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Sets a plane using a point that lies within it along with a normal to orient it.</para>
        <para>Note that the normal must be a <c>normalised</c> vector.</para>
      </summary>
      <param name="inNormal">The plane's normal vector.</param>
      <param name="inPoint">A point that lies on the plane.</param>
      <seealso cref="M:UnityEngine.Plane.Set3Points(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.surfaceArc">
      <summary>
        <para>The angle of an arc that defines the surface of the platform centered of the local 'up' of the effector.</para>
        <para>Any collision normal with an angle within this arc is never considered for one-way whereas everything outside this arc is considered for one-way.The default defines an arc that includes collisions from the local horizontal up to the local vertical. If collisions with the local vertical sides are not required then you can reduce the arc by a few degrees.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useOneWay">
      <summary>
        <para>Should the one-way collision behaviour be used?</para>
        <para>When true, collisions are only allowed when the linear velocity, transformed into the local-space of the target <see cref="T:UnityEngine.Collider2D" />, are less than zero. For <see cref="T:UnityEngine.Collider2D" /> that are not rotated in Z, this equates to a vertical velocity less than zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useSideBounce">
      <summary>
        <para>Should bounce be used on the platform sides?</para>
        <para>When false, a contact on the sides uses no bounce. When true, any existing bounce is used. This is useful to stop bouncing of a <see cref="T:UnityEngine.Collider2D" /> when in contact with a vertical surface. The "sides" are defined as the edges perpendicular to the "top" surface(s) in local-space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useSideFriction">
      <summary>
        <para>Should friction be used on the platform sides?</para>
        <para>When false, a contact on the side uses no friction. When true, any existing friction is used. This is useful to stop friction slowing a <see cref="T:UnityEngine.Collider2D" /> when in contact with a vertical surface when a force is being applied to keep the <see cref="T:UnityEngine.Collider2D" /> in contact with the surface. The "sides" are defined as the edges perpendicular to the "top" surface(s) in local-space.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.DeleteAll">
      <summary>Removes all keys and values from the preferences. Use with caution.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.DeleteKey(System.String)">
      <summary>Removes <c>key</c> and its corresponding value from the preferences.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetFloat(System.String,System.Single)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetFloat(System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetInt(System.String,System.Int32)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetInt(System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetString(System.String,System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.HasKey(System.String)">
      <summary>Returns true if <c>key</c> exists in the preferences.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.Save">
      <summary>
        <para>Writes all modified preferences to disk.</para>
        <para>By default Unity writes preferences to disk on Application Quit. In case when the game crashes or otherwise prematuraly exits, you might want to write the PlayerPrefs at sensible 'checkpoints' in your game. This function will write to disk potentially causing a small hiccup, therefore it is not recommended to call during actual gameplay.Note: On Windows Store Apps and Windows Phone 8.1 preferences are saved during application suspend, because there's no application quit event.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetFloat(System.String,System.Single)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetInt(System.String,System.Int32)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetString(System.String,System.String)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.angularDrag">
      <summary>
        <para>The angular drag to apply to rigid-bodies.</para>
        <para>The <c>angularDrag</c> coefficient is applied in addition to the standard <see cref="T:UnityEngine.Rigidbody2D" /> angular drag coefficient to provide additional angular drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.distanceScale">
      <summary>
        <para>The scale applied to the calculated distance between source and target.</para>
        <para>When the distance is calculated between source and target for distance-based force calculations (such as inverse-linear or inverse-squared), it is then scaled by this value. This changes the effective distance used, it does not change the actual distance in which the effector works, as that is always controlled by the collider.This can be useful when using very large or very small colliders, allowing you to shrink or expand the distance calculation, changing the magnitude of the force applied.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.drag">
      <summary>
        <para>The linear drag to apply to rigid-bodies.</para>
        <para>The <c>drag</c> coefficient is applied in addition to the standard <see cref="T:UnityEngine.Rigidbody2D" /> drag coefficient to provide additional drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceMagnitude">
      <summary>The magnitude of the force to be applied.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceMode">
      <summary>The mode used to apply the effector force.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceSource">
      <summary>The source which is used to calculate the centroid point of the effector. The distance from the target is defined from this point.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceTarget">
      <summary>The target for where the effector applies any force.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceVariation">
      <summary>
        <para>The variation of the magnitude of the force to be applied.</para>
        <para>A random value between 0 and <c>forceVariation</c> is used and added to the force magnitude. The <c>forceVariation</c> can be negative to randomly reduce the force magnitude.See Also: <see cref="P:UnityEngine.PointEffector2D.forceMagnitude" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PolygonCollider2D.pathCount">
      <summary>
        <para>The number of paths in the polygon.</para>
        <para>A <c>path</c> is cyclic sequence of line segments between points that define the outline of the polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.See Also: <see cref="M:UnityEngine.PolygonCollider2D.GetPath(System.Int32)" />, <see cref="M:UnityEngine.PolygonCollider2D.SetPath(System.Int32,UnityEngine.Vector2[])" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PolygonCollider2D.points">
      <summary>Corner points that define the collider's shape in local space.</summary>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32,UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
      <param name="scale">The X/Y scale of the polygon. These must be greater than zero.</param>
      <param name="offset">The X/Y offset of the polygon.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32,UnityEngine.Vector2)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
      <param name="scale">The X/Y scale of the polygon. These must be greater than zero.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.GetPath(System.Int32)">
      <summary>
        <para>Get a path from the polygon by its index.</para>
        <para>A <c>path</c> is cyclic sequence of line segments between points that define the outline of the polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.The returned value is an ordered array of the points in the path.See Also: <see cref="P:UnityEngine.PolygonCollider2D.pathCount" />, <see cref="M:UnityEngine.PolygonCollider2D.SetPath(System.Int32,UnityEngine.Vector2[])" />.</para>
      </summary>
      <param name="index">The index of the path to retrieve.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.GetTotalPointCount">
      <summary>Return the total number of points in the polygon in all paths.</summary>
      <seealso cref="P:UnityEngine.PolygonCollider2D.points" />
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.SetPath(System.Int32,UnityEngine.Vector2[])">
      <summary>
        <para>Define a path by its constituent points.</para>
        <para>A <c>path</c> is cyclic sequence of line segments between points that define the outline of the polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.See Also: <see cref="P:UnityEngine.PolygonCollider2D.pathCount" />, <see cref="M:UnityEngine.PolygonCollider2D.GetPath(System.Int32)" />.</para>
      </summary>
      <param name="index">Index of the path to set.</param>
      <param name="points">Points that define the path.</param>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.isSupported">
      <summary>Check if ProceduralMaterials are supported on the current platform.</summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.substanceProcessorUsage">
      <summary>Used to specify the Substance engine CPU usage.</summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.animationUpdateRate">
      <summary>
        <para>Set or get the update rate in millisecond of the animated substance.</para>
        <para>An animated substance is a ProceduralMaterial containing a $time input which is automatically generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.cacheSize">
      <summary>
        <para>Set or get the Procedural cache budget.</para>
        <para>When set, this sets the ProceduralMaterial's sleep budget, i.e. the amount of memory the Substance engine will keep allocated to speed up further texture computations. When queried, this returns the ProceduralMaterial's work budget, i.e. the amount of memory the Substance engine will use during the texture computation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.isCachedDataAvailable">
      <summary>Indicates whether cached data is available for this ProceduralMaterial's textures (only relevant for Cache and DoNothingAndCache loading behaviors).</summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.isLoadTimeGenerated">
      <summary>
        <para>Should the ProceduralMaterial be generated at load time?</para>
        <para>If enabled, the ProceduralMaterial will be generated when the scene loads. If disabled, the ProceduralMaterial will not be generated until RebuildTextures or RebuildTexturesImmediately is called.See Also: <see cref="M:UnityEngine.ProceduralMaterial.RebuildTextures" />, <see cref="M:UnityEngine.ProceduralMaterial.RebuildTexturesImmediately" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.isProcessing">
      <summary>Check if the ProceduralTextures from this ProceduralMaterial are currently being rebuilt.</summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.isReadable">
      <summary>
        <para>Set or get the "Readable" flag for a ProceduralMaterial.</para>
        <para>ProceduralTexture.GetPixels32 can ONLY be used with textures generated from a "Readable" ProceduralMaterial whose texture format is set to RAW.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.loadingBehavior">
      <summary>Get ProceduralMaterial loading behavior.</summary>
    </member>
    <member name="P:UnityEngine.ProceduralMaterial.preset">
      <summary>
        <para>Set or get an XML string of "input/value" pairs (setting the preset rebuilds the textures).</para>
        <para>This allows to quickly save the set of a ProceduralMaterial's settings and to export them or to re-apply them later on.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.CacheProceduralProperty(System.String,System.Boolean)">
      <summary>
        <para>Specifies if a named ProceduralProperty should be cached for efficient runtime tweaking.</para>
        <para>Set this to true for all properties that you expect to be tweaking. It will take effect the next time the textures are rebuild, so call <see cref="M:UnityEngine.ProceduralMaterial.RebuildTextures" /> after setting up these flags in order to prepare the cache. The fewer properties have caching enabled, the more efficient rebuilding the textures will be so consider carefully which properties are actually going to be changed. While modified properties are automatically cached for the next rebuild, this cache flag is persistent.See Also: <see cref="M:UnityEngine.ProceduralMaterial.IsProceduralPropertyCached(System.String)" />, <see cref="M:UnityEngine.ProceduralMaterial.ClearCache" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.ClearCache">
      <summary>
        <para>Clear the Procedural cache.</para>
        <para>This frees up all memory used by the cache and sets all properties to not be cached anymore. Use this when you don't expect to make anymore changes to the ProceduralProperties for now.See Also: <see cref="M:UnityEngine.ProceduralMaterial.CacheProceduralProperty(System.String,System.Boolean)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetGeneratedTexture(System.String)">
      <summary>This allows to get a reference to a ProceduralTexture generated by a ProceduralMaterial using its name.</summary>
      <param name="textureName">The name of the ProceduralTexture to get.</param>
      <seealso cref="M:UnityEngine.ProceduralMaterial.GetGeneratedTextures" />
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetGeneratedTextures">
      <summary>Get generated textures.</summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralBoolean(System.String)">
      <summary>
        <para>Get a named Procedural boolean property.</para>
        <para>Used for ProceduralProperties of type Boolean.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralBoolean(System.String,System.Boolean)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralColor(System.String)">
      <summary>
        <para>Get a named Procedural color property.</para>
        <para>Used for ProceduralProperties of types Color3 and Color4.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralColor(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralEnum(System.String)">
      <summary>
        <para>Get a named Procedural enum property.</para>
        <para>Used for ProceduralProperties of type Enum. The function does not return an actual enum but an integer specifying the index of the selected option. The available options are contained in the array <see cref="F:UnityEngine.ProceduralPropertyDescription.enumOptions" />.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralEnum(System.String,System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralFloat(System.String)">
      <summary>
        <para>Get a named Procedural float property.</para>
        <para>Used for ProceduralProperties of type Float.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralFloat(System.String,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions">
      <summary>
        <para>Get an array of descriptions of all the ProceduralProperties this ProceduralMaterial has.</para>
        <para>This can be used to build generic GUI that can be used to edit the properties of any ProceduralMaterial without knowing its properties in advance.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralTexture(System.String)">
      <summary>
        <para>Get a named Procedural texture property.</para>
        <para>Used for ProceduralProperties of type Texture.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralTexture(System.String,UnityEngine.Texture2D)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.GetProceduralVector(System.String)">
      <summary>
        <para>Get a named Procedural vector property.</para>
        <para>Used for ProceduralProperties of types Vector2, Vector3, and Vector4.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralVector(System.String,UnityEngine.Vector4)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.HasProceduralProperty(System.String)">
      <summary>Checks if the ProceduralMaterial has a ProceduralProperty of a given name.</summary>
      <seealso cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.IsProceduralPropertyCached(System.String)">
      <summary>Checks if a named ProceduralProperty is cached for efficient runtime tweaking.</summary>
      <seealso cref="M:UnityEngine.ProceduralMaterial.CacheProceduralProperty(System.String,System.Boolean)" />
      <seealso cref="M:UnityEngine.ProceduralMaterial.ClearCache" />
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.IsProceduralPropertyVisible(System.String)">
      <summary>Checks if a given ProceduralProperty is visible according to the values of this ProceduralMaterial's other ProceduralProperties and to the ProceduralProperty's visibleIf expression.</summary>
      <param name="inputName">The name of the ProceduralProperty whose visibility is evaluated.</param>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.RebuildTextures">
      <summary>Triggers an asynchronous rebuild of this ProceduralMaterial's dirty textures.</summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.RebuildTexturesImmediately">
      <summary>Triggers an immediate (synchronous) rebuild of this ProceduralMaterial's dirty textures.</summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralBoolean(System.String,System.Boolean)">
      <summary>
        <para>Set a named Procedural boolean property.</para>
        <para>Used for ProceduralProperties of type Boolean.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralBoolean(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Set a named Procedural color property.</para>
        <para>Used for ProceduralProperties of types Color3 and Color4.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.SetProceduralColor(System.String,UnityEngine.Color)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralEnum(System.String,System.Int32)">
      <summary>
        <para>Set a named Procedural enum property.</para>
        <para>Used for ProceduralProperties of type Enum. The function does not take an actual enum but an integer specifying the index of the selected option. The available options are contained in the array <see cref="F:UnityEngine.ProceduralPropertyDescription.enumOptions" />.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralEnum(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralFloat(System.String,System.Single)">
      <summary>
        <para>Set a named Procedural float property.</para>
        <para>Used for ProceduralProperties of type Float.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralFloat(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralTexture(System.String,UnityEngine.Texture2D)">
      <summary>
        <para>Set a named Procedural texture property.</para>
        <para>Used for ProceduralProperties of type Texture. The texture needs to be setup with Advanced texture type and Read-Write enabled.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralTexture(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.SetProceduralVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a named Procedural vector property.</para>
        <para>Used for ProceduralProperties of types Vector2, Vector3, and Vector4.See Also: <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralPropertyDescriptions" />, <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralVector(System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ProceduralMaterial.StopRebuilds">
      <summary>Discard all the queued ProceduralMaterial rendering operations that have not started yet.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.componentLabels">
      <summary>The names of the individual components of a Vector2/3/4 ProceduralProperty.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.enumOptions">
      <summary>The available options for a ProceduralProperty of type Enum.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.group">
      <summary>The name of the GUI group. Used to display ProceduralProperties in groups.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.hasRange">
      <summary>
        <para>If true, the Float or Vector property is constrained to values within a specified range.</para>
        <para>For Vector types this applies to all the vector components.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.label">
      <summary>
        <para>The label of the ProceduralProperty. Can contain space and be overall more user-friendly than the 'name' member.</para>
        <para>Used in the Inspector to display the ProceduralProperty.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.maximum">
      <summary>
        <para>If hasRange is true, maximum specifies the maximum allowed value for this Float or Vector property.</para>
        <para>For Vector types this applies to all the vector components.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.minimum">
      <summary>
        <para>If hasRange is true, minimum specifies the minimum allowed value for this Float or Vector property.</para>
        <para>For Vector types this applies to all the vector components.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.name">
      <summary>The name of the ProceduralProperty. Used to get and set the values.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.step">
      <summary>
        <para>Specifies the step size of this Float or Vector property. Zero is no step.</para>
        <para>For Vector types this applies to all the vector components.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyDescription.type">
      <summary>The <see cref="T:UnityEngine.ProceduralPropertyType" /> describes what type of property this is.</summary>
    </member>
    <member name="P:UnityEngine.ProceduralTexture.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ProceduralTexture.hasAlpha">
      <summary>Check whether the ProceduralMaterial that generates this ProceduralTexture is set to an output format with an alpha channel.</summary>
    </member>
    <member name="M:UnityEngine.ProceduralTexture.GetPixels32(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Grab pixel values from a ProceduralTexture.</para>
        <para>This only works for ProceduralMaterial instances that have been marked as "Readable" and whose texture format is set to RAW.The correct sequence to use GetPixels32() is: - Set the ProceduralMaterial "Readable" flag using <see cref="P:UnityEngine.ProceduralMaterial.isReadable" /> - Rebuild the ProceduralMaterial's textures using <see cref="M:UnityEngine.ProceduralMaterial.RebuildTexturesImmediately" /> - Call GetPixels32().See Also: <see cref="P:UnityEngine.ProceduralMaterial.isReadable" />, <see cref="M:UnityEngine.ProceduralMaterial.RebuildTexturesImmediately" />, <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />.</para>
      </summary>
      <param name="x">X-coord of the top-left corner of the rectangle to grab.</param>
      <param name="y">Y-coord of the top-left corner of the rectangle to grab.</param>
      <param name="blockWidth">Width of rectangle to grab.</param>
      <param name="blockHeight">Height of the rectangle to grab. Get the pixel values from a rectangular area of a ProceduralTexture into an array. The block is specified by its x,y offset in the texture and by its width and height. The block is "flattened" into the array by scanning the pixel values across rows one by one.</param>
    </member>
    <member name="M:UnityEngine.ProceduralTexture.GetProceduralOutputType">
      <summary>The output type of this ProceduralTexture.</summary>
    </member>
    <member name="P:UnityEngine.Profiler.enableBinaryLog">
      <summary>
        <para>Sets profiler output file in built players.</para>
        <para>If binary log is enabled, a file is generated named "&lt;logfile&gt;.data" which holds binary data for the profile This becomes a large file, so only enable it for a few frames on webplayers the file is placed next to the log file See Also: Profiler.enableBinaryLog.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiler.enabled">
      <summary>
        <para>Enables the Profiler.</para>
        <para>Can be used with Profiler.logFile to log profiling information in built players.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiler.logFile">
      <summary>
        <para>Sets profiler output file in built players.</para>
        <para>Use it with Profiler.enabled to produce profiling information outside of the Unity Editor. Setting this property is not supported in the WebPlayer. The WebPlayer will output the profiling information next to your webplayer logfile. This produces a file with framerate See Also: Profiler.enabled.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiler.maxNumberOfSamplesPerFrame">
      <summary>
        <para>Resize the profiler sample buffers to allow the desired amount of samples per thread.</para>
        <para>If the scene is very complex, the number of samples recorded for one frame can surpass the reserved number of samples. The preallocated buffers can then be resized using this API. If dynamic resizing is desired, set this value to -1. The default value for this is 512K samples per thread. The max value is 8M samples per thread.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiler.usedHeapSize">
      <summary>
        <para>uint Size of the used heap in bytes, (or 0 if the profiler is disabled).</para>
        <para>Heap size used by the program.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.AddFramesFromFile(System.String)">
      <summary>
        <para>Displays the recorded profiledata in the profiler.</para>
        <para>Use the name of the text file, ".data" will be appended.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.BeginSample(System.String)">
      <summary>
        <para>Begin profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy. Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.BeginSample(System.String,UnityEngine.Object)">
      <summary>
        <para>Begin profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy. Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.EndSample">
      <summary>
        <para>End profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.GetMonoHeapSize">
      <summary>
        <para>Returns the size of the mono heap.</para>
        <para>This is the reserved system memory that Mono is using for allocations.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.GetMonoUsedSize">
      <summary>
        <para>Returns the used size from mono.</para>
        <para>This is the amount of allocated memory for non collected objects in Mono memory always call GC.Collect before this call, as non referenced objects will still take up space untill they are collected. If not Collecting, this will display an ever growing number untill Collect is called elsewhere.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiler.GetRuntimeMemorySize(UnityEngine.Object)">
      <summary>
        <para>Returns the runtime memory usage of the resource.</para>
        <para>This has been implemented for the following resource types: Mesh, Texture, Audio, Animation and Materials Only available in development players and editor.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.aspectRatio">
      <summary>
        <para>The aspect ratio of the projection.</para>
        <para>This is projection width divided by height. An aspect ratio of 1.0 makes the projection square; a ratio of 2.0 makes it twice as wide than high.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.farClipPlane">
      <summary>
        <para>The far clipping plane distance.</para>
        <para>The projector will not affect anything that is further than this distance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.fieldOfView">
      <summary>
        <para>The field of view of the projection in degrees.</para>
        <para>This is the vertical field of view; horizontal FOV varies depending on the <see cref="P:UnityEngine.Projector.aspectRatio" />. Field of view is ignored when projector is orthographic (see <see cref="P:UnityEngine.Projector.orthographic" />).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.ignoreLayers">
      <summary>
        <para>Which object layers are ignored by the projector.</para>
        <para>See layer mask.By default this is zero - i.e. no layers are ignored. Each set bit in <c>ignoreLayers</c> will make this layer not affected by the projector.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.material">
      <summary>
        <para>The material that will be projected onto every object.</para>
        <para>Projector does nothing if it has no material set up. The Standard Assets package contains an example of Projector's material in <c>Blob-Shadow</c> folder.See Also: projector component, <see cref="T:UnityEngine.Material" /> class.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.nearClipPlane">
      <summary>
        <para>The near clipping plane distance.</para>
        <para>The projector will not affect anything that is nearer than this distance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.orthographic">
      <summary>
        <para>Is the projection orthographic (<c>true</c>) or perspective (<c>false</c>)?</para>
        <para>When orthographic is <c>true</c>, projection is defined by <see cref="P:UnityEngine.Projector.orthographicSize" />. When orthographic is <c>false</c>, projection is defined by <see cref="P:UnityEngine.Projector.fieldOfView" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.orthographicSize">
      <summary>
        <para>Projection's half-size when in orthographic mode.</para>
        <para>This is half of the vertical size of the projection volume. Horizontal projection size varies depending on <see cref="P:UnityEngine.Projector.aspectRatio" />. Orthographic size is ignored when projection is not orthographic (see <see cref="P:UnityEngine.Projector.orthographic" />).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.activeColorSpace">
      <summary>Active color space.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.anisotropicFiltering">
      <summary>Global anisotropic filtering mode.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.antiAliasing">
      <summary>
        <para>Set The AA Filtering option.</para>
        <para>The AntiAliazing filter can be set to either 0,2,4 or 8. This coresponds to the number of multisamples used per pixel.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.billboardsFaceCameraPosition">
      <summary>If enabled, billboards will face towards camera position rather than camera orientation.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.blendWeights">
      <summary>
        <para>Blend weights.</para>
        <para>The Blend weights can be set to either One Bone, Two Bones or Four Bones.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.desiredColorSpace">
      <summary>Desired color space.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.lodBias">
      <summary>
        <para>Global multiplier for the LOD's switching distance.</para>
        <para>A larger value leads to a longer view distance before a lower resolution LOD is picked.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.masterTextureLimit">
      <summary>
        <para>A texture size limit applied to all textures.</para>
        <para>Setting this to one uses the first mipmap of each texture (so all textures are half size), setting this to two uses the second mipmap of each texture (so all textures are quarter size), etc.. This can be used to decrease video memory requirements on low-end computers. The default value is zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.maximumLODLevel">
      <summary>A maximum LOD level. All LOD groups.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.maxQueuedFrames">
      <summary>
        <para>Maximum number of frames queued up by graphics driver.</para>
        <para>Graphics drivers can queue up frames to be rendered. When CPU has much less work to do than the graphics card, is it possible for this queue to become quite large. In those cases, user's input will "lag behind" what is on the screen.Use QualitySettings.maxQueuedFrames to limit maximum number of frames that are queued. The default value is -1, which does not limit the queue.Note that using a low maxQueuedFrames value can lower your FPS count, because CPU will be waiting until the graphics card will finish rendering previous frames. But you will get lower input latency.Currently maxQueuedFrames is only implemented in Direct3D renderer; it will be ignored in OpenGL.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.names">
      <summary>The indexed list of available Quality Settings.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.particleRaycastBudget">
      <summary>Budget for how many ray casts can be performed per frame for approximate collision testing.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.pixelLightCount">
      <summary>
        <para>The maximum number of pixel lights that should affect any object.</para>
        <para>If there are more lights illuminating an object, the dimmest ones will be rendered as vertex lights.Use this from scripting if you want to have finer control than offered by quality settings levels.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.realtimeReflectionProbes">
      <summary>
        <para>Enables realtime reflection probes.</para>
        <para>If disabled, realtime reflection probes will not be baked.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascade2Split">
      <summary>The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascade4Split">
      <summary>The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascades">
      <summary>Number of cascades to use for directional light shadows.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowDistance">
      <summary>Shadow drawing distance.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowNearPlaneOffset">
      <summary>
        <para>Offset shadow frustum near plane.</para>
        <para>Offset shadow near plane to account for large triangles being distorted by shadow pancaking.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowProjection">
      <summary>Directional light shadow projection.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.softVegetation">
      <summary>
        <para>Use a two-pass shader for the vegetation in the terrain engine.</para>
        <para>If enabled, vegetation will have smoothed edges, if disabled all plants will have hard edges but are rendered roughly twice as fast.See Also: Quality Settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.vSyncCount">
      <summary>
        <para>The VSync Count.</para>
        <para>The number of VSyncs that should pass between each frame. Use 'Don't Sync' (0) to not wait for VSync. Value must be 0, 1 or 2.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)">
      <summary>
        <para>Decrease the current quality level.</para>
        <para>
          <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" /> and <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" /> functions only apply anti-aliasing if applyExpensiveChanges is true.See Also: <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" />, Quality Settings.</para>
      </summary>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
    </member>
    <member name="M:UnityEngine.QualitySettings.DecreaseLevel">
      <summary>
        <para>Decrease the current quality level.</para>
        <para>
          <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" /> and <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" /> functions only apply anti-aliasing if applyExpensiveChanges is true.See Also: <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" />, Quality Settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.QualitySettings.GetQualityLevel">
      <summary>Returns the current graphics quality level.</summary>
      <seealso cref="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)">
      <summary>
        <para>Increase the current quality level.</para>
        <para>
          <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" /> and <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" /> functions only apply anti-aliasing if applyExpensiveChanges is true.See Also: <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" />, Quality Settings.</para>
      </summary>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
    </member>
    <member name="M:UnityEngine.QualitySettings.IncreaseLevel">
      <summary>
        <para>Increase the current quality level.</para>
        <para>
          <see cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)" /> and <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" /> functions only apply anti-aliasing if applyExpensiveChanges is true.See Also: <see cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)" />, Quality Settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32,System.Boolean)">
      <summary>
        <para>Sets a new graphics quality level.</para>
        <para>Note that changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It's fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied.When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It's best to query the available quality settings and use the returned index.See Also: <see cref="M:UnityEngine.QualitySettings.GetQualityLevel" />.</para>
      </summary>
      <param name="index">Quality index to set.</param>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
    </member>
    <member name="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32)">
      <summary>
        <para>Sets a new graphics quality level.</para>
        <para>Note that changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It's fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied.When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It's best to query the available quality settings and use the returned index.See Also: <see cref="M:UnityEngine.QualitySettings.GetQualityLevel" />.</para>
      </summary>
      <param name="index">Quality index to set.</param>
    </member>
    <member name="P:UnityEngine.Quaternion.identity">
      <summary>
        <para>The identity rotation (Read Only).</para>
        <para>This quaternion corresponds to "no rotation" - the object is perfectly aligned with the world or parent axes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Quaternion.eulerAngles">
      <summary>
        <para>Returns the euler angle representation of the rotation.</para>
        <para>A rotation that rotates euler.z degrees around the z axis, euler.x degrees around the x axis, and euler.y degrees around the y axis (in that order).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Quaternion.w">
      <summary>W component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="F:UnityEngine.Quaternion.x">
      <summary>X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="F:UnityEngine.Quaternion.y">
      <summary>Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="F:UnityEngine.Quaternion.z">
      <summary>Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Constructs new Quaternion with given x,y,z,w components.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set x, y, z and w components of an existing Quaternion.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.SetFromToRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Creates a rotation which rotates from <c>fromDirection</c> to <c>toDirection</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>The result is applied to this quaternion If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c>, assuming these vectors are orthogonal. Logs an error if the forward direction is zero.See Also: <see cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />.</para>
      </summary>
      <param name="view">The direction to look in.</param>
      <param name="up">The vector that defines in which direction up is.</param>
    </member>
    <member name="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>The result is applied to this quaternion If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c>, assuming these vectors are orthogonal. Logs an error if the forward direction is zero.See Also: <see cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />.</para>
      </summary>
      <param name="view">The direction to look in.</param>
    </member>
    <member name="M:UnityEngine.Quaternion.ToAngleAxis(System.Single@,UnityEngine.Vector3@)">
      <summary>Converts a rotation to angle-axis representation (angles in degrees).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.ToString">
      <summary>Returns a nicely formatted string of the Quaternion.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.ToString(System.String)">
      <summary>Returns a nicely formatted string of the Quaternion.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Angle(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>Returns the angle in degrees between two rotations <c>a</c> and <c>b</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.AngleAxis(System.Single,UnityEngine.Vector3)">
      <summary>Creates a rotation which rotates <c>angle</c> degrees around <c>axis</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Dot(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>The dot product between two rotations.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Euler(System.Single,System.Single,System.Single)">
      <summary>Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Euler(UnityEngine.Vector3)">
      <summary>Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation which rotates from <c>fromDirection</c> to <c>toDirection</c>.</para>
        <para>Usually you use this to rotate a transform so that one of its axes eg. the y-axis - follows a target direction <c>toDirection</c> in world space.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Inverse(UnityEngine.Quaternion)">
      <summary>Returns the Inverse of <c>rotation</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Interpolates between <c>a</c> and <c>b</c> by <c>t</c> and normalizes the result afterwards. The parameter <c>t</c> is clamped to the range [0, 1].</para>
        <para>This is faster than Slerp but looks worse if the rotations are far apart.</para>
        <para>
          <see cref="M:UnityEngine.Quaternion.LerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />.</para>
      </summary>
      <seealso cref="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />
    </member>
    <member name="M:UnityEngine.Quaternion.LerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Interpolates between <c>a</c> and <c>b</c> by <c>t</c> and normalizes the result afterwards. The parameter <c>t</c> is not clamped.</para>
        <para>This is faster than Slerp but looks worse if the rotations are far apart.See Also: <see cref="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />, <see cref="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>Returns the computed quaternion. If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c> if these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="forward">The direction to look in.</param>
      <param name="upwards">The vector that defines in which direction up is.</param>
      <seealso cref="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>Returns the computed quaternion. If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c> if these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="forward">The direction to look in.</param>
      <seealso cref="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Quaternion.RotateTowards(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Rotates a rotation <c>from</c> towards <c>to</c>.</para>
        <para>The <c>from</c> quaternion is rotated towards <c>to</c> by an angular step of <c>maxDegreesDelta</c> (but note that the rotation will not overshoot). Negative values of <c>maxDegreesDelta</c> will move away from <c>to</c> until the rotation is exactly the opposite direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>Spherically interpolates between <c>a</c> and <c>b</c> by t. The parameter <c>t</c> is clamped to the range [0, 1].</summary>
      <seealso cref="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />
      <seealso cref="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />
    </member>
    <member name="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>Spherically interpolates between <c>a</c> and <c>b</c> by t. The parameter <c>t</c> is not clamped.</summary>
      <seealso cref="M:UnityEngine.Quaternion.LerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />
      <seealso cref="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)" />
    </member>
    <member name="M:UnityEngine.Quaternion.operator !=(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>
        <para>Are two quaternions different from each other?</para>
        <para>This function tests whether dot product of two quaternions is less than 1.0.Note that because quaternions can represent rotations that are up to two full revolutions (720 degrees), this comparison can return <c>true</c> even if resulting rotations look the same.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.operator *(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>
        <para>Combines rotations <c>lhs</c> and <c>rhs</c>.</para>
        <para>Rotating by the product <c>lhs</c> * <c>rhs</c> is the same as applying the two rotations in sequence: <c>lhs</c> first and then <c>rhs</c>, relative to the reference frame resulting from <c>lhs</c> rotation. Note that this means rotations are not commutative, so <c>lhs * rhs</c> does not give the same rotation as <c>rhs * lhs</c>.</para>
      </summary>
      <param name="lhs">Left-hand side quaternion.</param>
      <param name="rhs">Right-hand side quaternion.</param>
    </member>
    <member name="M:UnityEngine.Quaternion.operator *(UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Rotates the point <c>point</c> with <c>rotation</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.operator ==(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>
        <para>Are two quaternions equal to each other?</para>
        <para>This function tests whether dot product of two quaternions is close to 1.0.Note that because quaternions can represent rotations that are up to two full revolutions (720 degrees), this comparison can return <c>false</c> even if resulting rotations look the same.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Random.insideUnitCircle">
      <summary>Returns a random point inside a circle with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.insideUnitSphere">
      <summary>Returns a random point inside a sphere with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.onUnitSphere">
      <summary>Returns a random point on the surface of a sphere with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.rotation">
      <summary>Returns a random rotation (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.rotationUniform">
      <summary>Returns a random rotation with uniform distribution (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.seed">
      <summary>
        <para>Sets the seed for the random number generator.</para>
        <para>The random number generator is not truly random but produces numbers in a preset sequence (the values in the sequence "jump" around the range in such a way that they appear random for most purposes).The point in the sequence where a particular run of pseudo-random values begins is selected using an integer called the <c>seed</c> value. The seed is normally set from some arbitrary value like the system clock before the random number functions are used. This prevents the same run of values from occurring each time a game is played and thus avoids predictable gameplay. However, it is sometimes useful to produce the same run of pseudo-random values on demand by setting the seed yourself.You might set your own seed, for example, when you generate a game level procedurally. You can use randomly-chosen elements to make the scene look arbitrary and natural but set the seed to a preset value before generating. This will make sure that the same "random" pattern is produced each time the game is played. This can often be an effective way to reduce a game's storage requirements - you can generate as many levels as you like procedurally and store each one using nothing more than an integer seed value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Random.value">
      <summary>
        <para>Returns a random number between 0.0 [inclusive] and 1.0 [inclusive] (Read Only).</para>
        <para>Both 0.0 and 1.0 may be returned by this property. This behaviour is different to that of many other random number generators which return a value less than but never exactly equal to 1.0.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Random.Range(System.Single,System.Single)">
      <summary>Returns a random float number between and <c>min</c> [inclusive] and <c>max</c> [inclusive] (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Random.Range(System.Int32,System.Int32)">
      <summary>
        <para>Returns a random integer number between <c>min</c> [inclusive] and <c>max</c> [exclusive] (Read Only).</para>
        <para>If <c>max</c> equals <c>min</c>, <c>min</c> will be returned. The returned value will never be <c>max</c> unless <c>min</c> equals <c>max</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Ray.direction">
      <summary>
        <para>The direction of the ray.</para>
        <para>Direction is always a normalized vector. If you assign a vector of non unit length, it will be normalized.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Ray.origin">
      <summary>The origin point of the ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.#ctor(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Creates a ray starting at <c>origin</c> along <c>direction</c>.</summary>
    </member>
    <member name="M:UnityEngine.Ray.GetPoint(System.Single)">
      <summary>Returns a point at <c>distance</c> units along the ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.ToString">
      <summary>Returns a nicely formatted string for this ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.ToString(System.String)">
      <summary>Returns a nicely formatted string for this ray.</summary>
    </member>
    <member name="P:UnityEngine.Ray2D.direction">
      <summary>The direction of the ray in world space.</summary>
    </member>
    <member name="P:UnityEngine.Ray2D.origin">
      <summary>The starting point of the ray in world space.</summary>
    </member>
    <member name="M:UnityEngine.Ray2D.GetPoint(System.Single)">
      <summary>
        <para>Get a point that lies a given distance along a ray.</para>
        <para>The distance is measured away from the ray's origin along its direction.See Also: <see cref="P:UnityEngine.Ray2D.origin" />, <see cref="P:UnityEngine.Ray2D.direction" />.</para>
      </summary>
      <param name="distance">Distance of the desired point along the path of the ray.</param>
    </member>
    <member name="P:UnityEngine.RaycastHit.barycentricCoordinate">
      <summary>
        <para>The barycentric coordinate of the triangle we hit.</para>
        <para>This lets you interpolate any of the vertex data along the 3 axes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.collider">
      <summary>
        <para>The <see cref="T:UnityEngine.Collider" /> that was hit.</para>
        <para>This property is null if the ray hit nothing and not-null if it hit a Collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.distance">
      <summary>The distance from the ray's origin to the impact point.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.lightmapCoord">
      <summary>
        <para>The uv lightmap coordinate at the impact point.</para>
        <para>This can be used for sampling the lightmap and setting the sampled color value as the material color of a moving object to make it roughly match the baked lighting.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.normal">
      <summary>The normal of the surface the ray hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.point">
      <summary>The impact point in world space where the ray hit the collider.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.rigidbody">
      <summary>The <see cref="T:UnityEngine.Rigidbody" /> of the collider that was hit. If the collider is not attached to a rigidbody then it is <c>null</c>.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.textureCoord">
      <summary>
        <para>The uv texture coordinate at the impact point.</para>
        <para>This can be used for 3D texture painting or drawing bullet marks. If the collider is no mesh collider, zero <see cref="T:UnityEngine.Vector2" /> will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.textureCoord2">
      <summary>
        <para>The secondary uv texture coordinate at the impact point.</para>
        <para>This can be used for 3D texture painting or drawing bullet marks. If the collider is not a mesh collider, Vector2.zero will be returned. If the mesh contains no secondary uv set, the uv of the primary uv set will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.transform">
      <summary>The <see cref="T:UnityEngine.Transform" /> of the rigidbody or collider that was hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.triangleIndex">
      <summary>
        <para>The index of the triangle that was hit.</para>
        <para>Triangle index is only valid if the collider that was hit is a <see cref="T:UnityEngine.MeshCollider" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.centroid">
      <summary>
        <para>The centroid of the primitive used to perform the cast.</para>
        <para>When the <see cref="T:UnityEngine.RaycastHit2D" /> is returned from line or ray casting, the centroid is identical to the return point property however when using cast methods that use a geometry shape (as opposed to a simple point) such as circle or box casting, the <c>centroid</c> is the center of the respective shape when it is in contact with the returned point.The <c>centroid</c> is useful in determining the position the cast shape should be for it to collider at the contact point. Note that the point takes into account any rotation specified for the shape when it was cast.See Also: See Also: <see cref="P:UnityEngine.RaycastHit2D.point" />, <see cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)" />, <see cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" /> &amp; <see cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.collider">
      <summary>
        <para>The collider hit by the ray.</para>
        <para>This can be useful if the hit object has more than one collider - this property can be used to determine the specific collider rather than just the object.Note that some functions that return a single RaycastHit2D will leave the collider as NULL which indicates nothing hit. RaycastHit2D implements an implicit conversion operator converting to bool which checks this property allowing it to be used as a simple condition check for whether a hit occurred or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.distance">
      <summary>The distance from the ray origin to the impact point.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.fraction">
      <summary>
        <para>Fraction of the distance along the ray that the hit occurred.</para>
        <para>If the ray's direction vector is normalised then this value is simply the distance between the origin and the hit point. If the direction is not normalised then this distance is expressed as a "fraction" (which could be greater than 1) of the vector's magnitude.See Also: <see cref="P:UnityEngine.RaycastHit2D.point" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.normal">
      <summary>
        <para>The normal vector of the surface hit by the ray.</para>
        <para>The <c>normal vector</c> of a surface is the vector that points outward perpenidularly at a given point on that surface. This vector can be useful in raycasting as a way to determine reflections or ricochets from projectiles or to align a character so that it stands upright on the surface.Note that if a hit occurs starting inside a collider then the collision normal will be simply the opposite direction of the line/ray query.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.point">
      <summary>
        <para>The point in world space where the ray hit the collider's surface.</para>
        <para>The exact point of contact can be useful for positioning graphic effects (such as explosion or blood splatters) and for determining which specific part of an object was hit.See Also: <see cref="P:UnityEngine.RaycastHit2D.fraction" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.rigidbody">
      <summary>The Rigidbody2D attached to the object that was hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.transform">
      <summary>The Transform of the object that was hit.</summary>
    </member>
    <member name="P:UnityEngine.Rect.center">
      <summary>Center coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.height">
      <summary>Height of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.max">
      <summary>
        <para>Upper right corner of the rectangle.</para>
        <para>Changing this value will preserve the left and bottom side of rectangle (so <see cref="P:UnityEngine.Rect.width" /> and <see cref="P:UnityEngine.Rect.height" /> will change as well).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.min">
      <summary>
        <para>Lower left corner of the rectangle.</para>
        <para>Changing this value will preserve the right and top side of rectangle (so <see cref="P:UnityEngine.Rect.width" /> and <see cref="P:UnityEngine.Rect.height" /> will change as well).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.position">
      <summary>
        <para>The top left coordinates of the rectangle.</para>
        <para>This is the <see cref="P:UnityEngine.Rect.x" /> and <see cref="P:UnityEngine.Rect.y" /> coordinates in a combined Vector2.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.size">
      <summary>
        <para>The size of the rectangle.</para>
        <para>This is the <see cref="P:UnityEngine.Rect.width" /> and <see cref="P:UnityEngine.Rect.height" /> in a combined Vector2.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.width">
      <summary>Width of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.x">
      <summary>Left coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.xMax">
      <summary>
        <para>Right coordinate of the rectangle.</para>
        <para>Changing this value will preserve left side of rectangle (so <see cref="P:UnityEngine.Rect.width" /> will change as well).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.xMin">
      <summary>
        <para>Left coordinate of the rectangle.</para>
        <para>Changing this value will preserve right side of rectangle (so <see cref="P:UnityEngine.Rect.width" /> will change as well).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.y">
      <summary>Top coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.yMax">
      <summary>
        <para>Bottom coordinate of the rectangle.</para>
        <para>Changing this value will preserve top side of rectangle (so <see cref="P:UnityEngine.Rect.height" /> will change as well).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.yMin">
      <summary>
        <para>Top coordinate of the rectangle.</para>
        <para>Changing this value will preserve bottom side of rectangle (so <see cref="P:UnityEngine.Rect.height" /> will change as well).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates a new rectangle.</summary>
    </member>
    <member name="M:UnityEngine.Rect.#ctor(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Creates a rectangle given a size and position.</para>
        <para>This form of the constructor is convenient when you are already working with Vector2 values.</para>
      </summary>
      <param name="position">The position of the top-left corner.</param>
      <param name="size">The width and height.</param>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector2)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector3)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector3,System.Boolean)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
      <param name="allowInverse">Does the test allow the Rect's width and height to be negative?</param>
    </member>
    <member name="M:UnityEngine.Rect.Overlaps(UnityEngine.Rect)">
      <summary>Returns true if the other rectangle overlaps this one. If <c>allowInverse</c> is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="other">Other rectangle to test overlapping with.</param>
    </member>
    <member name="M:UnityEngine.Rect.Overlaps(UnityEngine.Rect,System.Boolean)">
      <summary>Returns true if the other rectangle overlaps this one. If <c>allowInverse</c> is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="other">Other rectangle to test overlapping with.</param>
      <param name="allowInverse">Does the test allow the Rects' widths and heights to be negative?</param>
    </member>
    <member name="M:UnityEngine.Rect.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set components of an existing Rect.</summary>
    </member>
    <member name="M:UnityEngine.Rect.ToString">
      <summary>Returns a nicely formatted string for this Rect.</summary>
    </member>
    <member name="M:UnityEngine.Rect.ToString(System.String)">
      <summary>Returns a nicely formatted string for this Rect.</summary>
    </member>
    <member name="M:UnityEngine.Rect.MinMaxRect(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates a rectangle from min/max coordinate values.</summary>
    </member>
    <member name="M:UnityEngine.Rect.NormalizedToPoint(UnityEngine.Rect,UnityEngine.Vector2)">
      <summary>Returns a point inside a rectangle, given normalized coordinates.</summary>
      <param name="rectangle">Rectangle to get a point inside.</param>
      <param name="normalizedRectCoordinates">Normalized coordinates to get a point for.</param>
    </member>
    <member name="M:UnityEngine.Rect.PointToNormalized(UnityEngine.Rect,UnityEngine.Vector2)">
      <summary>Returns the normalized coordinates cooresponding the the point.</summary>
      <param name="rectangle">Rectangle to get normalized coordinates inside.</param>
      <param name="point">A point inside the rectangle to get normalized coordinates for.</param>
    </member>
    <member name="M:UnityEngine.Rect.operator !=(UnityEngine.Rect,UnityEngine.Rect)">
      <summary>Returns true if the rectangles are different.</summary>
    </member>
    <member name="M:UnityEngine.Rect.operator ==(UnityEngine.Rect,UnityEngine.Rect)">
      <summary>Returns true if the rectangles are the same.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.bottom">
      <summary>Bottom edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.horizontal">
      <summary>Shortcut for left + right. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.left">
      <summary>Left edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.right">
      <summary>Right edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.top">
      <summary>Top edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.vertical">
      <summary>Shortcut for top + bottom. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.#ctor">
      <summary>Creates a new rectangle with offsets.</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Creates a new rectangle with offsets.</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.Add(UnityEngine.Rect)">
      <summary>Add the border offsets to a <c>rect</c>.</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.Remove(UnityEngine.Rect)">
      <summary>Remove the border offsets from a <c>rect</c>.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchoredPosition">
      <summary>
        <para>The position of the pivot of this RectTransform relative to the anchor reference point.</para>
        <para>The anchor reference point is where the anchors are. If the anchors are not together, the four anchor positions are interpolated according to the pivot placement.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchoredPosition3D">
      <summary>
        <para>The 3D position of the pivot of this RectTransform relative to the anchor reference point.</para>
        <para>The anchor reference point is where the anchors are. If the anchors are not together, the four anchor positions are interpolated according to the pivot placement.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchorMax">
      <summary>The normalized position in the parent RectTransform that the upper right corner is anchored to.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchorMin">
      <summary>The normalized position in the parent RectTransform that the lower left corner is anchored to.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.offsetMax">
      <summary>The offset of the upper right corner of the rectangle relative to the upper right anchor.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.offsetMin">
      <summary>The offset of the lower left corner of the rectangle relative to the lower left anchor.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.pivot">
      <summary>The normalized position in this RectTransform that it rotates around.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.rect">
      <summary>The calculated rectangle in the local space of the <see cref="T:UnityEngine.Transform" />.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.sizeDelta">
      <summary>
        <para>The size of this RectTransform relative to the distances between the anchors.</para>
        <para>If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectTransform.GetLocalCorners(UnityEngine.Vector3[])">
      <summary>Get the corners of the calculated rectangle in the local space of its Transform.</summary>
      <param name="fourCornersArray">Array that corners should be filled into.</param>
    </member>
    <member name="M:UnityEngine.RectTransform.GetWorldCorners(UnityEngine.Vector3[])">
      <summary>Get the corners of the calculated rectangle in world space.</summary>
      <param name="fourCornersArray">Array that corners should be filled into.</param>
    </member>
    <member name="M:UnityEngine.RectTransform.SetInsetAndSizeFromParentEdge(UnityEngine.RectTransform.Edge,System.Single,System.Single)">
      <summary>
        <para>Set the distance of this rectangle relative to a specified edge of the parent rectangle, while also setting its size.</para>
        <para>Calling this method sets both the anchors, anchoredPosition, and sizeDelta, though only either the horizontal or vertical components, depending on which edge is specified for the inset.The method can particularly be useful when scripting layout behaviours, since it makes it simple to specify positions relative to the parent edges without needing to be concerned with anchoring functionality.</para>
      </summary>
      <param name="edge">The edge of the parent rectangle to inset from.</param>
      <param name="inset">The inset distance.</param>
      <param name="size">The size of the rectangle along the same direction of the inset.</param>
    </member>
    <member name="M:UnityEngine.RectTransform.SetSizeWithCurrentAnchors(UnityEngine.RectTransform.Axis,System.Single)">
      <summary>
        <para>Makes the RectTransform calculated rect be a given size on the specified axis.</para>
        <para>This method produces the given size with the current anchoring. If the parent RectTransform changes size, the size of the rect may change. If the size is meant to stay, either the RectTransform anchors should be set not to stretch, or this method should be invoked again whenever the parent size changes.</para>
      </summary>
      <param name="axis">The axis to specify the size along.</param>
      <param name="size">The desired size along the specified axis.</param>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.FlipLayoutAxes(UnityEngine.RectTransform,System.Boolean,System.Boolean)">
      <summary>
        <para>Flips the horizontal and vertical axes of the RectTransform size and alignment, and optionally its children as well.</para>
        <para>This swaps the horizontal and vertical axis in the size and alignment of the RectTransform. This can also be thought of as a diagonal flip. Any actual content such as images or text will not be flipped or rotated but may be resized and aligned differently.An example usage is to instantiate a control designed for alignment along one axis (like a horizontal slider) and flip the axes so the layout becomes suitable for use along the other axis (like a vertical slider).When used with the recursive argument set to true, the children are always flipped with the keepPositioning option set to false so that they properly follow the flip of the parent.</para>
      </summary>
      <param name="rect">The RectTransform to flip.</param>
      <param name="keepPositioning">Flips around the pivot if true. Flips within the parent rect if false.</param>
      <param name="recursive">Flip the children as well?</param>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.FlipLayoutOnAxis(UnityEngine.RectTransform,System.Int32,System.Boolean,System.Boolean)">
      <summary>
        <para>Flips the alignment of the RectTransform along the horizontal or vertical axis, and optionally its children as well.</para>
        <para>This flips the alignment of the RectTransform. Any actual content such as images or text will not be flipped but may aligned differently. An example usage is to instantiate a control designed in a left to right manner (like a horizontal slider where 0 is to the left) and flip it horizontally so the layout becomes suitable for use in the opposite direction (like a horizontal slider where 0 is to the right).When used with the recursive argument set to true, the children are always flipped with the keepPositioning option set to false so that they properly follow the flip of the parent.</para>
      </summary>
      <param name="rect">The RectTransform to flip.</param>
      <param name="axis">The axis to flip along. 0 is horizontal and 1 is vertical.</param>
      <param name="keepPositioning">Flips around the pivot if true. Flips within the parent rect if false.</param>
      <param name="recursive">Flip the children as well?</param>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.PixelAdjustPoint(UnityEngine.Vector2,UnityEngine.Transform,UnityEngine.Canvas)">
      <summary>Convert a given point in screen space into a pixel correct point.</summary>
      <returns>Pixel adjusted point.</returns>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.PixelAdjustRect(UnityEngine.RectTransform,UnityEngine.Canvas)">
      <summary>Given a rect transform, return the corner points in pixel accurate coordinates.</summary>
      <returns>Pixel adjusted rect.</returns>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.RectangleContainsScreenPoint(UnityEngine.RectTransform,UnityEngine.Vector2,UnityEngine.Camera)">
      <summary>Does the RectTransform contain the screen point as seen from the given camera?</summary>
      <param name="rect">The RectTransform to test with.</param>
      <param name="screenPoint">The screen point to test.</param>
      <param name="cam">The camera from which the test is performed from.</param>
      <returns>True if the point is inside the rectangle.</returns>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(UnityEngine.RectTransform,UnityEngine.Vector2,UnityEngine.Camera,UnityEngine.Vector2@)">
      <summary>
        <para>Transform a screen space point to a position in the local space of a RectTransform that is on the plane of its rectangle.</para>
        <para>The cam parameter should be the camera associated with the screen point. For a RectTransform in a Canvas set to Screen Space - Overlay mode, the cam parameter should be null.When ScreenPointToLocalPointInRectangle is used from within an event handler that provides a PointerEventData object, the correct camera can be obtained by using PointerEventData.enterEventData (for hover functionality) or <see cref="P:UnityEngine.EventSystems.PointerEventData.pressEventCamera" /> (for click functionality). This will automatically use the correct camera (or null) for the given event.</para>
      </summary>
      <param name="rect">The RectTransform to find a point inside.</param>
      <param name="screenPoint">Screen space position.</param>
      <param name="cam">The camera associated with the screen space position.</param>
      <param name="localPoint">Point in local space of the rect transform.</param>
      <returns>Returns true if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.</returns>
    </member>
    <member name="M:UnityEngine.RectTransformUtility.ScreenPointToWorldPointInRectangle(UnityEngine.RectTransform,UnityEngine.Vector2,UnityEngine.Camera,UnityEngine.Vector3@)">
      <summary>
        <para>Transform a screen space point to a position in world space that is on the plane of the given RectTransform.</para>
        <para>The cam parameter should be the camera associated with the screen point. For a RectTransform in a Canvas set to Screen Space - Overlay mode, the cam parameter should be null.When ScreenPointToWorldPointInRectangle is used from within an event handler that provides a PointerEventData object, the correct camera can be obtained by using PointerEventData.enterEventData (for hover functionality) or <see cref="P:UnityEngine.EventSystems.PointerEventData.pressEventCamera" /> (for click functionality). This will automatically use the correct camera (or null) for the given event.</para>
      </summary>
      <param name="rect">The RectTransform to find a point inside.</param>
      <param name="screenPoint">Screen space position.</param>
      <param name="cam">The camera associated with the screen space position.</param>
      <param name="worldPoint">Point in world space.</param>
      <returns>Returns true if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.</returns>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.backgroundColor">
      <summary>
        <para>The color with which the texture of reflection probe will be cleared.</para>
        <para>Only used if <see cref="P:UnityEngine.ReflectionProbe.clearFlags" /> are set to CameraClearFlags.SolidColor (or CameraClearFlags.Skybox but the skybox is not set up).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.bakedTexture">
      <summary>Reference to the baked texture of the reflection probe's surrounding.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.blendDistance">
      <summary>
        <para>Distance around probe used for blending (used in deferred probes).</para>
        <para>When using deferred shading, reflection probes are rendered per-pixel (instead of one or two probes affecting whole object). Blend distance controls how probes blend with each other; essentially it's the size of the probe blend area. Default blend distance is 1.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.bounds">
      <summary>
        <para>The bounding volume of the reflection probe (Read Only).</para>
        <para>This is the axis-aligned bounding box of the reflection probe in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.boxProjection">
      <summary>
        <para>Should this reflection probe use box projection?</para>
        <para>Box projection is affected by the center and the size of the probe.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.center">
      <summary>The center of the box area in which reflections will be applied to the objects. Measured in the probes's local space.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.clearFlags">
      <summary>
        <para>How the reflection probe clears the background.</para>
        <para>Can be <see cref="F:UnityEngine.Rendering.ReflectionProbeClearFlags.Skybox" /> or <see cref="F:UnityEngine.Rendering.ReflectionProbeClearFlags.SolidColor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.cullingMask">
      <summary>
        <para>This is used to render parts of the reflecion probe's surrounding selectively.</para>
        <para>If the <see cref="T:UnityEngine.GameObject" />'s <c>layerMask</c> AND the probe's <c>cullingMask</c> is zero then the game object will be invisible from this probe.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.customBakedTexture">
      <summary>Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.farClipPlane">
      <summary>The far clipping plane distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.hdr">
      <summary>
        <para>Should this reflection probe use HDR rendering?</para>
        <para>When baked HDR reflection probe range [0;8] is packed to [0;1] with multiplier stored in the alpha channel.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.importance">
      <summary>
        <para>Reflection probe importance.</para>
        <para>The bigger the value the more important the probe is. When deciding which probe to use for the object, Unity will always pick Important probe over the Not Important. This property also affects blending, if object is inside both Important and Not Important probe, only Important probe will be used, when object is leaving Important probe bounding box, it will gradually blend over Not Important probe. If both probes would have same importance, the object would use both probes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.intensity">
      <summary>The intensity modifier that is applied to the texture of reflection probe in the shader.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.mode">
      <summary>Should reflection probe texture be generated in the Editor (<see cref="F:UnityEngine.Rendering.ReflectionProbeMode.Baked" />) or should probe use custom specified texure (<see cref="F:UnityEngine.Rendering.ReflectionProbeMode.Custom" />)?</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.nearClipPlane">
      <summary>The near clipping plane distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.refreshMode">
      <summary>Sets the way the probe will refresh.See Also: <see cref="T:UnityEngine.Rendering.ReflectionProbeRefreshMode" />.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.resolution">
      <summary>Resolution of the underlying reflection texture in pixels.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.shadowDistance">
      <summary>Shadow drawing distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.size">
      <summary>
        <para>The size of the box area in which reflections will be applied to the objects. Measured in the probes's local space.</para>
        <para>The box size will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.texture">
      <summary>
        <para>Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).</para>
        <para>This texture is meant to represent reflection in a particular direction.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.timeSlicingMode">
      <summary>Sets this probe time-slicing modeSee Also: <see cref="T:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode" />.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.type">
      <summary>Reflection probe type.</summary>
    </member>
    <member name="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)">
      <summary>Checks if a probe has finished a time-sliced render.</summary>
      <param name="renderId">An integer representing the RenderID as returned by the RenderProbe method.</param>
      <returns>True if the render has finished, false otherwise.</returns>
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode" />
    </member>
    <member name="M:UnityEngine.ReflectionProbe.RenderProbe(UnityEngine.RenderTexture)">
      <summary>Refreshes the probe's cubemap.</summary>
      <param name="targetTexture">Target RendeTexture in which rendering should be done. Specifying null will update the probe's default texture.</param>
      <returns>An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.</returns>
      <seealso cref="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)" />
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode" />
    </member>
    <member name="M:UnityEngine.ReflectionProbe.RenderProbe">
      <summary>Refreshes the probe's cubemap.</summary>
      <returns>An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.</returns>
      <seealso cref="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)" />
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode" />
    </member>
    <member name="M:UnityEngine.ReflectionProbe.BlendCubemap(UnityEngine.Texture,UnityEngine.Texture,System.Single,UnityEngine.RenderTexture)">
      <summary>Utility method to blend 2 cubemaps into a target render texture.</summary>
      <param name="src">Cubemap to blend from.</param>
      <param name="dst">Cubemap to blend to.</param>
      <param name="blend">Blend weight.</param>
      <param name="target">RenderTexture which will hold the result of the blend.</param>
      <returns>Returns trues if cubemaps were blended, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.RenderBuffer.GetNativeRenderBufferPtr">
      <summary>Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.bounds">
      <summary>
        <para>The bounding volume of the renderer (Read Only).</para>
        <para>This is the axis-aligned bounding box fully enclosing the object in world space.Using <c>bounds</c> is convenient to make rough approximations about the object's location and its extents. For example, the <c>center</c> property is often a more precise approximation to the center of the object than <see cref="P:UnityEngine.Transform.position" />, especially if the object is not symmetrical.Note that the <see cref="P:UnityEngine.Mesh.bounds" /> property is similar but returns the bounds of the mesh in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.enabled">
      <summary>Makes the rendered 3D object visible if enabled.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.isPartOfStaticBatch">
      <summary>Has this renderer been statically batched with any other renderers?</summary>
    </member>
    <member name="P:UnityEngine.Renderer.isVisible">
      <summary>
        <para>Is this renderer visible in any camera? (Read Only)</para>
        <para>Note that the object is considered visible when it needs to be rendered in the scene. For example, it might not actually be visible by any camera but still need to be rendered for shadows. When running in the editor, the scene view cameras will also cause this value to be true.See Also: <see href="Renderer.OnBecameVisible" cref="OnBecameVisible" />, <see href="Renderer.OnBecameInvisible" cref="OnBecameInvisible" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightmapIndex">
      <summary>
        <para>The index of the baked lightmap applied to this renderer.</para>
        <para>The index refers to the <see cref="P:UnityEngine.LightmapSettings.lightmaps" /> array. A value of -1 (0xFFFF) means no lightmap has been assigned, which is the default. A value of 0xFFFE is internally used for objects that have their scale in lightmap set to 0; they affect lightmaps, but don't have a lightmap assigned themselves. The index is 16 bits internally and can't be larger than 65533 (0xFFFE).A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.lightmapScaleOffset" /> property, ShaderLab properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightmapScaleOffset">
      <summary>
        <para>The UV scale &amp; offset used for a lightmap.</para>
        <para>A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.The vector's x and y refer to UV scale, while z and w refer to UV offset.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.lightmapIndex" /> property, ShaderLab properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.localToWorldMatrix">
      <summary>
        <para>Matrix that transforms a point from local space into world space (Read Only).</para>
        <para>This property MUST be used instead of Transform.localToWorldMatrix, if you're setting shader parameters.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.material">
      <summary>
        <para>Returns the first instantiated <see cref="T:UnityEngine.Material" /> assigned to the renderer.</para>
        <para>Modifying <c>material</c> will change the material for this object only.If the material is used by any other renderers, this will clone the shared material and start using it from now on.Note: This function automatically instantiates the materials and makes them unique to this renderer. It is your responsibility to destroy the materials when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the materials but it is usually only called when loading a new level.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.materials">
      <summary>
        <para>Returns all the instantiated materials of this object.</para>
        <para>This is an array of all materials used by the renderer. Unity supports a single object using multiple materials; in this case <c>materials</c> contains all the materials. <see cref="P:UnityEngine.Renderer.sharedMaterial" /> and <see cref="P:UnityEngine.Renderer.material" /> properties return the first used material if there is more than one.Modifying any material in <c>materials</c> will change the appearance of only that object.Note that like all arrays returned by Unity, this returns a copy of materials array. If you want to change some materials in it, get the value, change an entry and set materials back.Note: This function automatically instantiates the materials and makes them unique to this renderer. It is your responsibility to destroy the materials when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the materials but it is usually only called when loading a new level.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.probeAnchor">
      <summary>
        <para>If set, Renderer will use this Transform's position to find the light or reflection probe.</para>
        <para>Otherwise the center of Renderer's AABB will be used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.realtimeLightmapIndex">
      <summary>
        <para>The index of the realtime lightmap applied to this renderer.</para>
        <para>A value of -1 (0xFFFF) means no lightmap has been assigned, which is the default. A value of 0xFFFE is internally used for objects that have their scale in lightmap set to 0; they affect lightmaps, but don't have a lightmap assigned themselves. The index is 16 bits internally and can't be larger than 65533 (0xFFFE).A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.lightmapIndex" />, <see cref="P:UnityEngine.Renderer.lightmapScaleOffset" /> property, ShaderLab properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.realtimeLightmapScaleOffset">
      <summary>
        <para>The UV scale &amp; offset used for a realtime lightmap.</para>
        <para>Same as <see cref="P:UnityEngine.Renderer.lightmapScaleOffset" />, but for realtime lightmaps.A realtime lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.The vector's x and y refer to UV scale, while z and w refer to UV offset.See Also: <see cref="T:UnityEngine.LightmapSettings" /> class, <see cref="P:UnityEngine.Renderer.lightmapScaleOffset" /> property, ShaderLab properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.receiveShadows">
      <summary>
        <para>Does this object receive shadows?</para>
        <para>Usually objects should receive shadows, but turning this off can be useful for optimization purposes, in cases of when you know that no shadows will be needed on this particular object.Note that receive shadows flag is not used when using one of Deferred rendering paths; all objects receive shadows there.See Also: <see cref="P:UnityEngine.Renderer.shadowCastingMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.reflectionProbeUsage">
      <summary>
        <para>Should reflection probes be used for this Renderer?</para>
        <para>If enabled and reflection probes are present in the scene, a reflection texture will be picked for this object and set as a built-in shader uniform variable. Surface shaders use this information automatically.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.shadowCastingMode">
      <summary>
        <para>Does this object cast shadows?</para>
        <para>
          <see cref="T:UnityEngine.Rendering.ShadowCastingMode" /> enum defines how and if shadows are cast from this object. Typically shadows are either cast or not, but it's also possible to make shadows two-sided (useful for otherwise single-sided geometry) or make a shadows-only object (that is otherwise invisible in the scene, but casts a shadow).See Also: <see cref="T:UnityEngine.Rendering.ShadowCastingMode" />, <see cref="P:UnityEngine.Renderer.receiveShadows" />, <see cref="P:UnityEngine.Light.shadows" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sharedMaterial">
      <summary>
        <para>The shared material of this object.</para>
        <para>Modifying <c>sharedMaterial</c> will change the appearance of all objects using this material, and change material settings that are stored in the project too.It is not recommended to modify materials returned by sharedMaterial. If you want to modify the material of a renderer use <see cref="P:UnityEngine.Renderer.material" /> instead.See Also: <see cref="P:UnityEngine.Renderer.material" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sharedMaterials">
      <summary>
        <para>All the shared materials of this object.</para>
        <para>This is an array of all materials used by the renderer. Unity supports a single object using multiple materials; in this case <c>sharedMaterials</c> contains all the materials. <see cref="P:UnityEngine.Renderer.sharedMaterial" /> and <see cref="P:UnityEngine.Renderer.material" /> properties return the first used material if there is more than one.Modifying any material in <c>sharedMaterials</c> will change the appearance of all objects using this material, and change material settings that are stored in the project too.It is not recommended to modify materials returned by sharedMaterials. If you want to modify the material of a renderer use <see cref="P:UnityEngine.Renderer.material" /> instead.Note that like all arrays returned by Unity, this returns a copy of materials array. If you want to change some materials in it, get the value, change an entry and set materials back.See Also: <see cref="P:UnityEngine.Renderer.material" />, <see cref="P:UnityEngine.Renderer.sharedMaterial" /> properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingLayerID">
      <summary>
        <para>Unique ID of the Renderer's sorting layer.</para>
        <para>ID of the default sorting layer is always 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingLayerName">
      <summary>Name of the Renderer's sorting layer.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingOrder">
      <summary>Renderer's order within a sorting layer.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.useLightProbes">
      <summary>
        <para>Should light probes be used for this Renderer?</para>
        <para>If enabled and baked light probes are present in the scene, an interpolated light probe will be calculated for this object and set as built-in shader uniform variables. Surface shaders use this information automatically. To add light probe contribution to your custom non-surface shaders, use ShadeSH9(worldSpaceNormal) in your vertex or pixel shader.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.worldToLocalMatrix">
      <summary>
        <para>Matrix that transforms a point from world space into local space (Read Only).</para>
        <para>This property MUST be used instead of Transform.worldToLocalMatrix, if you're setting shader parameters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Renderer.GetClosestReflectionProbes">
      <summary>Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur.</summary>
    </member>
    <member name="M:UnityEngine.Renderer.GetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      <summary>Get per-renderer material property block.</summary>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock" />
      <seealso cref="M:UnityEngine.Renderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)" />
    </member>
    <member name="M:UnityEngine.Renderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Lets you add per-renderer material parameters without duplicating a material.</para>
        <para>This is recommended when changing material properties often. With multithreaded rendering, it is more efficient than setting properties directly on the material.See Also: <see cref="T:UnityEngine.MaterialPropertyBlock" />, <see cref="M:UnityEngine.Renderer.GetPropertyBlock(UnityEngine.MaterialPropertyBlock)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientEquatorColor">
      <summary>
        <para>Ambient lighting coming from the sides.</para>
        <para>Trilight ambient lighing mode uses this color to affect sideways-facing object parts.In Flat ambient lighting mode, equator color is just the single ambient color, and has the same value as <see cref="P:UnityEngine.RenderSettings.ambientLight" />.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, <see cref="P:UnityEngine.RenderSettings.ambientSkyColor" />, <see cref="P:UnityEngine.RenderSettings.ambientGroundColor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientGroundColor">
      <summary>
        <para>Ambient lighting coming from below.</para>
        <para>Trilight ambient lighing mode uses this color to affect downwards-facing object parts.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, <see cref="P:UnityEngine.RenderSettings.ambientSkyColor" />, <see cref="P:UnityEngine.RenderSettings.ambientEquatorColor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientIntensity">
      <summary>How much the light from the Ambient Source affects the scene.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientLight">
      <summary>
        <para>Flat ambient lighting color.</para>
        <para>Flat ambient lighting mode uses color. It has the same value as <see cref="P:UnityEngine.RenderSettings.ambientSkyColor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientMode">
      <summary>
        <para>Ambient lighting mode.</para>
        <para>Unity can provide ambient lighting in several modes, for example directional ambient with separate sky, equator and ground colors, or flat ambient with a single color.See Also: <see cref="T:UnityEngine.Rendering.AmbientMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientProbe">
      <summary>
        <para>Custom or skybox ambient lighting data.</para>
        <para>Skybox ambient lighting mode uses this Spherical Harmonics (SH) probe to calculate ambient. You can also assign a completely custom SH probe this way.The GI system will bake the ambient probe, but it actually won't be used on geometry that uses light probes or lightmaps, as the environment lighting is already in the light probes and the lightmaps. It is used as the last fallback if light probes or lightmaps are not present or enabled for an object.Adjusting the ambient probe will not affect the input to realtime and baked Global Illumination. If you want to adjust ambient in a way that affects GI, adjust ambient through <see cref="P:UnityEngine.RenderSettings.ambientMode" />, for instance by using <see cref="F:UnityEngine.Rendering.AmbientMode.Trilight" />. The GI system will output the resulting ambient values into the ambient probe, which means that a custom ambient probe can be overwritten by the GI system.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, <see cref="T:UnityEngine.Rendering.SphericalHarmonicsL2" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientSkyColor">
      <summary>
        <para>Ambient lighting coming from above.</para>
        <para>Trilight ambient lighing mode uses this color to affect upwards-facing object parts.See Also: <see cref="P:UnityEngine.RenderSettings.ambientMode" />, <see cref="P:UnityEngine.RenderSettings.ambientGroundColor" />, <see cref="P:UnityEngine.RenderSettings.ambientEquatorColor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.customReflection">
      <summary>
        <para>Custom specular reflection cubemap.</para>
        <para>You can specify cubemap that will be used as a default specular reflection.See Also: <see cref="P:UnityEngine.RenderSettings.defaultReflectionMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.defaultReflectionMode">
      <summary>
        <para>Default reflection mode.</para>
        <para>Unity can use a custom texture or generate a specular reflection texture from skybox.See Also: <see cref="P:UnityEngine.RenderSettings.defaultReflectionMode" />, Lighting Window.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.defaultReflectionResolution">
      <summary>Cubemap resolution for default reflection.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.flareFadeSpeed">
      <summary>The fade speed of all flares in the scene.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.flareStrength">
      <summary>The intensity of all flares in the scene.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fog">
      <summary>Is fog enabled?</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogColor">
      <summary>The color of the fog.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogDensity">
      <summary>
        <para>The density of the exponential fog.</para>
        <para>Fog density is used by <see cref="F:UnityEngine.FogMode.Exponential" /> and <see cref="F:UnityEngine.FogMode.ExponentialSquared" /> modes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogEndDistance">
      <summary>
        <para>The ending distance of linear fog.</para>
        <para>Fog start and end distances are used by <see cref="F:UnityEngine.FogMode.Linear" /> fog mode.See Also: <see cref="P:UnityEngine.RenderSettings.fogStartDistance" />, <see cref="P:UnityEngine.RenderSettings.fogMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogMode">
      <summary>Fog mode to use.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogStartDistance">
      <summary>
        <para>The starting distance of linear fog.</para>
        <para>Fog start and end distances are used by <see cref="F:UnityEngine.FogMode.Linear" /> fog mode.See Also: <see cref="P:UnityEngine.RenderSettings.fogEndDistance" />, <see cref="P:UnityEngine.RenderSettings.fogMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.haloStrength">
      <summary>
        <para>Size of the <see cref="T:UnityEngine.Light" /> halos.</para>
        <para>For any light, the size of the halo is this value multiplied by <see cref="P:UnityEngine.Light.range" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.reflectionBounces">
      <summary>
        <para>The number of times a reflection includes other reflections.</para>
        <para>Defines in how many passes reflections are calculated. In a given pass, the scene is rendered into a cubemap with the reflections calculated in the previous pass applied to reflective objects.If set to 1, the scene will be rendered once, which means that a reflection will not be able to reflect another reflection and reflective objects will show up black, when seen in other reflective surfaces.If set to 2, the scene will be rendered twice and reflective objects will show reflections from the first pass, when seen in other reflective surfaces.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.reflectionIntensity">
      <summary>How much the skybox / custom cubemap reflection affects the scene.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.skybox">
      <summary>
        <para>The global skybox to use.</para>
        <para>If you change the skybox in playmode, you have to use the <see cref="M:UnityEngine.DynamicGI.UpdateEnvironment" /> function call to update the ambient probe.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.color">
      <summary>Color Buffers to set.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.colorLoad">
      <summary>
        <para>Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.colorStore">
      <summary>
        <para>Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.cubemapFace">
      <summary>Cubemap face to render to.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depth">
      <summary>Depth Buffer to set.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depthLoad">
      <summary>
        <para>Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depthStore">
      <summary>
        <para>Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.mipLevel">
      <summary>Mip Level to render to.</summary>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
      <param name="mipLevel">Mip Level to render to.</param>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32,UnityEngine.CubemapFace)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
      <param name="mipLevel">Mip Level to render to.</param>
      <param name="face">Cubemap face to render to.</param>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer,System.Int32)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
      <param name="mipLevel">Mip Level to render to.</param>
    </member>
    <member name="M:UnityEngine.RenderTargetSetup.#ctor(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer,System.Int32,UnityEngine.CubemapFace)">
      <summary>Constructs RenderTargetSetup.</summary>
      <param name="color">Color Buffer(s) to set.</param>
      <param name="depth">Depth Buffer to set.</param>
      <param name="mipLevel">Mip Level to render to.</param>
      <param name="face">Cubemap face to render to.</param>
    </member>
    <member name="P:UnityEngine.RenderTexture.active">
      <summary>
        <para>Currently active render texture.</para>
        <para>All rendering goes into the active RenderTexture. If the active RenderTexture is <c>null</c> everything is rendered in the main window.Setting RenderTexture.active is the same as calling <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" />. Typically you change or query the active render texture when implementing custom graphics effects; if all you need is to make a Camera render into a texture then use <see cref="P:UnityEngine.Camera.targetTexture" /> instead.When a RenderTexture becomes active its hardware rendering context is automatically created if it hasn't been created already.See Also: <see cref="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.antiAliasing">
      <summary>
        <para>The antialiasing level for the RenderTexture.</para>
        <para>Anti-aliasing value must be one of (1, 2, 4 or 8), indicating the number of samples per pixel.When a RenderTexture is using anti-aliasing, then any rendering into it will happen into the multi-sampled texture, which will be "resolved" into a regular texture when switching to another render target. To the rest of the system only this "resolved" surface is visible.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.colorBuffer">
      <summary>Color buffer of the render texture (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.depth">
      <summary>
        <para>The precision of the render texture's depth buffer in bits (0, 16, 24 are supported).</para>
        <para>When 0 is used, then no Z buffer is created by a render texture.If you also need a stencil buffer, use 24 bit Z format (0 &amp; 16 bit Z buffers do not have stencil).See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.width" />, <see cref="P:UnityEngine.RenderTexture.height" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.depthBuffer">
      <summary>Depth/stencil buffer of the render texture (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.enableRandomWrite">
      <summary>
        <para>Enable random access write into this render texture on Shader Model 5.0 level shaders.</para>
        <para>Shader Model 5.0 level pixel or compute shaders can write into arbitrary locations of some textures, called "unordered access views" in DirectX 11. Set this flag before creating your render texture to enable this capability.When a texture has this flag set, it can be written into as one RWTexture* resources in HLSL or image resources in GLSL. It can also be set as random access write target for pixel shaders using <see cref="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.RenderTexture)" />.See Also: <see cref="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.RenderTexture)" />, DirectX 11.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.format">
      <summary>The color format of the render texture.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.generateMips">
      <summary>Should mipmap levels be generated automatically?</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.height">
      <summary>
        <para>The height of the render texture in pixels.</para>
        <para>Note that unlike Texture.height property, this is both read and write - setting a value changes size.See Also:: <see cref="P:UnityEngine.RenderTexture.width" />, <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.depth" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.isCubemap">
      <summary>
        <para>If enabled, this Render Texture will be used as a <see cref="T:UnityEngine.Cubemap" />.</para>
        <para>
          <see cref="T:UnityEngine.Cubemap" /> render textures are most often used for dynamic cubemap reflections, see Camera.RenderToCubemap. A cubemap render texture must have the same <see cref="P:UnityEngine.RenderTexture.width" /> and <see cref="P:UnityEngine.RenderTexture.height" />, and must be power of two size.See Also: <see cref="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.Cubemap,System.Int32)" />, <see cref="T:UnityEngine.Cubemap" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.isVolume">
      <summary>
        <para>If enabled, this Render Texture will be used as a <see cref="T:UnityEngine.Texture3D" />.</para>
        <para>Volumetric render textures currently only work on DirectX 11. You can render into them using "random access writes" from a pixel shader or a compute shader.See Also: <see cref="P:UnityEngine.RenderTexture.volumeDepth" />, <see cref="P:UnityEngine.RenderTexture.enableRandomWrite" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.sRGB">
      <summary>
        <para>Does this render texture use sRGB read / write (Read Only).</para>
        <para>The value of this property is fixed for the life of the RenderTexture but it can be set using the <c>readWrite</c> parameter of the RenderTexture constructor function.See Also: <see cref="T:UnityEngine.ColorSpace" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.useMipMap">
      <summary>
        <para>Use mipmaps on a render texture?</para>
        <para>When set to <c>true</c>, rendering into this render texture will create and generate mipmap levels. By default render textures don't have mipmaps. This flag can be used only on render textures that have power-of-two size.By default the mipmaps will be automatically generated. If you want to render into texture mip levels manually, set <see cref="P:UnityEngine.RenderTexture.generateMips" /> to false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.volumeDepth">
      <summary>
        <para>Volume extent of a 3D render texture.</para>
        <para>For volumetric render textures (see <see cref="P:UnityEngine.RenderTexture.isVolume" />), this variable determines the volume extent.See Also: <see cref="P:UnityEngine.RenderTexture.isVolume" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.width">
      <summary>
        <para>The width of the render texture in pixels.</para>
        <para>Note that unlike Texture.width property, this is both read and write - setting a value changes size.See Also:: <see cref="P:UnityEngine.RenderTexture.height" />, <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.depth" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Creates a new RenderTexture object.</para>
        <para>The render texture is created with <c>width</c> by <c>height</c> size, with a depth buffer of <c>depth</c> bits (depth can be 0, 16 or 24), and in <c>format</c> format and with sRGB read / write on or off.Note that constructing a RenderTexture object does not create the hardware representation immediately. The actual render texture is created upon first use or when <see cref="M:UnityEngine.RenderTexture.Create" /> is called manually. So after constructing the render texture, it is possible to set additional variables, like <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.isCubemap" /> and so on.See Also: <see cref="P:UnityEngine.RenderTexture.format" /> variable, <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />.</para>
      </summary>
      <param name="width">Texture width in pixels.</param>
      <param name="height">Texture height in pixels.</param>
      <param name="depth">Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.#ctor(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Creates a new RenderTexture object.</para>
        <para>The render texture is created with <c>width</c> by <c>height</c> size, with a depth buffer of <c>depth</c> bits (depth can be 0, 16 or 24), and in <c>format</c> format and with sRGB read / write on or off.Note that constructing a RenderTexture object does not create the hardware representation immediately. The actual render texture is created upon first use or when <see cref="M:UnityEngine.RenderTexture.Create" /> is called manually. So after constructing the render texture, it is possible to set additional variables, like <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.isCubemap" /> and so on.See Also: <see cref="P:UnityEngine.RenderTexture.format" /> variable, <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />.</para>
      </summary>
      <param name="width">Texture width in pixels.</param>
      <param name="height">Texture height in pixels.</param>
      <param name="depth">Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
      <param name="format">Texture color format.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.#ctor(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite)">
      <summary>
        <para>Creates a new RenderTexture object.</para>
        <para>The render texture is created with <c>width</c> by <c>height</c> size, with a depth buffer of <c>depth</c> bits (depth can be 0, 16 or 24), and in <c>format</c> format and with sRGB read / write on or off.Note that constructing a RenderTexture object does not create the hardware representation immediately. The actual render texture is created upon first use or when <see cref="M:UnityEngine.RenderTexture.Create" /> is called manually. So after constructing the render texture, it is possible to set additional variables, like <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="P:UnityEngine.RenderTexture.isCubemap" /> and so on.See Also: <see cref="P:UnityEngine.RenderTexture.format" /> variable, <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />.</para>
      </summary>
      <param name="width">Texture width in pixels.</param>
      <param name="height">Texture height in pixels.</param>
      <param name="depth">Number of bits in depth buffer (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
      <param name="format">Texture color format.</param>
      <param name="readWrite">How or if color space conversions should be done on texture read/write.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.Create">
      <summary>
        <para>Actually creates the RenderTexture.</para>
        <para>RenderTexture constructor does not actually create the hardware texture; by default the texture is created the first time it is set <see cref="P:UnityEngine.RenderTexture.active" />. Calling <c>Create</c> lets you create it up front. <c>Create</c> does nothing if the texture is already created.See Also: <see cref="M:UnityEngine.RenderTexture.Release" />, <see cref="M:UnityEngine.RenderTexture.IsCreated" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.DiscardContents">
      <summary>
        <para>Discards the contents of the RenderTexture.</para>
        <para>On some platforms, it can be good for performance if you indicate when the current contents of a RenderTexture aren't needed anymore. This can save copying it from one kind of memory to another when the texture is reused. Xbox 360 and many mobile GPUs benefit from this.Both the colour buffer and depth buffer are discarded by default but either can be selected individually using the optional boolean parameters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.DiscardContents(System.Boolean,System.Boolean)">
      <summary>
        <para>Discards the contents of the RenderTexture.</para>
        <para>On some platforms, it can be good for performance if you indicate when the current contents of a RenderTexture aren't needed anymore. This can save copying it from one kind of memory to another when the texture is reused. Xbox 360 and many mobile GPUs benefit from this.Both the colour buffer and depth buffer are discarded by default but either can be selected individually using the optional boolean parameters.</para>
      </summary>
      <param name="discardColor">Should the colour buffer be discarded?</param>
      <param name="discardDepth">Should the depth buffer be discarded?</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.IsCreated">
      <summary>
        <para>Is the render texture actually created?</para>
        <para>RenderTexture constructor does not actually create the hardware texture; by default the texture is created the first time it is set <see cref="P:UnityEngine.RenderTexture.active" />. <c>IsCreated</c> returns <c>true</c> if the hardware resources for this render are created.See Also: <see cref="M:UnityEngine.RenderTexture.Create" />, <see cref="M:UnityEngine.RenderTexture.Release" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.MarkRestoreExpected">
      <summary>
        <para>Indicate that there's a RenderTexture restore operation expected.</para>
        <para>When in mobile graphics emulation mode, Unity issues warnings when a RenderTexture "restore" operation is performed. Restore happens when rendering into a texture, without clearing or discarding (<see cref="M:UnityEngine.RenderTexture.DiscardContents" />) it first. This is a costly operation on many mobile GPUs and multi-GPU systems and best should be avoided.However, if your rendering effect absolutely needs a RenderTexture restore, you can call this function to indicate that yes, a restore is expected, and Unity will not issue a warning here.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.Release">
      <summary>
        <para>Releases the RenderTexture.</para>
        <para>This function releases the hardware resources used by the render texture. The texture itself is not destroyed, and will be automatically created again when being used.See Also: <see cref="M:UnityEngine.RenderTexture.Create" />, <see cref="M:UnityEngine.RenderTexture.IsCreated" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.SetGlobalShaderProperty(System.String)">
      <summary>Assigns this RenderTexture as a global shader property named <c>propertyName</c>.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> as soon as you're done with it, so another call can start reusing it if needed.Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames.If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="M:UnityEngine.RenderTexture.DiscardContents" /> call which helps to avoid costly restore operations on the previous render texture contents.You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.See Also: <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" />.</para>
      </summary>
      <param name="width">Width in pixels.</param>
      <param name="height">Height in pixels.</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
      <param name="format">Render texture format.</param>
      <param name="readWrite">sRGB handling mode.</param>
      <param name="antiAliasing">Anti-aliasing (1,2,4,8).</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> as soon as you're done with it, so another call can start reusing it if needed.Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames.If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="M:UnityEngine.RenderTexture.DiscardContents" /> call which helps to avoid costly restore operations on the previous render texture contents.You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.See Also: <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" />.</para>
      </summary>
      <param name="width">Width in pixels.</param>
      <param name="height">Height in pixels.</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
      <param name="format">Render texture format.</param>
      <param name="readWrite">sRGB handling mode.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> as soon as you're done with it, so another call can start reusing it if needed.Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames.If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="M:UnityEngine.RenderTexture.DiscardContents" /> call which helps to avoid costly restore operations on the previous render texture contents.You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.See Also: <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" />.</para>
      </summary>
      <param name="width">Width in pixels.</param>
      <param name="height">Height in pixels.</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
      <param name="format">Render texture format.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> as soon as you're done with it, so another call can start reusing it if needed.Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames.If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="M:UnityEngine.RenderTexture.DiscardContents" /> call which helps to avoid costly restore operations on the previous render texture contents.You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.See Also: <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" />.</para>
      </summary>
      <param name="width">Width in pixels.</param>
      <param name="height">Height in pixels.</param>
      <param name="depthBuffer">Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" /> as soon as you're done with it, so another call can start reusing it if needed.Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames.If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="M:UnityEngine.RenderTexture.DiscardContents" /> call which helps to avoid costly restore operations on the previous render texture contents.You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.See Also: <see cref="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)" />.</para>
      </summary>
      <param name="width">Width in pixels.</param>
      <param name="height">Height in pixels.</param>
    </member>
    <member name="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)">
      <summary>
        <para>Release a temporary texture allocated with <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" />.</para>
        <para>Later calls to <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" /> will reuse the RenderTexture created earlier if possible. When no one has requested the temporary RenderTexture for a few frames it will be destroyed.See Also: <see cref="M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32,UnityEngine.RenderTextureFormat,UnityEngine.RenderTextureReadWrite,System.Int32)" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.SupportsStencil(UnityEngine.RenderTexture)">
      <summary>
        <para>Does a RenderTexture have stencil buffer?</para>
        <para>If rt is null, will report the status for the main screen.</para>
      </summary>
      <param name="rt">Render texture, or null for main screen.</param>
    </member>
    <member name="P:UnityEngine.Resolution.height">
      <summary>Resolution height in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Resolution.refreshRate">
      <summary>Resolution's vertical refresh rate in Hz.</summary>
    </member>
    <member name="P:UnityEngine.Resolution.width">
      <summary>Resolution width in pixels.</summary>
    </member>
    <member name="M:UnityEngine.Resolution.ToString">
      <summary>Returns a nicely formatted string of the resolution.</summary>
      <returns>A string with the format "width x height @ refreshRateHz".</returns>
    </member>
    <member name="P:UnityEngine.ResourceRequest.asset">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="P:UnityEngine.AsyncOperation.isDone" /> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Resources.FindObjectsOfTypeAll(System.Type)">
      <summary>
        <para>Returns a list of all objects of Type <c>type</c>.</para>
        <para>This function can return any type of Unity object that is loaded, including game objects, prefabs, materials, meshes, textures, etc. It will also list internal stuff, therefore please be <c>extra</c> careful the way you handle the returned objects. Contrary to <see cref="M:UnityEngine.Object.FindObjectsOfType(System.Type)" /> this function will also list disabled objects.Please note that this function is very slow and is not recommended to be used every frame.</para>
      </summary>
      <param name="type">Type of the class to match while searching.</param>
      <returns>An array of objects whose class is <c>type</c> or is derived from <c>type</c>.</returns>
    </member>
    <member name="M:UnityEngine.Resources.FindObjectsOfTypeAll``1">
      <summary>
        <para>Returns a list of all objects of Type <c>T</c>.</para>
        <para>This function can return any type of Unity object that is loaded, including game objects, prefabs, materials, meshes, textures, etc. It will also list internal stuff, therefore please be <c>extra</c> careful the way you handle the returned objects. Contrary to <see cref="M:UnityEngine.Object.FindObjectsOfType(System.Type)" /> this function will also list disabled objects.Please note that this function is very slow and is not recommended to be used every frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Resources.Load(System.String)">
      <summary>
        <para>Loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns the asset at <c>path</c> if it can be found otherwise returns null. Only objects of <c>type</c> will be returned if this parameter is supplied. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.Load(System.String,System.Type)">
      <summary>
        <para>Loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns the asset at <c>path</c> if it can be found otherwise returns null. Only objects of <c>type</c> will be returned if this parameter is supplied. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
      <param name="systemTypeInstance">Type filter for objects returned.</param>
    </member>
    <member name="M:UnityEngine.Resources.Load``1(System.String)">
      <summary>
        <para>Loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns the asset at <c>path</c> if it can be found otherwise returns null. Only objects of type <c>T</c> will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAll(System.String)">
      <summary>
        <para>Loads all assets in a folder or file at <c>path</c> in a Resources folder.</para>
        <para>If <c>path</c> refers to a folder, all assets in the folder will be returned. If <c>path</c> refers to a file, only that asset will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project.Note:All asset names and paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAll(System.String,System.Type)">
      <summary>
        <para>Loads all assets in a folder or file at <c>path</c> in a Resources folder.</para>
        <para>If <c>path</c> refers to a folder, all assets in the folder will be returned. If <c>path</c> refers to a file, only that asset will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project.Note:All asset names and paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
      <param name="systemTypeInstance">Type filter for objects returned.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAll``1(System.String)">
      <summary>
        <para>Loads all assets in a folder or file at <c>path</c> in a Resources folder.</para>
        <para>If <c>path</c> refers to a folder, all assets in the folder will be returned. If <c>path</c> refers to a file, only that asset will be returned. Only objects of type <c>T</c> will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type will be returned if this parameter is supplied. The path is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String,System.Type)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type will be returned if this parameter is supplied. The path is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type <c>T</c> will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted.Note:All asset names &amp; paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.UnloadAsset(UnityEngine.Object)">
      <summary>
        <para>Unloads <c>assetToUnload</c> from memory.</para>
        <para>This function can only be called on Assets that are stored on disk.If there are any references from game objects in the scene to the asset and it is being used then Unity will reload the asset from disk as soon as it is accessed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Resources.UnloadUnusedAssets">
      <summary>
        <para>Unloads assets that are not used.</para>
        <para>An asset is deemed to be unused if it isn't reached after walking the whole game object hierarchy, including script components. Static variables are also examined.The script excecution stack, however, is not examined so an asset referenced only from within the script stack will be unloaded and, if necessary, loaded back in the next time one of its properties or methods is used. This requires extra care for assets which have been modified in memory. Make sure to call <see cref="M:UnityEditor.EditorUtility.SetDirty(UnityEngine.Object)" /> before an asset garbage collection is triggered.See Also: <see cref="M:UnityEditor.EditorUtility.UnloadUnusedAssetsImmediate" />.</para>
      </summary>
      <returns>Object on which you can yield to wait until the operation completes.</returns>
    </member>
    <member name="P:UnityEngine.Rigidbody.angularDrag">
      <summary>
        <para>The angular drag of the object.</para>
        <para>Angular drag can be used to slow down the rotation of an object. The higher the drag the more the rotation slows down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.angularVelocity">
      <summary>
        <para>The angular velocity vector of the rigidbody.</para>
        <para>In most cases you should not modify it directly, as this can result in unrealistic behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.centerOfMass">
      <summary>
        <para>The center of mass relative to the transform's origin.</para>
        <para>If you don't set the center of mass from a script it will be calculated automatically from all colliders attached to the rigidbody. Setting the center of mass is often useful when simulating cars to make them more stable. A car with a lower center of mass is less likely to topple over.Note: <c>centerOfMass</c> is relative to the transform's position and rotation, but will not reflect the transform's scale!</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.collisionDetectionMode">
      <summary>
        <para>The Rigidbody's collision detection mode.</para>
        <para>Use this to set up a Rigidbody's for continuous collision detection, which is used to prevent fast moving objects from passing through other objects without detecting collisions. For best results, set this value to <see cref="F:UnityEngine.CollisionDetectionMode.ContinuousDynamic" /> for fast moving objects, and for other objects which these need to collide with, set it to <see cref="F:UnityEngine.CollisionDetectionMode.Continuous" />. This has a big impact on physics performance, so just leave it set to the default value of <see cref="F:UnityEngine.CollisionDetectionMode.Discrete" />, if you don't have any issues with collisions of fast objects. Continuous Collision Detection is only supported for Rigidbodies with Sphere-, Capusle- or BoxColliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.constraints">
      <summary>
        <para>Controls which degrees of freedom are allowed for the simulation of this Rigidbody.</para>
        <para>By default this is set to RigidbodyConstraints.None, allowing rotation and movement along all axes. In some cases, you may want to constrain a Rigidbody to only move or rotate along some axes, for example when developing 2D games. You can use the bitwise OR operator to combine multiple constraints. Note that the constraints are applied in the local space of the Rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.detectCollisions">
      <summary>
        <para>Should collision detection be enabled? (By default always enabled).</para>
        <para>Disabling collision detections is useful when you have a ragdoll which is setup to be kinematic and you want to avoid heavy collision detection calculations on that rigidbody. <c>detectCollisions</c> is not serialized. This means it doesn't show up in the Inspector and when Instantiating the rigidbody or saving it in a scene, it will not be saved.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.drag">
      <summary>
        <para>The drag of the object.</para>
        <para>Drag can be used to slow down an object. The higher the drag the more the object slows down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.freezeRotation">
      <summary>
        <para>Controls whether physics will change the rotation of the object.</para>
        <para>If freezeRotation is enabled, the rotation is not modified by the physics simulation. This is useful for creating first person shooters, because the player needs full control of the rotation using the mouse.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.inertiaTensor">
      <summary>
        <para>The diagonal inertia tensor of mass relative to the center of mass.</para>
        <para>The inertia tensor is rotated by the inertiaTensorRotation. If you don't set intertia tensor from a script it will be calculated automatically from all colliders attached to the rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.inertiaTensorRotation">
      <summary>
        <para>The rotation of the inertia tensor.</para>
        <para>If you don't set intertia tensor rotation from a script it will be calculated automatically from all colliders attached to the rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.interpolation">
      <summary>
        <para>Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.</para>
        <para>By default interpolation is turned off. Commonly rigidbody interpolation is used on the player's character. Physics is running at discrete timesteps, while graphics is renderered at variable frame rates. This can lead to jittery looking objects, because physics and graphics are not completely in sync. The effect is subtle but often visible on the player character, especially if a camera follows the main character. It is recommended to turn on interpolation for the main character but disable it for everything else.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.isKinematic">
      <summary>
        <para>Controls whether physics affects the rigidbody.</para>
        <para>If isKinematic is enabled, Forces, collisions or joints will not affect the rigidbody anymore. The rigidbody will be under full control of animation or script control by changing transform.position. Kinematic bodies also affect the motion of other rigidbodies through collisions or joints. Eg. can connect a kinematic rigidbody to a normal rigidbody with a joint and the rigidbody will be constrained with the motion of the kinematic body. Kinematic rigidbodies are also particularly useful for making characters which are normally driven by an animation, but on certain events can be quickly turned into a ragdoll by setting isKinematic to false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.mass">
      <summary>
        <para>The mass of the rigidbody.</para>
        <para>You should strive to keep mass close to 0.1 and never more than 10. Large masses make physics simulation unstable.Higher mass objects push lower mass objects more when colliding. Think of a big truck, hitting a small car.A common mistake is to assume that heavy objects fall faster than light ones. This is not true as the speed is dependent on gravity and drag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.maxAngularVelocity">
      <summary>
        <para>The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }.</para>
        <para>The angular velocity of rigidbodies is clamped to maxAngularVelocity to avoid numerical instability with fast rotating bodies. Because this may prevent intentional fast rotations on objects such as wheels, you can override this value per rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.maxDepenetrationVelocity">
      <summary>
        <para>Maximum velocity of a rigidbody when moving out of penetrating state.</para>
        <para>Use this property when you want to make your bodies move out of colliding state in a more smooth way than by default.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.position">
      <summary>
        <para>The position of the rigidbody.</para>
        <para>Rigidbody.position allows you to get and set the position of a Rigidbody using the physics engine. If you change the position of a Rigibody using Rigidbody.position, the transform will be updated after the next physics simulation step. This is faster than updating the position using Transform.position, as the latter will cause all attached Colliders to recalculate their positions relative to the Rigidbody. If you want to continuously move a rigidbody use MovePosition instead, which takes interpolation into account.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.rotation">
      <summary>
        <para>The rotation of the rigdibody.</para>
        <para>Rigidbody.rotation allows you to get and set the rotation of a Rigidbody using the physics engine. If you change the rotation of a Rigibody using Rigidbody.rotation, the transform will be updated after the next physics simulation step. This is faster than updating the rotation using Transform.rotation, as the latter will cause all attached Colliders to recalculate their rotation relative to the Rigidbody. If you want to continuously rotate a rigidbody use MoveRotation instead, which takes interpolation into account.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.sleepThreshold">
      <summary>The mass-normalized energy threshold, below which objects start going to sleep.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.solverIterationCount">
      <summary>
        <para>Allows you to override the solver iteration count per rigidbody.</para>
        <para>The solverIterationCount determines how accuratly joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically setting a higher solver iteration count may improve their stability.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.useConeFriction">
      <summary>
        <para>Force cone friction to be used for this rigidbody.</para>
        <para>This insures that all contacts involving the actor will use cone friction. This will however have a negative impact on performance. By default this is off and a much faster and almost as good approximation called pyramid friction method is used. In most cases it is recommended to leave this value off.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.useGravity">
      <summary>
        <para>Controls whether gravity affects this rigidbody.</para>
        <para>If set to false the rigidbody will behave as in outer space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.velocity">
      <summary>
        <para>The velocity vector of the rigidbody.</para>
        <para>In most cases you should not modify the velocity directly, as this can result in unrealistic behaviour. Don't set the velocity of an object every physics step, this will lead to unrealistic physics simulation. A typical example where you would change the velocity is when jumping in a first person shooter, because you want an immediate change in velocity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.worldCenterOfMass">
      <summary>The center of mass of the rigidbody in world space (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody.By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force.Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
      <param name="upwardsModifier">Adjustment to the apparent position of the explosion to make it seem to lift objects.</param>
      <param name="mode">The method used to apply the force to its targets.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single,System.Single)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody.By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force.Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
      <param name="upwardsModifier">Adjustment to the apparent position of the explosion to make it seem to lift objects.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody.By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force.Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3)">
      <summary>
        <para>Adds a force to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the world x-axis.</param>
      <param name="y">Size of force along the world y-axis.</param>
      <param name="z">Size of force along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a force to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the world x-axis.</param>
      <param name="y">Size of force along the world y-axis.</param>
      <param name="z">Size of force along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Applies <c>force</c> at <c>position</c>. As a result this will apply a torque and force on the object.</para>
        <para>For realistic effects <c>position</c> should be approximately in the range of the surface of the rigidbody. This is most commonly used for explosions. When applying explosions it is best to apply forces over several frames instead of just one. Note that when <c>position</c> is far away from the center of the rigidbody the applied torque will be unrealistically large.Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForceAtPosition has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <param name="position">Position in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Applies <c>force</c> at <c>position</c>. As a result this will apply a torque and force on the object.</para>
        <para>For realistic effects <c>position</c> should be approximately in the range of the surface of the rigidbody. This is most commonly used for explosions. When applying explosions it is best to apply forces over several frames instead of just one. Note that when <c>position</c> is far away from the center of the rigidbody the applied torque will be unrealistically large.Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForceAtPosition has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <param name="position">Position in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in local coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="force">Force vector in local coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the local x-axis.</param>
      <param name="y">Size of force along the local y-axis.</param>
      <param name="z">Size of force along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect.Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the local x-axis.</param>
      <param name="y">Size of force along the local y-axis.</param>
      <param name="z">Size of force along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque vector in local coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque vector in local coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the local x-axis.</param>
      <param name="y">Size of torque along the local y-axis.</param>
      <param name="z">Size of torque along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the local x-axis.</param>
      <param name="y">Size of torque along the local y-axis.</param>
      <param name="z">Size of torque along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque vector in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.See Also: <see cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />, <see cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque vector in world coordinates.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the world x-axis.</param>
      <param name="y">Size of torque along the world y-axis.</param>
      <param name="z">Size of torque along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect.Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the world x-axis.</param>
      <param name="y">Size of torque along the world y-axis.</param>
      <param name="z">Size of torque along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.ClosestPointOnBounds(UnityEngine.Vector3)">
      <summary>The closest point to the bounding box of the attached colliders.</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.GetPointVelocity(UnityEngine.Vector3)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>worldPoint</c> in global space.</para>
        <para>GetPointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.GetRelativePointVelocity(UnityEngine.Vector3)">
      <summary>
        <para>The velocity relative to the rigidbody at the point <c>relativePoint</c>.</para>
        <para>GetRelativePointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.IsSleeping">
      <summary>Is the rigidbody sleeping?</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.MovePosition(UnityEngine.Vector3)">
      <summary>
        <para>Moves the rigidbody to <c>position</c>.</para>
        <para>Use Rigidbody.MovePosition to move a Rigidbody, complying with the Rigidbody's interpolation setting.If Rigidbody interpolation is enabled on the Rigidbody, calling Rigidbody.MovePosition results in a smooth transition between the two positions in any intermediate frames rendered. This should be used if you want to continuously move a rigidbody in each FixedUpdate.Set Rigidbody.position instead, if you want to teleport a rigidbody from one position to another, with no intermediate positions being rendered.</para>
      </summary>
      <param name="position">The new position for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.MoveRotation(UnityEngine.Quaternion)">
      <summary>
        <para>Rotates the rigidbody to <c>rotation</c>.</para>
        <para>Use Rigidbody.MoveRotation to rotate a Rigidbody, complying with the Rigidbody's interpolation setting.If Rigidbody interpolation is enabled on the Rigidbody, calling Rigidbody.MoveRotation will resulting in a smooth transition between the two positions in any intermediate frames rendered. This should be used if you want to continuously rotate a rigidbody in each FixedUpdate.Set Rigidbody.rotation instead, if you want to teleport a rigidbody from one rotation to another, with no intermediate positions being rendered.</para>
      </summary>
      <param name="rot">The new rotation for the Rigidbody.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.SetDensity(System.Single)">
      <summary>
        <para>Sets the mass based on the attached colliders assuming a constant density.</para>
        <para>This is useful to set the mass to a value which scales with the size of the colliders.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.Sleep">
      <summary>
        <para>Forces a rigidbody to sleep at least one frame.</para>
        <para>A common use is to call this from Awake in order to make a rigidbody sleep at startup.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene.</para>
        <para>This is similar to doing a <see cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" /> for all points contained in any of a Rigidbody's colliders and returning the closest of all hits (if any) reported. This is useful for AI code, say if you need to know that an object would fit through a gap without colliding with anything.Note that this function only works when a primitive collider type (sphere, cube or capsule) is attached to the rigidbody object - mesh colliders will not work, although they can be detected in the scene by the sweep.See Also: <see cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)" />, <see cref="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3)" />.</para>
      </summary>
      <returns>True when the rigidbody sweep intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)" />, but returns all hits.</para>
        <para>The sweep may return multiple hits against the same collider if more then one of the rigidbody's attached colliders would hit it.Note that this function only works when a primitive collider type (sphere, cube or capsule) is attached to the rigidbody object - mesh colliders will not work, although they can be detected in the scene by the sweep.This function can only return up to 128 hits.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.WakeUp">
      <summary>Forces a rigidbody to wake up.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.angularDrag">
      <summary>
        <para>Coefficient of angular drag.</para>
        <para>
          <c>Drag</c> is the tendency of an object to slow down due to friction with the air or water that surrounds it. The <c>angular drag</c> applies to rotational movement and is set up separately from the <c>linear drag</c> that affects positional movement. A higher value of angular drag will cause an object's rotation to come to rest more quickly following a collision or torque.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.angularVelocity" />, <see cref="P:UnityEngine.Rigidbody2D.drag" />, <see cref="P:UnityEngine.Rigidbody.angularDrag" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.angularVelocity">
      <summary>
        <para>Angular velocity in degrees per second.</para>
        <para>Unlike a 3D Rigidbody, a Rigidbody2D can only rotate around one axis (perpendicular to the plane) so the angular velocity is just a float value rather than a vector. Typically, the value of this property is not set directly but rather by applying <c>torques</c> to the rigidbody. The angular velocity will also decrease automatically under the effect of <c>angular drag</c>.See Also: <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.angularDrag" />, <see cref="P:UnityEngine.Rigidbody.angularVelocity" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.centerOfMass">
      <summary>The center of mass of the rigidBody in local space.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.collisionDetectionMode">
      <summary>The method used by the physics engine to check if two objects have collided.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.constraints">
      <summary>
        <para>Controls which degrees of freedom are allowed for the simulation of this <see cref="T:UnityEngine.Rigidbody2D" />.</para>
        <para>By default this is set to RigidbodyConstraints2D.None, allowing rotation and movement along all axes.In some cases, you may want to constrain a <see cref="T:UnityEngine.Rigidbody2D" /> to only move or rotate along some axes. You can use the bitwise OR operator to combine multiple constraints.See Also: <see cref="T:UnityEngine.RigidbodyConstraints2D" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.drag">
      <summary>
        <para>Coefficient of drag.</para>
        <para>
          <c>Drag</c> is the tendency of an object to slow down due to friction with the air or water that surrounds it. The <c>linear drag</c> applies to positional movement and is set up separately from the <c>angular drag</c> that affects rotational movement. A higher value of drag will cause an object's rotation to come to rest more quickly following a collision or force.See Also: <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.angularDrag" />, <see cref="P:UnityEngine.Rigidbody.drag" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.freezeRotation">
      <summary>
        <para>Controls whether physics will change the rotation of the object.</para>
        <para>If freezeRotation is enabled, the rotation in Z is not modified by the physics simulation.See Also: <see cref="P:UnityEngine.Rigidbody2D.constraints" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.gravityScale">
      <summary>
        <para>The degree to which this object is affected by gravity.</para>
        <para>In 2D physics, the gravity is a global setting in the Physics2D class but you can also control the proportion of that gravity applied to each object individually using <c>gravityScale</c>. For example, it may be easier to implement a flying character by turning off its gravity rather than simulating the forces that keep it aloft.See Also: <see cref="P:UnityEngine.Physics2D.gravity" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.inertia">
      <summary>The rigidBody rotational inertia.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.interpolation">
      <summary>
        <para>Physics interpolation used between updates.</para>
        <para>Interpolation is used to estimate the position of the Rigidbody between physics updates. It can be useful to switch this on when the graphics update is much more frequent than the physics update because the object can appear to move along in jerky "hops" rather than having smooth motion. With <c>interpolate</c> mode, motion is smoothed based on the object's positions in previous frames. <c>Extrapolate</c> mode smooths motion based on an estimate of its position in the next frame. The choice of mode depends of the dynamics of the object during gameplay.See Also: <see cref="P:UnityEngine.Rigidbody.interpolation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.isKinematic">
      <summary>
        <para>Should this rigidbody be taken out of physics control?</para>
        <para>If this property is set to true then the rigidbody will stop reacting to collisions and applied forces. This can be useful when an object should usually be controlled "kinematically" (ie, non-physically) but then sometimes needs physics for realism. For example, a human character is usually not implemented using physics but may sometimes be thrown through the air and collide with objects as the result of an impact or explosion.See Also: <see cref="P:UnityEngine.Rigidbody.isKinematic" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.mass">
      <summary>
        <para>Mass of the rigidbody.</para>
        <para>The mass is given in arbitrary units but the basic physical principles of mass apply. From Newton's classic equation force = mass x accelelation, it is apparent that the larger an object's mass, the more force it requires to accelerate it to a given velocity. Also, mass affects momentum, which is significant during collisions; an object with large mass will be moved less by a collision than an object with lower mass.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody.mass" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.position">
      <summary>
        <para>The position of the rigidbody.</para>
        <para>This is the position of the X and Y axis only.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.rotation">
      <summary>
        <para>The rotation of the rigdibody.</para>
        <para>This is the rotation around the Z axis only.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.simulated">
      <summary>
        <para>Indicates whether the rigid body should be simulated or not by the physics system.</para>
        <para>When not simulated, any attached <see cref="T:UnityEngine.Collider2D" /> or <see cref="T:UnityEngine.Joint2D" /> also do not participate in the physics simulation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.sleepMode">
      <summary>
        <para>The sleep state that the rigidbody will initially be in.</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.velocity">
      <summary>
        <para>Linear velocity of the rigidbody.</para>
        <para>The velocity is specified as a vector with components in the X and Y directions (there is no Z direction in 2D physics). The value is not usually set directly but rather by using <c>forces</c>. The velocity can also gradually decay due to the effect of <c>drag</c> if this is enabled.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.drag" />, <see cref="P:UnityEngine.Rigidbody2D.angularVelocity" />, <see cref="P:UnityEngine.Rigidbody.velocity" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.worldCenterOfMass">
      <summary>Gets the center of mass of the rigidBody in global space.</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a force to the rigidbody.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.mass" />, <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="mode">The method used to apply the specified force.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2)">
      <summary>
        <para>Apply a force to the rigidbody.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.mass" />, <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a force at a given position in space.</para>
        <para>The <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" /> function applies a force that acts straight through the rigidbody's centre of mass and so produces only positional movement and no rotation. <c>AddForceAtPosition</c> can apply the force at any position in world space and will typically also apply a <c>torque</c> to the object which will set it rotating. Note that for the purposes of this function, the rigidbody is just a coordinate space of infinite size, so there is no reason why the force needs to be applied within the confines of the object's graphic or colliders.See Also:: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="position">Position in world space to apply the force.</param>
      <param name="mode">The method used to apply the specified force.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Apply a force at a given position in space.</para>
        <para>The <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" /> function applies a force that acts straight through the rigidbody's centre of mass and so produces only positional movement and no rotation. <c>AddForceAtPosition</c> can apply the force at any position in world space and will typically also apply a <c>torque</c> to the object which will set it rotating. Note that for the purposes of this function, the rigidbody is just a coordinate space of infinite size, so there is no reason why the force needs to be applied within the confines of the object's graphic or colliders.See Also:: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="position">Position in world space to apply the force.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddRelativeForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Adds a force to the rigidbody2D relative to its coordinate system.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.mass" />, <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="relativeForce">Components of the force in the X and Y axes.</param>
      <param name="mode">The method used to apply the specified force.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddRelativeForce(UnityEngine.Vector2)">
      <summary>
        <para>Adds a force to the rigidbody2D relative to its coordinate system.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)" />, <see cref="P:UnityEngine.Rigidbody2D.mass" />, <see cref="P:UnityEngine.Rigidbody2D.velocity" />, <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="T:UnityEngine.ForceMode2D" />.</para>
      </summary>
      <param name="relativeForce">Components of the force in the X and Y axes.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a torque at the rigidbody's centre of mass.</para>
        <para>A torque is conceptually a force being applied at the end of an imaginary lever, with the fulcrum at the centre of mass. A torque of five units could thus be equivalent to a force of five units pushing on the end of a lever one unit long, or a force of one unit on a lever five units long. Unity's units are arbitrary but the principle that <c>torque = force x lever length</c> still applies.Note that unlike a 3D Rigidbody, a Rigidbody2D can only rotate in one axis and so torque is a float value rather than a vector.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque to apply.</param>
      <param name="mode">The force mode to use.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddTorque(System.Single)">
      <summary>
        <para>Apply a torque at the rigidbody's centre of mass.</para>
        <para>A torque is conceptually a force being applied at the end of an imaginary lever, with the fulcrum at the centre of mass. A torque of five units could thus be equivalent to a force of five units pushing on the end of a lever one unit long, or a force of one unit on a lever five units long. Unity's units are arbitrary but the principle that <c>torque = force x lever length</c> still applies.Note that unlike a 3D Rigidbody, a Rigidbody2D can only rotate in one axis and so torque is a float value rather than a vector.See Also: <see cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)" />, <see cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)" />.</para>
      </summary>
      <param name="torque">Torque to apply.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetPoint(UnityEngine.Vector2)">
      <summary>Get a local space point given the point <c>point</c> in rigidBody global space.</summary>
      <param name="point">The global space point to transform into local space.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetPointVelocity(UnityEngine.Vector2)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>Point</c> in global space.</para>
        <para>GetPointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
      <param name="point">The global space point to calculate velocity for.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativePoint(UnityEngine.Vector2)">
      <summary>Get a global space point given the point <c>relativePoint</c> in rigidBody local space.</summary>
      <param name="relativePoint">The local space point to transform into global space.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativePointVelocity(UnityEngine.Vector2)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>Point</c> in local space.</para>
        <para>GetRelativePointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
      <param name="relativePoint">The local space point to calculate velocity for.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativeVector(UnityEngine.Vector2)">
      <summary>Get a global space vector given the vector <c>relativeVector</c> in rigidBody local space.</summary>
      <param name="relativeVector">The local space vector to transform into a global space vector.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetVector(UnityEngine.Vector2)">
      <summary>Get a local space vector given the vector <c>vector</c> in rigidBody global space.</summary>
      <param name="vector">The global space vector to transform into a local space vector.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsAwake">
      <summary>
        <para>Is the rigidbody "awake"?</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function tells if the rigidbody is currently awake.See Also: <see cref="M:UnityEngine.Rigidbody2D.Sleep" />, <see cref="M:UnityEngine.Rigidbody2D.WakeUp" />, <see cref="M:UnityEngine.Rigidbody2D.IsSleeping" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsSleeping">
      <summary>
        <para>Is the rigidbody "sleeping"?</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function tells if the rigidbody is currently sleeping.See Also: <see cref="M:UnityEngine.Rigidbody2D.Sleep" />, <see cref="M:UnityEngine.Rigidbody2D.WakeUp" />, <see cref="M:UnityEngine.Rigidbody2D.IsAwake" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouching(UnityEngine.Collider2D)">
      <summary>
        <para>Check whether any of the collider(s) attached to this rigidbody are touching the <c>collider</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching any of the collider(s) attached to this rigidbody.</param>
      <returns>Whether the <c>collider</c> is touching any of the collider(s) attached to this rigidbody or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouchingLayers(System.Int32)">
      <summary>
        <para>Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouchingLayers">
      <summary>
        <para>Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="T:UnityEngine.Collider2D" /> or have moved a <see cref="T:UnityEngine.Collider2D" /> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <returns>Whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.MovePosition(UnityEngine.Vector2)">
      <summary>
        <para>Moves the rigidbody to <c>position</c>.</para>
        <para>Moves the rigidbody to the specified <c>position</c> by calculating the appropriate linear velocity required to move the rigidbody to that position during the next physics update. During the move, neither gravity or linear drag will affect the body. This causes the object to rapidly move from the existing position, through the world, to the specified <c>position</c>.Because this feature allows a rigidbody to be moved rapidly to the specified <c>position</c> through the world, any colliders attached to the rigidbody will react as expected i.e. they will produce collisions and/or triggers. This also means that if the colliders produce a collision then it will affect the rigidbody movement and potentially stop it from reaching the specified <c>position</c> during the next physics update. If the rigidbody is kinematic then any collisions won't affect the rigidbody itself and will only affect any other dynamic colliders.2D rigidbodies have a fixed limit on how fast they can move therefore attempting to move large distances over short time-scales can result in the rigidbody not reaching the specified <c>position</c> during the next physics update. It is recommended that you use this for relatively small distance movements only.It is important to understand that the actual position change will only occur during the next physics update therefore calling this method repeatedly without waiting for the next physics update will result in the last call being used. For this reason, it is recommended that it is called during the FixedUpdate callback.</para>
      </summary>
      <param name="position">The new position for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.MoveRotation(System.Single)">
      <summary>
        <para>Rotates the rigidbody to <c>angle</c> (given in degrees).</para>
        <para>Rotates the rigidbody to the specified <c>angle</c> by calculating the appropriate angular velocity required to rotate the rigidbody to that angle during the next physics update. During the move, angular drag won't affect the body. This causes the object to rapidly move from the existing angle to the specified <c>angle</c>.Because this feature allows a rigidbody to be rotated rapidly to the specified <c>angle</c>, any colliders attached to the rigidbody will react as expected i.e. they will produce collisions and/or triggers. This also means that if the colliders produce a collision then it will affect the rigidbody movement and potentially stop it from reaching the specified <c>angle</c> during the next physics update. If the rigidbody is kinematic then any collisions won't affect the rigidbody itself and will only affect any other dynamic colliders.2D rigidbodies have a fixed limit on how fast they can rotate therefore attempting to rotate large angles over short time-scales can result in the rigidbody not reaching the specified <c>angle</c> during the next physics update. It is recommended that you use this for relatively small rotational movements only.It is important to understand that the actual rotation change will only occur during the next physics update therefore calling this method repeatedly without waiting for the next physics update will result in the last call being used. For this reason, it is recommended that it is called during the FixedUpdate callback.</para>
      </summary>
      <param name="angle">The new rotation angle for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Sleep">
      <summary>
        <para>Make the rigidbody "sleep".</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest.</para>
      </summary>
      <seealso cref="M:UnityEngine.Rigidbody2D.IsSleeping" />
      <seealso cref="M:UnityEngine.Rigidbody2D.WakeUp" />
      <seealso cref="P:UnityEngine.Rigidbody2D.sleepMode" />
    </member>
    <member name="M:UnityEngine.Rigidbody2D.WakeUp">
      <summary>
        <para>Disables the "sleeping" state of a rigidbody.</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function wakes up a rigidbody that is currently sleeping.See Also: <see cref="M:UnityEngine.Rigidbody2D.IsSleeping" />, <see cref="M:UnityEngine.Rigidbody2D.Sleep" />, <see cref="P:UnityEngine.Rigidbody2D.sleepMode" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RuntimeAnimatorController.animationClips">
      <summary>Retrieves all AnimationClip used by the controller.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.airMouseConnected">
      <summary>Returns true if there is an air mouse available.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.gamePadMode">
      <summary>Changes the type of input the gamepad produces.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.gestureMode">
      <summary>Changes the type of input the gesture camera produces.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.gestureWorking">
      <summary>Returns true if the camera sees a hand.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.touchPadMode">
      <summary>The type of input the remote's touch pad produces.</summary>
    </member>
    <member name="M:UnityEngine.SamsungTV.SetSystemLanguage(UnityEngine.SystemLanguage)">
      <summary>Set the system language that is returned by Application.SystemLanguage.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.OpenAPI.serverType">
      <summary>The server type. Possible values: Developing, Development, Invalid, Operating.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.OpenAPI.timeOnTV">
      <summary>Get local time on TV.</summary>
    </member>
    <member name="P:UnityEngine.SamsungTV.OpenAPI.uid">
      <summary>Get UID from TV.</summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToLandscapeLeft">
      <summary>
        <para>Allow auto-rotation to landscape left?</para>
        <para>This setting is taken into account when <see cref="P:UnityEngine.Screen.orientation" /> is set to <see cref="F:UnityEngine.ScreenOrientation.AutoRotation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToLandscapeRight">
      <summary>
        <para>Allow auto-rotation to landscape right?</para>
        <para>This setting is taken into account when <see cref="P:UnityEngine.Screen.orientation" /> is set to <see cref="F:UnityEngine.ScreenOrientation.AutoRotation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToPortrait">
      <summary>
        <para>Allow auto-rotation to portrait?</para>
        <para>This setting is taken into account when <see cref="P:UnityEngine.Screen.orientation" /> is set to <see cref="F:UnityEngine.ScreenOrientation.AutoRotation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToPortraitUpsideDown">
      <summary>
        <para>Allow auto-rotation to portrait, upside down?</para>
        <para>This setting is taken into account when <see cref="P:UnityEngine.Screen.orientation" /> is set to <see cref="F:UnityEngine.ScreenOrientation.AutoRotation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.currentResolution">
      <summary>
        <para>The current screen resolution (Read Only).</para>
        <para>If the player is running in window mode, this returns the current resolution of the desktop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.dpi">
      <summary>
        <para>The current DPI of the screen / device (Read Only).</para>
        <para>This is the actual DPI of the screen attached or physical device running the application. May return 0 if unable to determine the current DPI.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.fullScreen">
      <summary>
        <para>Is the game running fullscreen?</para>
        <para>It is possible to toggle fullscreen mode by changing this property:</para>
        <para>A fullscreen switch does not happen immediately; it will actually happen when the current frame is finished.See Also: <see cref="M:UnityEngine.Screen.SetResolution(System.Int32,System.Int32,System.Boolean,System.Int32)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.height">
      <summary>
        <para>The current height of the screen window in pixels (Read Only).</para>
        <para>This is the actual height of the player window (in fullscreen it is also the current resolution).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.orientation">
      <summary>
        <para>Specifies logical orientation of the screen.</para>
        <para>Default value is taken from the 'Default Orientation' in Player Settings. As an example, if we take 480x320 resolution on iPhone, horizontal orientation is treated as 480x320 resolution and vertical orientation as 320x480.Note: logical orientation affects not only screen orientation, but also touch coordinates. You should expect drastic changes in the touch positions after changing logical orientation, since touch positions will be rotated clockwise or counter-clockwise to match screen coordinates.Currently screen orientation is only relevant on mobile platforms.</para>
        <para>If the value is set to <see cref="F:UnityEngine.ScreenOrientation.AutoRotation" /> then the screen will select from any of the options (enabled by <see cref="P:UnityEngine.Screen.autorotateToPortrait" />, etc) automatically as the device orientation changes.See Also: <see cref="T:UnityEngine.ScreenOrientation" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.resolutions">
      <summary>
        <para>All fullscreen resolutions supported by the monitor (Read Only).</para>
        <para>The returned resolutions are sorted by width, lower resolutions come first. Note that the array will always be empty on Android devices since the resolution is variable (within reason) and so there is no restricted set of resolutions to choose from.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.sleepTimeout">
      <summary>
        <para>A power saving setting, allowing the screen to dim some time after the last active user interaction.</para>
        <para>Most useful for handheld devices, allowing OS to preserve battery life in most efficient ways. Does nothing on non-handheld devices.sleepTimeout is measured in seconds. The default value varies from platform to platform, generally being non-zero.On mobile devices it would be useful to set sleepTimeout to [SleepTimeout.NeverSleep] for games using accelerometer as the main source of input. However, such games should allow screen dimming while in menu or paused. Currently you will only be able to set this property to one of the values predefined in [SleepTimeout] class. A get will return either one of the predefined values, or the actual number of seconds until screen gets dimmed, as specified in system preferences of the device.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.width">
      <summary>
        <para>The current width of the screen window in pixels (Read Only).</para>
        <para>This is the actual width of the player window (in fullscreen it is also the current resolution).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Screen.SetResolution(System.Int32,System.Int32,System.Boolean,System.Int32)">
      <summary>
        <para>Switches the screen resolution.</para>
        <para>A <c>width</c> by <c>height</c> resolution will be used. If no matching resolution is supported, the closest one will be used.If <c>preferredRefreshRate</c> is 0 (default) Unity will switch to the highest refresh rate supported by the monitor. If <c>preferredRefreshRate</c> is not 0 Unity will use it if the monitor supports it, otherwise will choose the highest supported one.In the web player you may only switch resolutions after the user has clicked on the content. The recommended way of doing it is to switch resolutions only when the user clicks on a designated button.On Android <c>fullscreen</c> controls the SYSTEM_UI_FLAG_LOW_PROFILE flag to View.setSystemUiVisibility(), on devices running Honeycomb (OS 3.0 / API 11) or later.On Windows Store Apps, switching to non-native resolution is only supported starting from Windows 8.1 and newer.A resolution switch does not happen immediately; it will actually happen when the current frame is finished.</para>
      </summary>
      <seealso cref="P:UnityEngine.Screen.resolutions" />
    </member>
    <member name="M:UnityEngine.Screen.SetResolution(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Switches the screen resolution.</para>
        <para>A <c>width</c> by <c>height</c> resolution will be used. If no matching resolution is supported, the closest one will be used.If <c>preferredRefreshRate</c> is 0 (default) Unity will switch to the highest refresh rate supported by the monitor. If <c>preferredRefreshRate</c> is not 0 Unity will use it if the monitor supports it, otherwise will choose the highest supported one.In the web player you may only switch resolutions after the user has clicked on the content. The recommended way of doing it is to switch resolutions only when the user clicks on a designated button.On Android <c>fullscreen</c> controls the SYSTEM_UI_FLAG_LOW_PROFILE flag to View.setSystemUiVisibility(), on devices running Honeycomb (OS 3.0 / API 11) or later.On Windows Store Apps, switching to non-native resolution is only supported starting from Windows 8.1 and newer.A resolution switch does not happen immediately; it will actually happen when the current frame is finished.</para>
      </summary>
      <seealso cref="P:UnityEngine.Screen.resolutions" />
    </member>
    <member name="M:UnityEngine.ScriptableObject.CreateInstance(System.String)">
      <summary>Creates an instance of a scriptable object with <c>className</c>.</summary>
    </member>
    <member name="M:UnityEngine.ScriptableObject.CreateInstance(System.Type)">
      <summary>Creates an instance of a scriptable object with <c>type</c>.</summary>
    </member>
    <member name="M:UnityEngine.ScriptableObject.CreateInstance``1">
      <summary>Creates an instance of a scriptable object with <c>T</c>.</summary>
    </member>
    <member name="M:UnityEngine.Security.GetChainOfTrustValue(System.String)">
      <summary>Get secret from Chain of Trust system.</summary>
      <param name="name">The name of the secret.</param>
      <returns>The secret.</returns>
    </member>
    <member name="M:UnityEngine.Security.LoadAndVerifyAssembly(System.Byte[],System.String)">
      <summary>Loads an assembly and checks that it is allowed to be used in the webplayer.Note: The single argument version of this API will always issue an error message. An authorisation key is always needed.</summary>
      <param name="assemblyData">Assembly to verify.</param>
      <param name="authorizationKey">Public key used to verify assembly.</param>
      <returns>Loaded, verified, assembly, or null if the assembly cannot be verfied.</returns>
    </member>
    <member name="M:UnityEngine.Security.LoadAndVerifyAssembly(System.Byte[])">
      <summary>Loads an assembly and checks that it is allowed to be used in the webplayer.Note: The single argument version of this API will always issue an error message. An authorisation key is always needed.</summary>
      <param name="assemblyData">Assembly to verify.</param>
      <returns>Loaded, verified, assembly, or null if the assembly cannot be verfied.</returns>
    </member>
    <member name="M:UnityEngine.Security.PrefetchSocketPolicy(System.String,System.Int32,System.Int32)">
      <summary>
        <para>Prefetch the webplayer socket security policy from a non-default port number.</para>
        <para>Socket connections attempted in a webplayer need to be validated by a socket policy. When the policy is hosted on a port different than the default port number (843) it needs to be explicitly fetched with this API call before any socket connections are attempted. The timeout argument is in milliseconds.The return value indicates if a policy was successfully retrieved or not.See more about the webplayer security sandbox in the manual.</para>
      </summary>
      <param name="ip">IP address of server.</param>
      <param name="atPort">Port from where socket policy is read.</param>
      <param name="timeout">Time to wait for response.</param>
    </member>
    <member name="M:UnityEngine.Security.PrefetchSocketPolicy(System.String,System.Int32)">
      <summary>
        <para>Prefetch the webplayer socket security policy from a non-default port number.</para>
        <para>Socket connections attempted in a webplayer need to be validated by a socket policy. When the policy is hosted on a port different than the default port number (843) it needs to be explicitly fetched with this API call before any socket connections are attempted. The timeout argument is in milliseconds.The return value indicates if a policy was successfully retrieved or not.See more about the webplayer security sandbox in the manual.</para>
      </summary>
      <param name="ip">IP address of server.</param>
      <param name="atPort">Port from where socket policy is read.</param>
    </member>
    <member name="P:UnityEngine.Shader.globalMaximumLOD">
      <summary>Shader LOD level for all shaders.</summary>
    </member>
    <member name="P:UnityEngine.Shader.isSupported">
      <summary>
        <para>Can this shader run on the end-users graphics card? (Read Only)</para>
        <para>Returns true if the shader itself or any fallbacks setup in the shader are supported. Most often you use this when implementing special effects. For example, image effects automatically disable themselves if the shader is not supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Shader.maximumLOD">
      <summary>Shader LOD level for this shader.</summary>
    </member>
    <member name="P:UnityEngine.Shader.renderQueue">
      <summary>Render queue of this shader. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.Shader.DisableKeyword(System.String)">
      <summary>
        <para>Unset a global shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Material.DisableKeyword(System.String)" />), or globally set shader keywords (<see cref="M:UnityEngine.Shader.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />).See Also: <see cref="M:UnityEngine.Shader.EnableKeyword(System.String)" />, multiple shader program variants.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.EnableKeyword(System.String)">
      <summary>
        <para>Set a global shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="M:UnityEngine.Material.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Material.DisableKeyword(System.String)" />), or globally set shader keywords (<see cref="M:UnityEngine.Shader.EnableKeyword(System.String)" /> and <see cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />).See Also: <see cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />, multiple shader program variants.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.Find(System.String)">
      <summary>
        <para>Finds a shader with the given <c>name</c>.</para>
        <para>Shader.Find can be used to switch to another shader without having to keep a reference to the shader. <c>name</c> is the name you can see in the shader popup of any material, for example "Standard", "Unlit/Texture", "Legacy Shaders/Diffuse" etc.Note that a shader might be not included into the player build if nothing references it! In that case, Shader.Find will work only in the editor, and will result in pink "missing shader" materials in the player build. Because of that, it is advisable to use shader references instead of finding them by name. To make sure a shader is included into the game build, do either of: 1) reference it from some of the materials used in your scene, 2) add it under "Always Included Shaders" list in ProjectSettings/Graphics or 3) put shader or something that references it (e.g. a Material) into a "Resources" folder.See Also: <see cref="T:UnityEngine.Material" /> class.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.IsKeywordEnabled(System.String)">
      <summary>Is global shader keyword enabled?</summary>
      <seealso cref="M:UnityEngine.Shader.EnableKeyword(System.String)" />
      <seealso cref="M:UnityEngine.Shader.DisableKeyword(System.String)" />
    </member>
    <member name="M:UnityEngine.Shader.PropertyToID(System.String)">
      <summary>
        <para>Gets unique identifier for a shader property name.</para>
        <para>Using property identifiers is more efficient than passing strings to all material property functions. For example if you are calling Material.SetColor a lot, or using <see cref="T:UnityEngine.MaterialPropertyBlock" />, then it is better to get the identifiers of the properties you need just once.Each name of shader property (for example, <c>_MainTex</c> or <c>_Color</c>) is assigned an unique integer number in Unity, that stays the same for the whole game. The numbers will not be the same between different runs of the game or between machines, so do not store them or send them over network.See Also: <see cref="T:UnityEngine.Material" />, <see cref="T:UnityEngine.MaterialPropertyBlock" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets a global compute buffer property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).See Also: <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />, <see cref="T:UnityEngine.ComputeBuffer" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Sets a global color property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" color (for example, color of the sun). Then you can set the global property from script and don't have to setup the same color in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets a global color property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" color (for example, color of the sun). Then you can set the global property from script and don't have to setup the same color in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      <summary>
        <para>Sets a global float property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" float (for example, density of some custom fog type). Then you can set the global property from script and don't have to setup the same float in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloat(System.Int32,System.Single)">
      <summary>
        <para>Sets a global float property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" float (for example, density of some custom fog type). Then you can set the global property from script and don't have to setup the same float in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalInt(System.String,System.Int32)">
      <summary>
        <para>Sets a global int property for all shaders.</para>
        <para>Internally float and integer shader properties are treated exactly the same, so this function is just an alias to <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalInt(System.Int32,System.Int32)">
      <summary>
        <para>Sets a global int property for all shaders.</para>
        <para>Internally float and integer shader properties are treated exactly the same, so this function is just an alias to <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a global matrix property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a global matrix property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Sets a global texture property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" texture (for example, custom diffuse-lighting cubemap). Then you can set the global property from script and don't have to setup the same texture in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Sets a global texture property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" texture (for example, custom diffuse-lighting cubemap). Then you can set the global property from script and don't have to setup the same texture in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Sets a global vector property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" vector (for example, wind direction). Then you can set the global property from script and don't have to setup the same vector in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a global vector property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).Usually this is used if you have a set of custom shaders that all use the same "global" vector (for example, wind direction). Then you can set the global property from script and don't have to setup the same vector in all materials.See Also: <see cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)" />, <see cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)" />, <see cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)" />; <see cref="T:UnityEngine.Material" /> class, ShaderLab documentation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.WarmupAllShaders">
      <summary>
        <para>Fully load all shaders to prevent future performance hiccups.</para>
        <para>Usually graphics drivers do not actually prepare shaders until they are first needed. However when some object is first rendered with a previously unused shader, there can be a hiccup because the driver is compiling/optimizing the shader. This can be quite noticeable, especially on mobile platforms.Calling this function will perform dummy one-invisible-triangle rendering with all variants of all currently loaded shaders. This can take some time but helps to avoid hiccups in the future. Generally it is better to use <see cref="T:UnityEngine.ShaderVariantCollection" /> for a more granular shader warmup control.Please be aware that this function will only warmup shaders that are currently loaded. If you use Resources.Load to load shaders, you will need to call WarmupAllShaders again.See Also: <see cref="T:UnityEngine.ShaderVariantCollection" /> for a more granular shader warmup control.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.isWarmedUp">
      <summary>Is this ShaderVariantCollection already warmed up? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.shaderCount">
      <summary>Number of shaders in this collection (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.variantCount">
      <summary>Number of total varians in this collection (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.#ctor">
      <summary>Create a new empty shader variant collection.</summary>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.WarmUp" />
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)">
      <summary>Adds a new shader variant to the collection.</summary>
      <param name="variant">Shader variant to add.</param>
      <returns>False if already in the collection.</returns>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Contains(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.Clear">
      <summary>Remove all shader variants from the collection.</summary>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.Contains(UnityEngine.ShaderVariantCollection.ShaderVariant)">
      <summary>Checks if a shader variant is in the collection.</summary>
      <param name="variant">Shader variant to check.</param>
      <returns>True if the variant is in the collection.</returns>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)">
      <summary>Adds shader variant from the collection.</summary>
      <param name="variant">Shader variant to add.</param>
      <returns>False if was not in the collection.</returns>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Contains(UnityEngine.ShaderVariantCollection.ShaderVariant)" />
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.WarmUp">
      <summary>
        <para>Fully load shaders in ShaderVariantCollection.</para>
        <para>Often graphics drivers do not actually prepare shaders until they are first needed. However when some object is first rendered with a previously unused shader, there can be a hiccup because the driver is compiling/optimizing the shader. This can be quite noticeable, especially on mobile platforms.Calling this function will perform dummy one-invisible-triangle rendering for the shaders and their variants in this ShaderVariantCollection. You can setup to do that automatically during game load time (in Graphics Settings), or manually call this function at appropriate times (e.g. when loading a new level).Calling WarmUp on a ShaderVariantCollection that is already warmed up will do nothing.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.keywords">
      <summary>Array of shader keywords to use in this variant.</summary>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.passType">
      <summary>Pass type to use in this variant.</summary>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.shader">
      <summary>Shader to use in this variant.</summary>
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.ShaderVariant.#ctor(UnityEngine.Shader,UnityEngine.Rendering.PassType,System.String[])">
      <summary>
        <para>Creates a ShaderVariant structure.</para>
        <para>Note that this will throw an ArgumentException if shader is null, pass type does not exist or variant with the passed keywords is not found.See Also: <see cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.name">
      <summary>The name of the Transform mapped to the bone.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.position">
      <summary>The T-pose position of the bone in local space.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.rotation">
      <summary>The T-pose rotation of the bone in local space.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.scale">
      <summary>The T-pose scaling of the bone in local space.</summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.bones">
      <summary>
        <para>The bones used to skin the mesh.</para>
        <para>See the code example for Mesh.bindposes for further details.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.localBounds">
      <summary>
        <para>AABB of this Skinned Mesh in its local space.</para>
        <para>It is precomputed on import for imported models based on animations associated with that model, which means that the bounding box might be much bigger than the mesh itself. It is recomputed every time when <see cref="P:UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen" /> is enabled, but in this case it would be exactly the size of the mesh at that frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.quality">
      <summary>The maximum number of bones affecting a single vertex.</summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.sharedMesh">
      <summary>The mesh used for skinning.</summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen">
      <summary>If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.</summary>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.BakeMesh(UnityEngine.Mesh)">
      <summary>
        <para>Creates a snapshot of SkinnedMeshRenderer and stores it in <c>mesh</c>.</para>
        <para>The vertices are relative to the SkinnedMeshRenderer Transform component. Note that the snapshot is still computed even when <see cref="P:UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen" /> is set to false and the skinned mesh object is currently offscreen.</para>
      </summary>
      <param name="mesh">A static mesh that will receive the snapshot of the skinned mesh.</param>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.GetBlendShapeWeight(System.Int32)">
      <summary>
        <para>Returns weight of BlendShape on this renderer.</para>
        <para>Index must be smaller than <see cref="P:UnityEngine.Mesh.blendShapeCount" /> of a mesh attached to this renderer. At weight 0 BlendShape has no influence, at weight 1 BlendShape is fully active, but weight is not limited to [0; 1] range.See Also: <see cref="M:UnityEngine.SkinnedMeshRenderer.SetBlendShapeWeight(System.Int32,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.SetBlendShapeWeight(System.Int32,System.Single)">
      <summary>
        <para>Sets weight of BlendShape on this renderer.</para>
        <para>Index must be smaller than <see cref="P:UnityEngine.Mesh.blendShapeCount" /> of a mesh attached to this renderer. At weight 0 BlendShape has no influence, at weight 1 BlendShape is fully active, but weight is not limited to [0; 1] range.See Also: <see cref="M:UnityEngine.SkinnedMeshRenderer.GetBlendShapeWeight(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Skybox.material">
      <summary>The material used by the skybox.</summary>
    </member>
    <member name="F:UnityEngine.SleepTimeout.NeverSleep">
      <summary>Prevent screen dimming.</summary>
    </member>
    <member name="F:UnityEngine.SleepTimeout.SystemSetting">
      <summary>
        <para>Set the sleep timeout to whatever the user has specified in the system settings.</para>
        <para>Useful when restoring back to the state the system was in before running your app.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.angle">
      <summary>
        <para>The angle of the line in space (in degrees).</para>
        <para>The line along which the joint can slide is specified by its world angle and optionally by endpoint limits along its length.See Also: <see cref="P:UnityEngine.SliderJoint2D.limits" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.jointSpeed">
      <summary>The current joint speed.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.jointTranslation">
      <summary>The current joint translation.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.limits">
      <summary>
        <para>Restrictions on how far the joint can slide in each direction along the line.</para>
        <para>The line along which the joint can slide is specified by its angle (relative to the coordinate system) and optionally by endpoint limits along its length.See Also: <see cref="P:UnityEngine.SliderJoint2D.angle" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.limitState">
      <summary>Gets the state of the joint limit.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.motor">
      <summary>Parameters for a motor force that is applied automatically to the Rigibody2D along the line.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.referenceAngle">
      <summary>The angle (in degrees) referenced between the two bodies used as the constraint for the joint.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.useLimits">
      <summary>Should motion limits be used?</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.useMotor">
      <summary>Should a motor force be applied automatically to the Rigidbody2D?</summary>
    </member>
    <member name="M:UnityEngine.SliderJoint2D.GetMotorForce(System.Single)">
      <summary>Gets the motor force of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor force for.</param>
    </member>
    <member name="P:UnityEngine.Social.Active">
      <summary>
        <para>This is the currently active social platform.</para>
        <para>If not explicitly set, a default is picked depending on the target platform.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Social.localUser">
      <summary>
        <para>The local user (potentially not logged in).</para>
        <para>Until the user logs in or authenticates himself the profile data will be invalid and no other Social API functionality will work.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Social.CreateAchievement">
      <summary>Create an IAchievement instance.</summary>
    </member>
    <member name="M:UnityEngine.Social.CreateLeaderboard">
      <summary>Create an ILeaderboard instance.</summary>
    </member>
    <member name="M:UnityEngine.Social.LoadAchievementDescriptions">
      <summary>
        <para>Loads the achievement descriptions accociated with this application.</para>
        <para>This is usually set up outside Unity on some external service provided by the implementation provider. For example, when using GameCenter you need to set up the achievements using iTunes Connect.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Social.LoadAchievements">
      <summary>Load the achievements the logged in user has already achieved or reported progress on.</summary>
    </member>
    <member name="M:UnityEngine.Social.LoadScores(System.String)">
      <summary>
        <para>Load a default set of scores from the given leaderboard.</para>
        <para>This uses default leaderboard parameters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Social.LoadUsers(System.String[])">
      <summary>Load the user profiles accociated with the given array of user IDs.</summary>
    </member>
    <member name="M:UnityEngine.Social.ReportProgress(System.String,System.Double)">
      <summary>
        <para>Reports the progress of an achievement.</para>
        <para>The achievement ID number must match an achievement description associated with this application. Reporting a progress of 0.0 usually means the achievement can be shown if it was hidden before. Depending on the platform, partial progress cannot always be reported, in which case 100.0 is the only other value which can be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Social.ReportScore(System.Int64,System.String)">
      <summary>Report a score to a specific leaderboard.</summary>
    </member>
    <member name="M:UnityEngine.Social.ShowAchievementsUI">
      <summary>Show a default/system view of the games achievements.</summary>
    </member>
    <member name="M:UnityEngine.Social.ShowLeaderboardUI">
      <summary>Show a default/system view of the games leaderboards.</summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.bounciness">
      <summary>
        <para>When the joint hits the limit, it can be made to bounce off it.</para>
        <para>Bounciness determines how much to bounce off an limit. range { 0, 1 }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.contactDistance">
      <summary>
        <para>Determines how far ahead in space the solver can "see" the joint limit.</para>
        <para>Distance inside the limit value at which the limit will be considered to be active by the solver. For translational joints the unit is meters. For rotational joints the unit is degrees. Setting this low can cause jittering, but might run faster. Setting this high can reduce jittering, but might run slower. Jointed objects will still fall asleep correctly. 0 = use defaultsPipeline: .</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.limit">
      <summary>The limit position/angle of the joint (in degrees).</summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimitSpring.damper">
      <summary>
        <para>The damping of the spring limit. In effect when the stiffness of the sprint limit is not zero.</para>
        <para>{ 0, infinity }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimitSpring.spring">
      <summary>
        <para>The stiffness of the spring limit. When stiffness is zero the limit is hard, otherwise soft.</para>
        <para>{ 0, infinity }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.layers">
      <summary>Returns all the layers defined in this project.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.id">
      <summary>This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.name">
      <summary>Returns the name of the layer as defined in the TagManager.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.value">
      <summary>
        <para>This is the relative value that indicates the sort order of this layer relative to the other layers.</para>
        <para>You may use this to determine the sort order of the layer.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SortingLayer.GetLayerValueFromID(System.Int32)">
      <summary>Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.</summary>
      <param name="id">The unique value of the sorting layer as returned by any renderer's sortingLayerID property.</param>
      <returns>The final sorting value of the layer relative to other layers.</returns>
      <seealso cref="M:UnityEngine.SortingLayer.GetLayerValueFromName(System.String)" />
    </member>
    <member name="M:UnityEngine.SortingLayer.GetLayerValueFromName(System.String)">
      <summary>Returns the final sorting layer value.</summary>
      <param name="name">The unique value of the sorting layer as returned by any renderer's sortingLayerID property.</param>
      <returns>The final sorting value of the layer relative to other layers.</returns>
      <seealso cref="M:UnityEngine.SortingLayer.GetLayerValueFromID(System.Int32)" />
    </member>
    <member name="M:UnityEngine.SortingLayer.IDToName(System.Int32)">
      <summary>Returns the unique id of the layer. Will return "&lt;unknown layer&gt;" if an invalid id is given.</summary>
      <param name="id">The unique id of the layer.</param>
      <returns>The name of the layer with <c>id</c> or "&lt;unknown layer&gt;" for invalid id.</returns>
    </member>
    <member name="M:UnityEngine.SortingLayer.IsValid(System.Int32)">
      <summary>Returns true if the id provided is a valid layer id.</summary>
      <param name="id">The unique id of a layer.</param>
      <returns>True if the <c>id</c> provided is valid and assigned to a layer.</returns>
    </member>
    <member name="M:UnityEngine.SortingLayer.NameToID(System.String)">
      <summary>Returns the id given the name. Will return 0 if an invalid name was given.</summary>
      <param name="name">The name of the layer.</param>
      <returns>The unique id of the layer with <c>name</c>.</returns>
    </member>
    <member name="P:UnityEngine.SparseTexture.isCreated">
      <summary>
        <para>Is the sparse texture actually created? (Read Only)</para>
        <para>Sparse texture contents can become "lost", mostly on graphics device change or active color space switch. When that happens, isCreated will start returning false - meaning you should recreate all the needed tiles again.See Also: <see cref="T:UnityEngine.SparseTexture" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SparseTexture.tileHeight">
      <summary>
        <para>Get sparse texture tile height (Read Only).</para>
        <para>After creating the sparse texture, query the tile size with <see cref="P:UnityEngine.SparseTexture.tileWidth" /> &amp; <see cref="P:UnityEngine.SparseTexture.tileHeight" />. Tile sizes are platform and GPU dependent.See Also: <see cref="T:UnityEngine.SparseTexture" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SparseTexture.tileWidth">
      <summary>
        <para>Get sparse texture tile width (Read Only).</para>
        <para>After creating the sparse texture, query the tile size with <see cref="P:UnityEngine.SparseTexture.tileWidth" /> &amp; <see cref="P:UnityEngine.SparseTexture.tileHeight" />. Tile sizes are platform and GPU dependent.See Also: <see cref="T:UnityEngine.SparseTexture" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SparseTexture.#ctor(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Int32)">
      <summary>
        <para>Create a sparse texture.</para>
        <para>See <see cref="T:UnityEngine.SparseTexture" />.</para>
      </summary>
      <param name="width">Texture width in pixels.</param>
      <param name="height">Texture height in pixels.</param>
      <param name="format">Texture format.</param>
      <param name="mipCount">Mipmap count. Pass -1 to create full mipmap chain.</param>
    </member>
    <member name="M:UnityEngine.SparseTexture.#ctor(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Int32,System.Boolean)">
      <summary>
        <para>Create a sparse texture.</para>
        <para>See <see cref="T:UnityEngine.SparseTexture" />.</para>
      </summary>
      <param name="width">Texture width in pixels.</param>
      <param name="height">Texture height in pixels.</param>
      <param name="format">Texture format.</param>
      <param name="mipCount">Mipmap count. Pass -1 to create full mipmap chain.</param>
      <param name="linear">Whether texture data will be in linear or sRGB color space (default is sRGB).</param>
    </member>
    <member name="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Unload sparse texture tile.</para>
        <para>This function removes a tile at (tileX,tileY) coordinates from memory. If a tile is not present, then this function does nothing.See Also: <see cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])" />.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
    </member>
    <member name="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      <summary>
        <para>Update sparse texture tile with color values.</para>
        <para>This function makes a tile at (tileX,tileY) coordinates resident in memory, and updates its pixels. If a tile is already resident, then only the pixels are updated.Data passed should have enough pixels for the tile (tileWidth*tileHeight elements). Exception can be small mipmap levels that are smaller than tile size; then it's ok to pass enough data for the mip level size.UpdateTile only works for non-compressed color formats. If you use a sparse texture with a compressed format, use <see cref="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])" /> and pass raw tile data bytes (e.g. DXT-compressed data). UpdateTileRaw can also be more efficient if texture format is not RGBA32, as then Unity does not have to convert from Color32 data into the underlying texture format.See Also: <see cref="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)" />, <see cref="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])" />.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
      <param name="data">Tile color data.</param>
    </member>
    <member name="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])">
      <summary>
        <para>Update sparse texture tile with raw pixel values.</para>
        <para>This function behaves just like <see cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])" />, except the data you pass already needs to be in the final texture format. This is mostly useful for compressed sparse textures, where you'd want to load already precompressed tile data.See Also: <see cref="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)" />, <see cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])" />.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
      <param name="data">Tile raw pixel data.</param>
    </member>
    <member name="P:UnityEngine.SphereCollider.center">
      <summary>The center of the sphere in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.SphereCollider.radius">
      <summary>
        <para>The radius of the sphere measured in the object's local space.</para>
        <para>The sphere radius will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.metallic">
      <summary>
        <para>The metallic value of the splat layer.</para>
        <para>This is only applicable when using the built-in standard material for terrain. Valid range is 0.0f to 1.0f.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.normalMap">
      <summary>Normal map of the splat applied to the Terrain.</summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.smoothness">
      <summary>
        <para>The smoothness value of the splat layer when the main texture has no alpha channel.</para>
        <para>This is only applicable when using the built-in standard material for terrain. Valid range is 0.0f to 1.0f.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.texture">
      <summary>Texture of the splat applied to the Terrain.</summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.tileOffset">
      <summary>Offset of the tile texture of the SplatPrototype.</summary>
    </member>
    <member name="P:UnityEngine.SplatPrototype.tileSize">
      <summary>Size of the tile used in the texture of the SplatPrototype.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.damper">
      <summary>The damper force used to dampen the spring force.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.maxDistance">
      <summary>
        <para>The maximum distance between the bodies relative to their initial distance.</para>
        <para>The distanced that will be maintained, will be kept between minDistance and maxDistance. Both values are relative to the distance between the center of masses when the scene was first loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.minDistance">
      <summary>
        <para>The minimum distance between the bodies relative to their initial distance.</para>
        <para>The distanced that will be maintained, will be kept between minDistance and maxDistance. Both values are relative to the distance between the center of masses when the scene was first loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.spring">
      <summary>The spring force used to keep the two objects together.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.dampingRatio">
      <summary>
        <para>The amount by which the spring force is reduced in proportion to the movement speed.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to reestablish the desired distance between the objects. The higher the damping ratio, the quicker the oscillation will die down to zero.See Also: <see cref="P:UnityEngine.SpringJoint2D.frequency" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.distance">
      <summary>The distance the spring will try to keep between the two objects.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.frequency">
      <summary>
        <para>The frequency at which the spring oscillates around the distance distance between the objects.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to reestablish the desired distance between the objects. A <c>damping ratio</c> can be set to cause this oscillation to die down over time.See Also: <see cref="P:UnityEngine.SpringJoint2D.dampingRatio" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SpringJoint2D.GetReactionForce(System.Single)">
      <summary>Gets the reaction force of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction force for.</param>
    </member>
    <member name="M:UnityEngine.SpringJoint2D.GetReactionTorque(System.Single)">
      <summary>Gets the reaction torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the reaction torque for.</param>
    </member>
    <member name="P:UnityEngine.Sprite.border">
      <summary>
        <para>Returns the border sizes of the sprite.</para>
        <para>X=left, Y=bottom, Z=right, W=top.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Sprite.bounds">
      <summary>Bounds of the Sprite, specified by its center and extents in world space units.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packed">
      <summary>Returns true if this Sprite is packed in an atlas.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packingMode">
      <summary>If Sprite is packed (see <see cref="P:UnityEngine.Sprite.packed" />), returns its SpritePackingMode.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packingRotation">
      <summary>If Sprite is packed (see <see cref="P:UnityEngine.Sprite.packed" />), returns its SpritePackingRotation.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.pivot">
      <summary>Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.pixelsPerUnit">
      <summary>The number of pixels in the sprite that correspond to one unit in world space. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Sprite.rect">
      <summary>Location of the Sprite on the original Texture, specified in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.texture">
      <summary>Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.textureRect">
      <summary>Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.textureRectOffset">
      <summary>Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.triangles">
      <summary>
        <para>Returns a copy of the array containing sprite mesh triangles.</para>
        <para>The array is a list of triangles that contains indices into the vertex array.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Sprite.uv">
      <summary>The base texture coordinates of the sprite mesh.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.vertices">
      <summary>Returns a copy of the array containing sprite mesh vertex positions.</summary>
    </member>
    <member name="M:UnityEngine.Sprite.OverrideGeometry(UnityEngine.Vector2[],System.UInt16[])">
      <summary>
        <para>Sets up new Sprite geometry.</para>
        <para>Vertex positions are in Sprite.rect space - 0 to Rect.size. Pivot offset and transformation to unit space is done automatically.The size of the triangle array must always be a multiple of 3. Vertices can be shared by simply indexing into the same vertex.Sprite UVs are calculated automatically by mapping the provided geometry onto the Sprite texture.See Also: <see cref="P:UnityEngine.Sprite.rect" />.</para>
      </summary>
      <param name="vertices">Array of vertex positions in Sprite Rect space.</param>
      <param name="triangles">Array of sprite mesh triangle indices.</param>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2,System.Single)">
      <summary>Create a new Sprite object.</summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.color">
      <summary>
        <para>Rendering color for the Sprite graphic.</para>
        <para>Becomes the vertex color and can be accessed in a pixel shader.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.sprite">
      <summary>The Sprite to render.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateMachineEnter(UnityEngine.Animator,System.Int32)">
      <summary>Called on the first Update frame when a transition from a state from another statemachine transition to one of this statemachine's state.</summary>
      <param name="animator">The Animator playing this state machine.</param>
      <param name="stateMachinePathHash">The full path hash for this state machine.</param>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateMachineExit(UnityEngine.Animator,System.Int32)">
      <summary>Called on the last Update frame when one of the statemachine's state is transitionning toward another state in another state machine.</summary>
      <param name="animator">The Animator playing this state machine.</param>
      <param name="stateMachinePathHash">The full path hash for this state machine.</param>
    </member>
    <member name="M:UnityEngine.StaticBatchingUtility.Combine(UnityEngine.GameObject)">
      <summary>
        <para>Combine will prepare all children of the <c>staticBatchRoot</c> for static batching.</para>
        <para>Once combined children can NOT change their <c>Transform</c> properties, however <c>staticBatchRoot</c> can be moved.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.StaticBatchingUtility.Combine(UnityEngine.GameObject[],UnityEngine.GameObject)">
      <summary>
        <para>Combine will prepare all <c>gos</c> for the static batching. <c>staticBatchRoot</c> will be treated as their parent.</para>
        <para>Once combined <c>gos</c> can NOT change their <c>Transform</c> properties, however <c>staticBatchRoot</c> can be moved.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.forceScale">
      <summary>
        <para>The scale of the impulse force applied while attempting to reach the surface speed.</para>
        <para>0 stops any impulse force, whereas 1 uses the full impulse force.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.speed">
      <summary>
        <para>The speed to be maintained along the surface.</para>
        <para>This <c>speed</c> will be maintained by applying continually applying impulse forces to the target <see cref="T:UnityEngine.Rigidbody2D" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.speedVariation">
      <summary>
        <para>The speed variation (from zero to the variation) added to base speed to be applied.</para>
        <para>A random value between 0 and <c>speedVariation</c> is used and added to the speed. The <c>speedVariation</c> can be negative to randomly reduce the speed.See Also: <see cref="P:UnityEngine.SurfaceEffector2D.speed" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useBounce">
      <summary>
        <para>Should bounce be used for any contact with the surface?</para>
        <para>When false, no bounce is used from any assigned physics material. When true, any existing bounce is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useContactForce">
      <summary>
        <para>Should the impulse force but applied to the contact point?</para>
        <para>When true, the force is applied to the contact point which may cause the target to rotate. When off, the force is applied to the center-of-mass, therefore no rotation is produced.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useFriction">
      <summary>
        <para>Should friction be used for any contact with the surface?</para>
        <para>When false, no friction is used from any assigned physics material. When true, any existing friction is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceModel">
      <summary>
        <para>The model of the device (Read Only).</para>
        <para>Possible examples: <c>iPhone3,1</c> or <c>iPod4,1</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceName">
      <summary>
        <para>The user defined name of the device (Read Only).</para>
        <para>Note that on Android, this property is not supported and always contains the string "&lt;unknown&gt;". You should use the <see cref="P:UnityEngine.SystemInfo.deviceModel" /> instead to identify an Android device.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceType">
      <summary>
        <para>Returns the kind of device the application is running on.</para>
        <para>See <see cref="T:UnityEngine.DeviceType" /> enumeration for possible values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceUniqueIdentifier">
      <summary>
        <para>A unique device identifier. It is guaranteed to be unique for every device (Read Only).</para>
        <para>iOS: on pre-iOS7 devices it will return hash of MAC address. On iOS7 devices it will be UIDevice identifierForVendor or, if that fails for any reason, ASIdentifierManager advertisingIdentifier. Windows Store Apps: uses AdvertisingManager::AdvertisingId for returning unique device identifier, if option in 'PC Settings -&gt; Privacy -&gt; Let apps use my advertising ID for experiences across apps (turning this off will reset your ID)' is disabled, Unity will fallback to HardwareIdentification::GetPackageSpecificToken().Id.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceID">
      <summary>
        <para>The identifier code of the graphics device (Read Only).</para>
        <para>This is the PCI device ID of the user's graphics card. Together with SystemInfo.graphicsDeviceVendorID, this number uniquely identifies a particular graphics card model. The number is the same across operating systems and driver versions.Note that device IDs are only implemented on PC (Windows/Mac/Linux) platforms; on other platforms you'll have to do name-based detection if needed.See <c>pcidatabase.com</c> for a list of device IDs.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVendorID" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceName" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceName">
      <summary>
        <para>The name of the graphics device (Read Only).</para>
        <para>This is the name of user's graphics card, as reported by the graphics driver.</para>
        <para>Note that the same graphics card can be reported by different names depending on the operating system, driver and so on. If you want to reliably identify some specific card, use SystemInfo.graphicsDeviceID SystemInfo.graphicsDeviceVendorID.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceID" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVendor" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVersion" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceType">
      <summary>The graphics API type used by the graphics device (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVendor">
      <summary>
        <para>The vendor of the graphics device (Read Only).</para>
        <para>This is the vendor of user's graphics card, as reported by the graphics driver.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceName" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVersion" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVendorID">
      <summary>
        <para>The identifier code of the graphics device vendor (Read Only).</para>
        <para>This is the PCI vendor ID of the user's graphics card. This number uniquely identifies a particular graphics card maker. The number is the same across operating systems and driver versions.Note that device IDs are only implemented on PC (Windows/Mac/Linux) platforms; on other platforms you'll have to do name-based detection if needed.See <c>pcidatabase.com</c> for a list of vendor IDs.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceID" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVendor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVersion">
      <summary>
        <para>The graphics API type and driver version used by the graphics device (Read Only).</para>
        <para>Returns a string identifying low-level graphics API kind and driver version. In most cases when you need to detect which graphics API is being used it is much easier to use <see cref="P:UnityEngine.SystemInfo.graphicsDeviceType" />.In case of OpenGL API, the returned string will contain "<c>OpenGL</c>" followed by version in "<c>major.minor</c>" format, followed by full version string in square brackets.In case of Direct3D9 API, the returned string will contain "<c>Direct3D 9.0c</c>" followed by driver name and version in square brackets.In case of Direct3D11 API, the returned string will contain "<c>Direct3D 11.0</c>" followed by feature level in square brackets.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsDeviceType" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceName" />, <see cref="P:UnityEngine.SystemInfo.graphicsDeviceVendor" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsMemorySize">
      <summary>
        <para>Amount of video memory present (Read Only).</para>
        <para>This is the approximate amount of graphics memory in megabytes.See Also: <see cref="P:UnityEngine.SystemInfo.systemMemorySize" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsMultiThreaded">
      <summary>
        <para>Is graphics device using multi-threaded rendering (Read Only)?</para>
        <para>On many platforms Unity can use multi-threaded rendering, where actual calls to underlying graphics API are done on a separate thread. Normally you do not have to worry about this, except if you're making native code rendering plugins. In that case, you need to make sure your plugin also does rendering calls on the right thread; use GL.IssuePluginEvent for that.See Also: GL.IssuePluginEvent, Native Plugin Interface.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsShaderLevel">
      <summary>
        <para>Graphics device shader capability level (Read Only).</para>
        <para>This is approximate "shader capability" level of the graphics device, expressed in DirectX shader model terms. Possible values are:50 Shader Model 5.0 (DX11.0) 41 Shader Model 4.1 (DX10.1) 40 Shader Model 4.0 (DX10.0) 30 Shader Model 3.0 20 Shader Model 2.x.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.npotSupport">
      <summary>What NPOT (ie, non-power of two resolution) support does the GPU provide? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.operatingSystem">
      <summary>Operating system name with version (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.processorCount">
      <summary>
        <para>Number of processors present (Read Only).</para>
        <para>This is number of processors as reported by the operating system. The processors could be separate processors, cores of the same processor, or logical processors (e.g. in case of one Hyper-Threaded CPU, this would report two CPUs since that's what it looks like to the system).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.processorType">
      <summary>Processor name (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      <summary>How many simultaneous render targets (MRTs) are supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supports3DTextures">
      <summary>Are 3D (volume) textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsAccelerometer">
      <summary>Is an accelerometer available on the device?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsComputeShaders">
      <summary>Are compute shaders supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsGyroscope">
      <summary>Is a gyroscope available on the device?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsImageEffects">
      <summary>
        <para>Are image effects supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card supports image postprocessing effects.See Also: Image Effects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsInstancing">
      <summary>
        <para>Is GPU draw call instancing supported? (Read Only)</para>
        <para>Currently only Graphics.DrawProcedural and Graphics.DrawProceduralIndirect use instancing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsLocationService">
      <summary>
        <para>Is the device capable of reporting its location?</para>
        <para>This property does not provide a detailed information on what kind of sensor can be used, it can use all kinds of underlying technology with varying accuracy.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsRenderTextures">
      <summary>
        <para>Are render textures supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card supports Render Textures in general. Use SystemInfo.SupportsRenderTextureFormat to check for support for specific render texture format.See Also: Render Texture assets, <see cref="T:UnityEngine.RenderTexture" /> class.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsRenderToCubemap">
      <summary>
        <para>Are cubemap render textures supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card supports render into cubemap Render Textures.See Also: Render Texture assets, <see cref="T:UnityEngine.RenderTexture" /> class.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsShadows">
      <summary>
        <para>Are built-in shadows supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card has support for built-in shadows.See Also: Shadows documentation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsSparseTextures">
      <summary>Are sparse textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsStencil">
      <summary>Is the stencil buffer supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsVibration">
      <summary>Is the device capable of providing the user haptic feedback by vibration?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.systemMemorySize">
      <summary>
        <para>Amount of system memory present (Read Only).</para>
        <para>This is the approximate amount of system memory in megabytes.Note: This function is not supported on Windows Store Apps and will always return 0.See Also: <see cref="P:UnityEngine.SystemInfo.graphicsMemorySize" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Is render texture format supported?</para>
        <para>Returns <c>true</c> if graphics card supports given <see cref="T:UnityEngine.RenderTextureFormat" />.See Also: Render Texture assets, <see cref="T:UnityEngine.RenderTexture" /> class.</para>
      </summary>
      <param name="format">The format to look up.</param>
      <returns>True if the format is supported.</returns>
    </member>
    <member name="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)">
      <summary>
        <para>Is texture format supported on this device?</para>
        <para>It is good practice to check that the device supports a texture format before using it.See Also: <see cref="T:UnityEngine.TextureFormat" /> enum.</para>
      </summary>
      <param name="format">The <see cref="T:UnityEngine.TextureFormat" /> format to look up.</param>
      <returns>True if the format is supported.</returns>
    </member>
    <member name="P:UnityEngine.Terrain.activeTerrain">
      <summary>The active terrain. This is a convenience function to get to the main terrain in the scene.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.activeTerrains">
      <summary>The active terrains in the scene.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.bakeLightProbesForTrees">
      <summary>Specifies if an array of internal light probes should be baked for terrain trees. Available only in editor.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.basemapDistance">
      <summary>
        <para>Heightmap patches beyond basemap distance will use a precomputed low res basemap.</para>
        <para>This improves performance for far away patches. Close up Unity renders the heightmap using splat maps by blending between any amount of provided terrain textures.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.castShadows">
      <summary>Should terrain cast shadows?.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.collectDetailPatches">
      <summary>
        <para>Collect Detail patches from memory.</para>
        <para>If enabled the detail patches in the Terrain will be removed from memory when not visible. If the property is set to false, the patches are kept in memory until the Terrain object is destroyed or the collectDetailPatches property is set to true. By setting the property to false all the detail patches for a given density will be initialized and kept in memory. Changing the density will recreate the patches.Note that Detail Patches can use a large amount of memory, therefore this property when set to false can increase the memory usage of your application significantly. In most cases you don't need to set this property to false (default behavior).See Also: <see cref="P:UnityEngine.Terrain.detailObjectDensity" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.detailObjectDensity">
      <summary>
        <para>Density of detail objects.</para>
        <para>This number goes from 0.0 to 1.0, with 1.0 being the original density, and lower numbers resulting in less detail objects being rendered.See Also: <see cref="P:UnityEngine.Terrain.detailObjectDistance" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.detailObjectDistance">
      <summary>Detail objects will be displayed up to this distance.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.drawHeightmap">
      <summary>Specify if terrain heightmap should be drawn.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.drawTreesAndFoliage">
      <summary>Specify if terrain trees and details should be drawn.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.heightmapMaximumLOD">
      <summary>
        <para>Lets you essentially lower the heightmap resolution used for rendering.</para>
        <para>This can be used on low end cards to never display the highest lod terrain. A value of 0 means always showing highest detail. A value of 1 means the triangle count will be reduced to 1/4th. The heightmap resolution will be halved for width and height.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.heightmapPixelError">
      <summary>
        <para>An approximation of how many pixels the terrain will pop in the worst case when switching lod.</para>
        <para>A higher value reduces the number of polygons drawn.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.legacyShininess">
      <summary>
        <para>The shininess value of the terrain.</para>
        <para>You can use it to control the overall shininess value across the whole terrain when <see cref="P:UnityEngine.Terrain.materialType" /> is <see cref="F:UnityEngine.Terrain.MaterialType.BuiltInLegacySpecular" />. The valid range of this value is 0.0f to 1.0f.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.legacySpecular">
      <summary>
        <para>The specular color of the terrain.</para>
        <para>You can use it to control the overall specular color across the whole terrain when <see cref="P:UnityEngine.Terrain.materialType" /> is <see cref="F:UnityEngine.Terrain.MaterialType.BuiltInLegacySpecular" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.lightmapIndex">
      <summary>The index of the baked lightmap applied to this terrain.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.lightmapScaleOffset">
      <summary>The UV scale &amp; offset used for a baked lightmap.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.materialTemplate">
      <summary>
        <para>The custom material used to render the terrain.</para>
        <para>You can use this variable to give the terrain a custom material to render with. For the material to be actually applied, you also need to set <see cref="P:UnityEngine.Terrain.materialType" /> to <see cref="F:UnityEngine.Terrain.MaterialType.Custom" />. No copy of the custom material is made internally, so modifying materialTemplate will affect all terrain objects using the same material.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.materialType">
      <summary>
        <para>The type of the material used to render the terrain. Could be one of the built-in types or custom. See <see cref="T:UnityEngine.Terrain.MaterialType" />.</para>
        <para>If you want to use a custom material, set this to <see cref="F:UnityEngine.Terrain.MaterialType.Custom" />, then assign a material to <see cref="P:UnityEngine.Terrain.materialTemplate" />. Terrain.MaterialType.Custom with Terrain.materialTemplate == null is identical to <see cref="F:UnityEngine.Terrain.MaterialType.BuiltInLegacyDiffuse" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.realtimeLightmapIndex">
      <summary>The index of the realtime lightmap applied to this terrain.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.realtimeLightmapScaleOffset">
      <summary>The UV scale &amp; offset used for a realtime lightmap.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.reflectionProbeUsage">
      <summary>
        <para>How reflection probes are used for terrain. See <see cref="T:UnityEngine.Rendering.ReflectionProbeUsage" />.</para>
        <para>If enabled and reflection probes are present in the scene, a reflection texture will be picked for the terrain object and set as a uniform for the shader. Not applicable to materials using built-in Legacy shaders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.terrainData">
      <summary>The Terrain Data that stores heightmaps, terrain textures, detail meshes and trees.</summary>
    </member>
    <member name="P:UnityEngine.Terrain.treeBillboardDistance">
      <summary>
        <para>Distance from the camera where trees will be rendered as billboards only.</para>
        <para>Decreasing this value improves performance but makes the transition look worse because the difference between billboards and trees will be more obvious.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.treeCrossFadeLength">
      <summary>
        <para>Total distance delta that trees will use to transition from billboard orientation to mesh orientation.</para>
        <para>Decreasing this value makes the transition happen faster. Setting it to 0 will produce a visible pop when switching from mesh to billboard representation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.treeDistance">
      <summary>
        <para>The maximum distance at which trees are rendered.</para>
        <para>The higher this is, the further the distance trees can be seen and the slower it will run.See Also: Terrain.treeBillboardDistance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Terrain.treeMaximumFullLODCount">
      <summary>
        <para>Maximum number of trees rendered at full LOD.</para>
        <para>This is an easy setting to prevent too many trees being rendered at too high resolution in dense forests. Since there will be no fade if <c>treeMaximumFullLODCount</c> is exceeded you should tweak the <c>treeBillboardDistance</c> to not include unnecessary trees that are not being seen but, still rendered.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Terrain.AddTreeInstance(UnityEngine.TreeInstance)">
      <summary>Adds a tree instance to the terrain.</summary>
    </member>
    <member name="M:UnityEngine.Terrain.ApplyDelayedHeightmapModification">
      <summary>Update the terrain's LOD and vegetation information after making changes with <see cref="M:UnityEngine.TerrainData.SetHeightsDelayLOD(System.Int32,System.Int32,System.Single[,])" />.</summary>
    </member>
    <member name="M:UnityEngine.Terrain.Flush">
      <summary>Flushes any change done in the terrain so it takes effect.</summary>
    </member>
    <member name="M:UnityEngine.Terrain.GetClosestReflectionProbes">
      <summary>
        <para>Fills the list with reflection probes whose AABB intersects with terrain's AABB. Their weights are also provided. Weight shows how much influence the probe has on the terrain, and is used when the blending between multiple reflection probes occurs.</para>
        <para>This function won't touch <c>result</c> if <see cref="P:UnityEngine.Terrain.reflectionProbeUsage" /> is <see cref="F:UnityEngine.Rendering.ReflectionProbeUsage.Off" />, otherwise the original content of the list will be cleared.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Terrain.GetPosition">
      <summary>Get the position of the terrain.</summary>
    </member>
    <member name="M:UnityEngine.Terrain.SampleHeight(UnityEngine.Vector3)">
      <summary>Samples the height at the given position defined in world space, relative to the terrain space.</summary>
    </member>
    <member name="M:UnityEngine.Terrain.SetNeighbors(UnityEngine.Terrain,UnityEngine.Terrain,UnityEngine.Terrain,UnityEngine.Terrain)">
      <summary>
        <para>Lets you setup the connection between neighboring Terrains.</para>
        <para>This ensures LOD matches up on neighboring terrains. Note that it is not enough to call this function on one Terrain, you need to set the neighbors of each terrain.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Terrain.CreateTerrainGameObject(UnityEngine.TerrainData)">
      <summary>Creates a Terrain including collider from <see cref="T:UnityEngine.TerrainData" />.</summary>
    </member>
    <member name="P:UnityEngine.TerrainCollider.terrainData">
      <summary>The terrain that stores the heightmap.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.alphamapHeight">
      <summary>Height of the alpha map.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.alphamapLayers">
      <summary>Number of alpha map layers.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.alphamapResolution">
      <summary>Resolution of the alpha map.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.alphamapTextures">
      <summary>Alpha map textures used by the Terrain. Used by Terrain Inspector for undo.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.alphamapWidth">
      <summary>Width of the alpha map.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.baseMapResolution">
      <summary>Resolution of the base map used for rendering far patches on the terrain.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.detailHeight">
      <summary>Detail height of the TerrainData.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.detailPrototypes">
      <summary>Contains the detail texture/meshes that the terrain has.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.detailResolution">
      <summary>Detail Resolution of the TerrainData.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.detailWidth">
      <summary>Detail width of the TerrainData.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.heightmapHeight">
      <summary>Height of the terrain in samples (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.heightmapResolution">
      <summary>Resolution of the heightmap.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.heightmapScale">
      <summary>The size of each heightmap sample.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.heightmapWidth">
      <summary>Width of the terrain in samples (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.size">
      <summary>The total size in world units of the terrain.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.splatPrototypes">
      <summary>
        <para>Splat texture used by the terrain.</para>
        <para>These are the ground textures.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TerrainData.thickness">
      <summary>
        <para>The thickness of the terrain used for collision detection.</para>
        <para>This lets the physics engine know how thick the Terrain is when used with a TerrainCollider. Any other colliders which are no less then thickness units underneath the Terrain will be considered to collide with the terrain, and will be moved above the terrain.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TerrainData.treeInstanceCount">
      <summary>Returns the number of tree instances.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.treeInstances">
      <summary>Contains the current trees placed in the terrain.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.treePrototypes">
      <summary>
        <para>The list of tree prototypes this are the ones available in the inspector.</para>
        <para>If you change any value here, you should call TerrainData.RefreshPrototypes so the changes take effect.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TerrainData.wavingGrassAmount">
      <summary>Amount of waving grass in the terrain.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.wavingGrassSpeed">
      <summary>Speed of the waving grass.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.wavingGrassStrength">
      <summary>Strength of the waving grass in the terrain.</summary>
    </member>
    <member name="P:UnityEngine.TerrainData.wavingGrassTint">
      <summary>Color of the waving grass that the terrain has.</summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetAlphamaps(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Returns the alpha map at a position x, y given a width and height.</para>
        <para>The returned array is three-dimensional - the first two dimensions represent x and y coordinates on the map, while the third denotes the splatmap texture to which the alphamap is applied.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetDetailLayer(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Returns a 2D array of the detail object density in the specific location.</para>
        <para>The Terrain system uses detail layer density maps. Each map is essentially a grayscale image where each pixel value denotes the number of detail objects that will be procedurally placed terrain area. That corresponds to the pixel. Since several different detail types may be used, the map is arranged into "layers" - the array indices of the layers are determined by the order of the detail types defined in the Terrain inspector (ie, when the Paint Details tool is selected).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetHeight(System.Int32,System.Int32)">
      <summary>Gets the height at a certain point x,y.</summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetHeights(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get an array of heightmap samples.</para>
        <para>Returns a two dimensional array of heightmap samples. The samples are represented as float values ranging from 0 to 1. The array has the dimensions [height,width] and is indexed as [y,x].</para>
      </summary>
      <param name="xBase">First x index of heightmap samples to retrieve.</param>
      <param name="yBase">First y index of heightmap samples to retrieve.</param>
      <param name="width">Number of samples to retrieve along the heightmap's x axis.</param>
      <param name="height">Number of samples to retrieve along the heightmap's y axis.</param>
    </member>
    <member name="M:UnityEngine.TerrainData.GetInterpolatedHeight(System.Single,System.Single)">
      <summary>Gets an interpolated height at a point x,y.</summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetInterpolatedNormal(System.Single,System.Single)">
      <summary>
        <para>Get an interpolated normal at a given location.</para>
        <para>The <c>x</c> and <c>y</c> values are normalized coordinates in the range 0..1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetSteepness(System.Single,System.Single)">
      <summary>
        <para>Gets the gradient of the terrain at point &amp;amp;amp;amp;lt;x,y&amp;amp;amp;amp;gt;.</para>
        <para>The <c>x</c> and <c>y</c> values are normalized coordinates in the range 0..1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetSupportedLayers(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Returns an array of all supported detail layer indices in the area.</para>
        <para>The Terrain uses a detail layer density map. Each pixel in the map determines the amount of details objects that will be procedurally placed in the pixel area. The layer determines the detail prototype that will be instantiated at the location.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.GetTreeInstance(System.Int32)">
      <summary>Get the tree instance at the specified index. It is used as a faster version of <see cref="P:UnityEngine.TerrainData.treeInstances" />[index] as this function doesn't create the entire tree instances array.</summary>
      <param name="index">The index of the tree instance.</param>
    </member>
    <member name="M:UnityEngine.TerrainData.RefreshPrototypes">
      <summary>
        <para>Reloads all the values of the available prototypes (ie, detail mesh assets) in the TerrainData Object.</para>
        <para>This can be used in editor scripts to update the terrain when the prototype assets change, much like the Terrain &gt; Refresh Tree and Detail Prototypes menu command.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.SetAlphamaps(System.Int32,System.Int32,System.Single[,,])">
      <summary>
        <para>Assign all splat values in the given map area.</para>
        <para>The array supplied to this function determines the width and height of the portion to be replaced. The third dimension of the array corresponds to the number of splatmap textures.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.SetDetailLayer(System.Int32,System.Int32,System.Int32,System.Int32[,])">
      <summary>
        <para>Sets the detail layer density map.</para>
        <para>The Terrain system uses detail layer density maps. Each map is essentially a grayscale image where each pixel value denotes the number of detail objects that will be procedurally placed terrain area that corresponds to the pixel. Since several different detail types may be used, the map is arranged into "layers" - the array indices of the layers are determined by the order of the detail types defined in the Terrain inspector (ie, when the Paint Details tool is selected).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TerrainData.SetDetailResolution(System.Int32,System.Int32)">
      <summary>Set the resolution of the detail map.</summary>
      <param name="detailResolution">Specifies the number of pixels in the detail resolution map. A larger detailResolution, leads to more accurate detail object painting.</param>
      <param name="resolutionPerPatch">Specifies the size in pixels of each individually rendered detail patch. A larger number reduces draw calls, but might increase triangle count since detail patches are culled on a per batch basis. A recommended value is 16. If you use a very large detail object distance and your grass is very sparse, it makes sense to increase the value.</param>
    </member>
    <member name="M:UnityEngine.TerrainData.SetHeights(System.Int32,System.Int32,System.Single[,])">
      <summary>
        <para>Set an array of heightmap samples.</para>
        <para>Sets heightmap data using a two dimensional array of heightmap samples. The samples are represented as float values ranging from 0 to 1. The area affected is defined by the array dimensions and starts at xBase and yBase. The heights array is indexed as [y,x].This method recomputes all the LOD and vegetation information for the terrain on each call, which can be computationally expensive. In interactive editing scenarios, it may be better to call <see cref="M:UnityEngine.TerrainData.SetHeightsDelayLOD(System.Int32,System.Int32,System.Single[,])" /> instead, followed by <see cref="M:UnityEngine.Terrain.ApplyDelayedHeightmapModification" /> when the user completes an editing action.</para>
      </summary>
      <param name="xBase">First x index of heightmap samples to set.</param>
      <param name="yBase">First y index of heightmap samples to set.</param>
      <param name="heights">Array of heightmap samples to set (values range from 0 to 1, array indexed as [y,x]).</param>
    </member>
    <member name="M:UnityEngine.TerrainData.SetHeightsDelayLOD(System.Int32,System.Int32,System.Single[,])">
      <summary>
        <para>Set an array of heightmap samples.</para>
        <para>Sets heightmap data using a two dimensional array of heightmap samples. The samples are represented as float values ranging from 0 to 1. The area affected is defined by the array dimensions and starts at xBase and yBase. The heights array is indexed as [y,x].Unlike <see cref="M:UnityEngine.TerrainData.SetHeights(System.Int32,System.Int32,System.Single[,])" />, this method does not update the LOD information for the terrain, or any trees/vegetation objects; this means the terrain may be temporarily rendered at an inappropriately high level of detail, but makes the method fast enough to be used in interactive editing scenarios. Once modifications to the terrain have been completed - for example, when the user releases the mouse button - call <see cref="M:UnityEngine.Terrain.ApplyDelayedHeightmapModification" /> to update all the LOD and vegetation information.</para>
      </summary>
      <param name="xBase">First x index of heightmap samples to set.</param>
      <param name="yBase">First y index of heightmap samples to set.</param>
      <param name="heights">Array of heightmap samples to set (values range from 0 to 1, array indexed as [y,x]).</param>
    </member>
    <member name="M:UnityEngine.TerrainData.SetTreeInstance(System.Int32,UnityEngine.TreeInstance)">
      <summary>Set the tree instance with new parameters at the specified index. However, <see cref="F:UnityEngine.TreeInstance.prototypeIndex" /> and <see cref="F:UnityEngine.TreeInstance.position" /> can not be changed otherwise an ArgumentException will be thrown.</summary>
      <param name="index">The index of the tree instance.</param>
      <param name="instance">The new TreeInstance value.</param>
    </member>
    <member name="P:UnityEngine.TextAsset.bytes">
      <summary>
        <para>The raw bytes of the text asset. (Read Only)</para>
        <para>If you're using the text asset to contain binary data, you should make sure the file has the .bytes extension. For any other of the extentions the TextImporter will try to strip nonascii characters if it is unable to parse the file as an utf8 string.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextAsset.text">
      <summary>The text contents of the .txt file as a string. (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.color">
      <summary>The base color for the text generation.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.font">
      <summary>Font to use for generation.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.fontSize">
      <summary>Font size.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.fontStyle">
      <summary>Font style.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.generateOutOfBounds">
      <summary>Continue to generate characters even if the text runs out of bounds.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.generationExtents">
      <summary>Extents that the generator will attempt to fit the text in.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.horizontalOverflow">
      <summary>What happens to text when it reaches the horizontal generation bounds.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.lineSpacing">
      <summary>
        <para>The line spacing multiplier.</para>
        <para>This is multiplied with the line spacing defined in the font.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.pivot">
      <summary>Generated vertices are offset by the pivot.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.resizeTextForBestFit">
      <summary>Should the text be resized to fit the configured bounds?</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.resizeTextMaxSize">
      <summary>Maximum size for resized text.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.resizeTextMinSize">
      <summary>Minimum size for resized text.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.richText">
      <summary>Allow rich text markup in generation.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.scaleFactor">
      <summary>A scale factor for the text. This is useful if the <see cref="T:UnityEngine.UI.Text" /> is on a <see cref="T:UnityEngine.Canvas" /> and the canvas is scaled.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.textAnchor">
      <summary>How is the generated text anchored.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.updateBounds">
      <summary>Should the text generator update the bounds from the generated text.</summary>
    </member>
    <member name="F:UnityEngine.TextGenerationSettings.verticalOverflow">
      <summary>What happens to text when it reaches the bottom generation bounds.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.characterCount">
      <summary>The number of characters that have been generated.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.characterCountVisible">
      <summary>The number of characters that have been generated and are included in the visible lines.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.characters">
      <summary>Array of generated characters.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.fontSizeUsedForBestFit">
      <summary>The size of the font that was found if using best fit mode.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.lineCount">
      <summary>Number of text lines generated.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.lines">
      <summary>Information about each generated text line.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.rectExtents">
      <summary>Extents of the generated text in rect format.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.vertexCount">
      <summary>Number of vertices generated.</summary>
    </member>
    <member name="P:UnityEngine.TextGenerator.verts">
      <summary>Array of generated vertices.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.#ctor">
      <summary>Create a TextGenerator.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.#ctor(System.Int32)">
      <summary>Create a TextGenerator.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetCharacters">
      <summary>Populate the given List with UICharInfo.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetCharactersArray">
      <summary>Returns the current UICharInfo.</summary>
      <returns>Character information.</returns>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetLines">
      <summary>Populate the given list with UILineInfo.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetLinesArray">
      <summary>Returns the current UILineInfo.</summary>
      <returns>Line information.</returns>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetPreferredHeight(System.String,UnityEngine.TextGenerationSettings)">
      <summary>Given a string and settings, returns the preferred height for a container that would hold this text.</summary>
      <param name="str">Generation text.</param>
      <param name="settings">Settings for generation.</param>
      <returns>Preferred height.</returns>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetPreferredWidth(System.String,UnityEngine.TextGenerationSettings)">
      <summary>Given a string and settings, returns the preferred width for a container that would hold this text.</summary>
      <param name="str">Generation text.</param>
      <param name="settings">Settings for generation.</param>
      <returns>Preferred width.</returns>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetVertices">
      <summary>Populate the given list with generated Vertices.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.GetVerticesArray">
      <summary>Returns the current UILineInfo.</summary>
      <returns>Vertices.</returns>
    </member>
    <member name="M:UnityEngine.TextGenerator.Invalidate">
      <summary>Mark the text generator as invalid. This will force a full text generation the next time Populate is called.</summary>
    </member>
    <member name="M:UnityEngine.TextGenerator.Populate(System.String,UnityEngine.TextGenerationSettings)">
      <summary>
        <para>Will generate the vertices and other data for the given string with the given settings.</para>
        <para>Will only regenrate if the string AND settings are differernt from the last execution.</para>
      </summary>
      <param name="str">String to generate.</param>
      <param name="settings">Settings.</param>
    </member>
    <member name="P:UnityEngine.TextMesh.alignment">
      <summary>How lines of text are aligned (Left, Right, Center).</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.anchor">
      <summary>Which point of the text shares the position of the Transform.</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.characterSize">
      <summary>The size of each character (This scales the whole text).</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.color">
      <summary>
        <para>The color used to render the text.</para>
        <para>This is the base color used to render the text. &lt;color&gt; tags in rich text markup will override this.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextMesh.font">
      <summary>The <see cref="T:UnityEngine.Font" /> used.</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.fontSize">
      <summary>
        <para>The font size to use (for dynamic fonts).</para>
        <para>If this is set to a non-zero value, the font size specified in the font importer is overriden with a custom size. This is only supported for fonts set to use dynamic font rendering. Other fonts will always use the default font size.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextMesh.fontStyle">
      <summary>
        <para>The font style to use (for dynamic fonts).</para>
        <para>If this is set to a value other then normal, the font style set in the font importer is overriden with a custom style. This is only supported for fonts set to use dynamic font rendering. Other fonts will always render in normal style.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextMesh.lineSpacing">
      <summary>How much space will be in-between lines of text.</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.offsetZ">
      <summary>How far should the text be offset from the transform.position.z when drawing.</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.richText">
      <summary>
        <para>Enable HTML-style tags for Text Formatting Markup.</para>
        <para>Supported tags are: &lt;color="htmlcolor"&gt;colored text&lt;/color&gt;, where "htmlcolor" is a html color string, like "#ff0000" or "red". &lt;b&gt;bold text&lt;/b&gt; &lt;i&gt;italic text&lt;/i&gt; &lt;size=20&gt;sized text&lt;/size&gt; &lt;material=1&gt;render using custom material index&lt;/material&gt; &lt;quad material=1 size=20 x=0.1 y=0.1 width=0.5 height=0.5/&gt;, to render a single quad using the given material and UVs, used for embedding images in text. These are only supported for fonts set to use dynamic font rendering, except for the 'color', 'material' and 'quad' tags.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextMesh.tabSize">
      <summary>How much space will be inserted for a tab '\t' character. This is a multiplum of the 'spacebar' character offset.</summary>
    </member>
    <member name="P:UnityEngine.TextMesh.text">
      <summary>The text that is displayed.</summary>
    </member>
    <member name="P:UnityEngine.Texture.anisoLevel">
      <summary>
        <para>Anisotropic filtering level of the texture.</para>
        <para>Anisotropic filtering makes textures look better when viewed at a shallow angle, but comes at a performance cost in the graphics hardware. Usually you use it on floor, ground or road textures to make them look better.The value range of this variable goes from 1 to 9, where 1 equals no filtering applied and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at shallow angles. Lower values mean the texture will be more blurry at shallow angles.See Also: texture assets.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.filterMode">
      <summary>Filtering mode of the texture.</summary>
    </member>
    <member name="P:UnityEngine.Texture.height">
      <summary>Height of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Texture.mipMapBias">
      <summary>
        <para>Mip map bias of the texture.</para>
        <para>A positive bias makes a texture appear extra blurry, while a negative bias sharpens the texture. Note that using large negative bias can reduce performance, so it's not recommended to use more than -0.5 negative bias. In most cases better sharpening of the texture can be achieved by using anisotropic filtering. Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms, e.g., OpenGL ES based do not support it without custom shaders.See Also: <see cref="P:UnityEngine.Texture.anisoLevel" />, texture assets.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.width">
      <summary>Width of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Texture.wrapMode">
      <summary>
        <para>Wrap mode (Repeat or Clamp) of the texture.</para>
        <para>Set the texture to clamp at the borders to avoid warping artifacts with TextureWrapMode.Clamp. Or tile the texture with TextureWrapMode.Repeat.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture.GetNativeTexturePtr">
      <summary>
        <para>Retrieve native ('hardware') pointer to a texture.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to a particular texture as it is represented on the native graphics device level. This can be used to enable texture manipulation from native code plugins.On Direct3D-like devices this returns a pointer to the base texture type (IDirect3DBaseTexture9 on D3D9, ID3D11Resource on D3D11). On OpenGL-like devices the GL texture "name" is returned; cast the pointer to integer type to get it. On Metal, the id&lt;MTLTexture&gt; pointer is returned. On platforms that do not support native code plugins, this function always returns NULL.Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up needed texture pointers only at initialization time.See Also: Native code plugins, <see cref="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture.SetGlobalAnisotropicFilteringLimits(System.Int32,System.Int32)">
      <summary>
        <para>Sets Anisotropic limits.</para>
        <para>ForcedMin value controls the minimal anisotropy level set when Anisotropy is forced. globalMax value controls the max possible anisotropy level. set any to -1 to use default values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.blackTexture">
      <summary>
        <para>Get a small texture with all black pixels.</para>
        <para>All pixels of this texture will be opaque black (0,0,0,1).See Also: <see cref="P:UnityEngine.Texture2D.whiteTexture" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.whiteTexture">
      <summary>
        <para>Get a small texture with all white pixels.</para>
        <para>All pixels of this texture will be opaque white (1,1,1,1).See Also: <see cref="P:UnityEngine.Texture2D.blackTexture" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.mipmapCount">
      <summary>
        <para>How many mipmap levels are in this texture (Read Only).</para>
        <para>The returned value includes the base level as well, so it is always 1 or more.Mipmap count is used if you use <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" /> or <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> to fetch or modify the different mip levels. For example, you could change a texture so that each mip level is tinted in a different color - then in the game you'd see which mip levels are actually visible.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" /> function, <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.#ctor(System.Int32,System.Int32)">
      <summary>
        <para>Create a new empty texture.</para>
        <para>The texture will be <c>width</c> by <c>height</c> size, with an ARGB32 <see cref="T:UnityEngine.TextureFormat" />, with mipmaps and in sRGB color space.Usually you will want to set the colors of the texture after creating it, using <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> and <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> functions.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Texture2D.#ctor(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean)">
      <summary>
        <para>Create a new empty texture.</para>
        <para>The texture will be <c>width</c> by <c>height</c> size, with a given <c>format</c>, with mipmaps or without and in either the linear or sRGB color space.Usually you will want to set the colors of the texture after creating it, using <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> and <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> functions.See Also: <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />. By default <c>updateMipmaps</c> is set to <c>true</c>.If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture2D.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />. By default <c>updateMipmaps</c> is set to <c>true</c>.If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture2D.Apply">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" /> and <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />. By default <c>updateMipmaps</c> is set to <c>true</c>.If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture2D.Compress(System.Boolean)">
      <summary>
        <para>Compress texture into DXT format.</para>
        <para>Use this to compress textures generated at runtime. Compressed textures use less graphics memory and are faster to render.After compression, texture will be in <see cref="F:UnityEngine.TextureFormat.DXT1" /> format if the original texture had no alpha channel, and in <see cref="F:UnityEngine.TextureFormat.DXT5" /> format if it had alpha channel.Passing <c>true</c> for <c>highQuality</c> parameter will dither the source texture during compression, which helps to reduce compression artifacts but is slightly slower.If the graphics card does not support compression or the texture is already in compressed format, then Compress will do nothing.In the Editor scripts, you probably want to use <see cref="M:UnityEditor.EditorUtility.CompressTexture(UnityEngine.Texture2D,UnityEngine.TextureFormat,System.Int32)" />, which will compress using slower, but higher quality DXT compression. It can also compress into non-DXT compressed formats.You can also load already precompressed data into a texture using <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" /> function.See Also: <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEditor.EditorUtility.CompressTexture(UnityEngine.Texture2D,UnityEngine.TextureFormat,System.Int32)" />, <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.EncodeToJPG">
      <summary>
        <para>Encodes this texture into JPG format.</para>
        <para>The returned byte array is the JPG "file". You can write them to disk to get the JPG file, send them over the network, etc.This function works only on <c>ARGB32</c> and <c>RGB24</c> texture formats. The texture also has to have Is Readable flag set in the import settings.The encoded JPG data will have no alpha channel.See Also: <see cref="M:UnityEngine.Texture2D.EncodeToPNG" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.EncodeToJPG(System.Int32)">
      <summary>
        <para>Encodes this texture into JPG format.</para>
        <para>The returned byte array is the JPG "file". You can write them to disk to get the JPG file, send them over the network, etc.This function works only on <c>ARGB32</c> and <c>RGB24</c> texture formats. The texture also has to have Is Readable flag set in the import settings.The encoded JPG data will have no alpha channel.See Also: <see cref="M:UnityEngine.Texture2D.EncodeToPNG" />.</para>
      </summary>
      <param name="quality">JPG quality to encode with, 1..100 (default 75).</param>
    </member>
    <member name="M:UnityEngine.Texture2D.EncodeToPNG">
      <summary>
        <para>Encodes this texture into PNG format.</para>
        <para>The returned byte array is the PNG "file". You can write them to disk to get the PNG file, send them over the network, etc.This function works only on <c>ARGB32</c> and <c>RGB24</c> texture formats. The texture also has to have Is Readable flag set in the import settings.The encoded PNG data will contain alpha channel for <c>ARGB32</c> textures, and no alpha channel for <c>RGB24</c> textures. PNG data will not contain gamma correction or color profile information.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32,System.Boolean)" />
      <seealso cref="T:UnityEngine.WaitForEndOfFrame" />
      <seealso cref="M:UnityEngine.Texture2D.LoadImage(System.Byte[])" />
      <seealso cref="M:UnityEngine.Texture2D.EncodeToJPG" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel color at coordinates (x, y).</para>
        <para>If the pixel coordinates are out of bounds (larger than width/height or small than 0), they will be clamped or repeated based on the texture's wrap mode.Texture coordinates start at lower left corner.If you are reading a large block of pixels from the texture, it may be faster to use <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" /> or <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" /> which returns a whole block of pixel colors.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" />, <see cref="M:UnityEngine.Texture2D.GetPixelBilinear(System.Single,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixelBilinear(System.Single,System.Single)">
      <summary>
        <para>Returns filtered pixel color at normalized coordinates (u, v).</para>
        <para>Coordinates <c>u</c> and <c>v</c> go from 0.0 to 1.0, just like UV coordinates in meshes. If coordinates are out of bounds (larger than 1.0 or smaller than 0.0), they will be clamped or repeated based on the texture's wrap mode.Texture coordinates start at lower left corner. UV of (0,0) lands exactly on the bottom left texel; and UV of ((width-1)/width, (height-1)/height) lands exactly on the top right texel.Returned pixel color is bilinearly filtered.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.See Also: <see cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" />.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture.The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.Using <c>GetPixels</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels. For most textures, even faster is to use <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" /> which returns low precision color data without costly integer-to-float conversions.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture.The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.Using <c>GetPixels</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels. For most textures, even faster is to use <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" /> which returns low precision color data without costly integer-to-float conversions.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function is an extended version of <c>GetPixels</c> above; it does not return the whole mip level but only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The block must fit into the used mip level. The returned array is <c>blockWidth*blockHeight</c> size.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function is an extended version of <c>GetPixels</c> above; it does not return the whole mip level but only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The block must fit into the used mip level. The returned array is <c>blockWidth*blockHeight</c> size.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      <summary>
        <para>Get a block of pixel colors in Color32 format.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture.The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.Using <c>GetPixels32</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels32</c> can access individual mipmap levels.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels32">
      <summary>
        <para>Get a block of pixel colors in Color32 format.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture.The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail.Using <c>GetPixels32</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels32</c> can access individual mipmap levels.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount" />
    </member>
    <member name="M:UnityEngine.Texture2D.GetRawTextureData">
      <summary>
        <para>Get raw data from a texture.</para>
        <para>This function returns the raw texture data as a byte array, which you can then use with <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />. This allows you to serialize and load textures of any format (including compressed ones), and to load them back into a texture later.</para>
      </summary>
      <returns>Raw texture data as a byte array.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.LoadImage(System.Byte[])">
      <summary>
        <para>Loads PNG/JPG image byte array into a texture.</para>
        <para>This function replaces texture contents with new image data. After LoadImage, texture size and format might change. JPG files are loaded into <see cref="F:UnityEngine.TextureFormat.RGB24" /> format, PNG files are loaded into <see cref="F:UnityEngine.TextureFormat.ARGB32" /> format. If texture format before calling LoadImage is <see cref="F:UnityEngine.TextureFormat.DXT1" /> or <see cref="F:UnityEngine.TextureFormat.DXT5" />, then the loaded image will be DXT-compressed (into DXT1 for JPG images and DXT5 for PNG images). If the platform is not able to perform runtime compression then false will be returned.Texture will be uploaded to the GPU automatically; there's no need to call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />.</para>
      </summary>
      <param name="data">The byte array containing the image data to load.</param>
      <returns>Returns true if the data can be loaded, false otherwise.</returns>
      <seealso cref="M:UnityEngine.Texture2D.EncodeToPNG" />
      <seealso cref="M:UnityEngine.Texture2D.EncodeToJPG" />
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />
    </member>
    <member name="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      <summary>
        <para>Fills texture pixels with raw preformatted data.</para>
        <para>This function fills texture pixel memory with raw data. This is mostly useful for loading compressed texture format data into a texture.Passed data should be of required size to fill the whole texture according to its width, height, data <see cref="P:UnityEngine.Texture2D.format" /> and <see cref="P:UnityEngine.Texture2D.mipmapCount" />. Mipmaps are laid out in memory starting from largest, with smaller mip level data immediately following.For example, a 16x8 texture of <see cref="F:UnityEngine.TextureFormat.ARGB32" /> type with no mipmaps can be filled with a 512-byte array (16x8x4).Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> after setting image data to actually upload it to the GPU.See Also: <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.LoadImage(System.Byte[])" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />.</para>
      </summary>
      <param name="data">Byte array to initialize texture pixels with.</param>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing.The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit.The atlas will have <see cref="F:UnityEngine.TextureFormat.DXT1" /> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="F:UnityEngine.TextureFormat.DXT1" /> or <see cref="F:UnityEngine.TextureFormat.DXT5" /> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="F:UnityEngine.TextureFormat.ARGB32" /> uncompressed format.If none of the input textures have mipmaps then the atlas will also have no mipmaps.If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions.If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <param name="maximumAtlasSize">Maximum size of the resulting texture.</param>
      <param name="makeNoLongerReadable">Should the texture be marked as no longer readable?</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32,System.Int32)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing.The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit.The atlas will have <see cref="F:UnityEngine.TextureFormat.DXT1" /> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="F:UnityEngine.TextureFormat.DXT1" /> or <see cref="F:UnityEngine.TextureFormat.DXT5" /> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="F:UnityEngine.TextureFormat.ARGB32" /> uncompressed format.If none of the input textures have mipmaps then the atlas will also have no mipmaps.If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions.If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <param name="maximumAtlasSize">Maximum size of the resulting texture.</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing.The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit.The atlas will have <see cref="F:UnityEngine.TextureFormat.DXT1" /> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="F:UnityEngine.TextureFormat.DXT1" /> or <see cref="F:UnityEngine.TextureFormat.DXT5" /> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="F:UnityEngine.TextureFormat.ARGB32" /> uncompressed format.If none of the input textures have mipmaps then the atlas will also have no mipmaps.If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions.If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Read pixels from screen into the saved texture data.</para>
        <para>This will copy a rectangular pixel area from the currently active <see cref="T:UnityEngine.RenderTexture" /> or the view (specified by the <c>source</c> parameter) into the position defined by <c>destX</c> and <c>destY</c>. Both coordinates use pixel space - (0,0) is lower left.If <c>recalculateMipMaps</c> is set to true, the mip maps of the texture will also be updated. If <c>recalculateMipMaps</c> is set to false, you must call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to recalculate them.This function works on <c>ARGB32</c> and <c>RGB24</c> texture formats, when render target is of a similar format too (e.g. usual 32 or 16 bit render texture). Reading from a HDR render target (ARGBFloat or ARGBHalf render texture formats) into HDR texture formats (RGBAFloat or RGBAHalf) is supported too.The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <param name="source">Rectangular region of the view to read from. Pixels are read from current render target.</param>
      <param name="destX">Horizontal pixel position in the texture to place the pixels that are read.</param>
      <param name="destY">Vertical pixel position in the texture to place the pixels that are read.</param>
      <param name="recalculateMipMaps">Should the texture's mipmaps be recalculated after reading?</param>
      <seealso cref="M:UnityEngine.Texture2D.EncodeToPNG" />
    </member>
    <member name="M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32)">
      <summary>
        <para>Read pixels from screen into the saved texture data.</para>
        <para>This will copy a rectangular pixel area from the currently active <see cref="T:UnityEngine.RenderTexture" /> or the view (specified by the <c>source</c> parameter) into the position defined by <c>destX</c> and <c>destY</c>. Both coordinates use pixel space - (0,0) is lower left.If <c>recalculateMipMaps</c> is set to true, the mip maps of the texture will also be updated. If <c>recalculateMipMaps</c> is set to false, you must call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to recalculate them.This function works on <c>ARGB32</c> and <c>RGB24</c> texture formats, when render target is of a similar format too (e.g. usual 32 or 16 bit render texture). Reading from a HDR render target (ARGBFloat or ARGBHalf render texture formats) into HDR texture formats (RGBAFloat or RGBAHalf) is supported too.The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <param name="source">Rectangular region of the view to read from. Pixels are read from current render target.</param>
      <param name="destX">Horizontal pixel position in the texture to place the pixels that are read.</param>
      <param name="destY">Vertical pixel position in the texture to place the pixels that are read.</param>
      <seealso cref="M:UnityEngine.Texture2D.EncodeToPNG" />
    </member>
    <member name="M:UnityEngine.Texture2D.Resize(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean)">
      <summary>
        <para>Resizes the texture.</para>
        <para>Changes size of texture to <c>width</c> by <c>height</c>, format to <c>textureFormat</c> and optionally creates mip maps. After resizing, texture pixels will be undefined. This function is very similar to the texture constructor, except it works on existing texture object.Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Resize(System.Int32,System.Int32)">
      <summary>
        <para>Resizes the texture.</para>
        <para>Changes size of texture to <c>width</c> by <c>height</c>. After resizing, texture pixels will be undefined. This function is very similar to texture constructor, except it works on existing texture object.Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets pixel color at coordinates (x,y).</para>
        <para>Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card. Uploading is an expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.If you're constantly regenerating a texture at runtime, it may be faster to generate an array of pixel colors and set all of them at once with <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixel</c> is ignored. The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />
      <seealso cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)" />
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored. The texture also has to have Is Readable flag set in the import settings.Using <c>SetPixels</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" /> repeatedly, especially for large textures. In addition, <c>SetPixels</c> can access individual mipmap levels.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />, <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.This function works only on <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored. The texture also has to have Is Readable flag set in the import settings.Using <c>SetPixels</c> can be faster than calling <see cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)" /> repeatedly, especially for large textures. In addition, <c>SetPixels</c> can access individual mipmap levels.See Also: <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />, <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a Color32 array and changes the pixel colors of the whole mip level of the texture. Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.This function works only on <c>ARGB32</c> texture formats. For other formats <c>SetPixels32</c> is ignored. The texture also has to have Is Readable flag set in the import settings.Using <c>SetPixels32</c> is faster than calling <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />.See Also: <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />, <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a Color32 array and changes the pixel colors of the whole mip level of the texture. Call <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" /> to actually upload the changed pixels to the graphics card.The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.This function works only on <c>ARGB32</c> texture formats. For other formats <c>SetPixels32</c> is ignored. The texture also has to have Is Readable flag set in the import settings.Using <c>SetPixels32</c> is faster than calling <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />.See Also: <see cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)" />, <see cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])" />, <see cref="P:UnityEngine.Texture2D.mipmapCount" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels32</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels32</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.UpdateExternalTexture(System.IntPtr)">
      <summary>
        <para>Updates Unity texture to use different native texture object.</para>
        <para>This function is mostly useful for native code plugins that create platform specific texture objects outside of Unity, and need to use these textures in Unity scenes. For a texture created with <see cref="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)" />, this function switches to another underlying texture object if/when it changes.See Also: <see cref="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)" />.</para>
      </summary>
      <param name="nativeTex">Native 2D texture object.</param>
    </member>
    <member name="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)">
      <summary>
        <para>Creates Unity Texture out of externally created native texture object.</para>
        <para>This function is mostly useful for native code plugins that create platform specific texture objects outside of Unity, and need to use these textures in Unity scenes. It is also possible to create a texture in Unity and get a pointer to the underlying platform representation; see <see cref="M:UnityEngine.Texture.GetNativeTexturePtr" />.Parameters passed to CreateExternalTexture should match what the texture actually is; and the underlying texture should be 2D (Cubemaps or 3D textures will not work).Native texture object on Direct3D-like devices is a pointer to the base type, from which a texture can be created (IDirect3DBaseTexture9 on D3D9, ID3D11ShaderResourceView on D3D11). On OpenGL/OpenGL ES it is GLuint. On Metal it is id&lt;MTLTexture&gt;.See Also: <see cref="M:UnityEngine.Texture2D.UpdateExternalTexture(System.IntPtr)" />, <see cref="M:UnityEngine.Texture.GetNativeTexturePtr" />.</para>
      </summary>
      <param name="width">Width of texture in pixels.</param>
      <param name="height">Height of texture in pixels.</param>
      <param name="format">Format of underlying texture object.</param>
      <param name="mipmap">Does the texture have mipmaps?</param>
      <param name="linear">Is texture using linear color space?</param>
      <param name="nativeTex">Native 2D texture object.</param>
    </member>
    <member name="P:UnityEngine.Texture3D.depth">
      <summary>The depth of the texture (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Texture3D.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture3D.#ctor(System.Int32,System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean)">
      <summary>
        <para>Create a new empty 3D Texture.</para>
        <para>3D textures can be thought of as a box of pixels, with width, height and depth. Note that large textures can consume a lot of memory, for example a 1024x512x256 texture with <see cref="F:UnityEngine.TextureFormat.ARGB32" /> format and no mipmaps will consume 512MB of memory.See Also: <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> functions.</para>
      </summary>
      <param name="width">Width of texture in pixels.</param>
      <param name="height">Height of texture in pixels.</param>
      <param name="depth">Depth of texture in pixels.</param>
      <param name="format">Texture data format.</param>
      <param name="mipmap">Should the texture have mipmaps?</param>
    </member>
    <member name="M:UnityEngine.Texture3D.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.See Also: <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture3D.Apply">
      <summary>
        <para>Actually apply all previous <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" /> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />.This is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.See Also: <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" /> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      <summary>
        <para>Returns an array of pixel colors representing one mip level of the 3D texture.</para>
        <para>Note that using <see cref="T:UnityEngine.Color32" /> data and <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" /> can be faster and consume less memory.See Also: <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels">
      <summary>
        <para>Returns an array of pixel colors representing one mip level of the 3D texture.</para>
        <para>Note that using <see cref="T:UnityEngine.Color32" /> data and <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" /> can be faster and consume less memory.See Also: <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      <summary>Returns an array of pixel colors representing one mip level of the 3D texture.</summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels32">
      <summary>Returns an array of pixel colors representing one mip level of the 3D texture.</summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)" />
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a color array and changes the pixel colors of the 3D texture. Call <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> to actually upload the changed pixels to the GPU.Note that using <see cref="T:UnityEngine.Color32" /> data with ::SetPixels32 function can be faster and consume less memory.See Also: <see cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" />.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <param name="miplevel">The mipmap level to be affected by the new colors.</param>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[])">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a color array and changes the pixel colors of the 3D texture. Call <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> to actually upload the changed pixels to the GPU.Note that using <see cref="T:UnityEngine.Color32" /> data with ::SetPixels32 function can be faster and consume less memory.See Also: <see cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)" />, <see cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" />.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a <see cref="T:UnityEngine.Color32" /> array and changes the pixel colors of the 3D texture. Call <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> to actually upload the changed pixels to the GPU.See Also: <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" />, <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" />.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <param name="miplevel">The mipmap level to be affected by the new colors.</param>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[])">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a <see cref="T:UnityEngine.Color32" /> array and changes the pixel colors of the 3D texture. Call <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" /> to actually upload the changed pixels to the GPU.See Also: <see cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)" />, <see cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)" />, <see cref="M:UnityEngine.Texture3D.Apply(System.Boolean)" />.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
    </member>
    <member name="P:UnityEngine.Time.captureFramerate">
      <summary>
        <para>Slows game playback time to allow screenshots to be saved between frames.</para>
        <para>If this property has a non-zero value then frame update will occur at an interval of (1.0 / captureFramerate) regardless of real time and the time required to render a frame. This is useful if you want to capture a movie where you need a constant frame rate and leave enough time between frames to save screen images.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.deltaTime">
      <summary>
        <para>The time in seconds it took to complete the last frame (Read Only).</para>
        <para>Use this function to make your game frame rate independent.If you add or subtract to a value every frame chances are you should multiply with Time.deltaTime. When you multiply with Time.deltaTime you essentially express: I want to move this object 10 meters per second instead of 10 meters per frame.When called from inside MonoBehaviour's <see href="MonoBehaviour.FixedUpdate" cref="FixedUpdate" />, returns the fixed framerate delta time.Note that you should not rely on Time.deltaTime from inside <see href="MonoBehaviour.OnGUI" cref="OnGUI" /> since OnGUI can be called multiple times per frame and deltaTime would hold the same value each call, until next frame where it would be updated again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedDeltaTime">
      <summary>
        <para>The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's <c>FixedUpdate</c>) are performed.</para>
        <para>For reading the delta time it is recommended to use Time.deltaTime instead because it automatically returns the right delta time if you are inside a <c>FixedUpdate</c> function or <c>Update</c> function.Note that the <c>fixedDeltaTime</c> interval is with respect to the in-game time affected by <see cref="P:UnityEngine.Time.timeScale" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedTime">
      <summary>
        <para>The time the latest <c>FixedUpdate</c> has started (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Fixed time is updated in regular intervals (equal to <see cref="P:UnityEngine.Time.fixedDeltaTime" />) until <see cref="P:UnityEngine.Time.time" /> property is reached.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.frameCount">
      <summary>The total number of frames that have passed (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Time.maximumDeltaTime">
      <summary>
        <para>The maximum time a frame can take. Physics and other fixed frame rate updates (like MonoBehaviour's <see href="MonoBehaviour.FixedUpdate" cref="FixedUpdate" />).</para>
        <para>Will be performed only for this duration of time per frame.Use this function to avoid low frame rate spikes occurring due to combination of GarbageCollector and expensive physics or other fixed frame rate updates.If frame will take longer than specified value, then less physics and other fixed frame rate updates will be performed. That will temporarily slow down the gameplay, but will allow frame rate to catchup avoiding nasty stuttering.It is advisable to keep maximum time for frame between 1/10th and 1/3th of a second.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.realtimeSinceStartup">
      <summary>
        <para>The real time in seconds since the game started (Read Only).</para>
        <para>In almost all cases you can and should use Time.time instead.<c>realtimeSinceStartup</c> returns the time since startup, not affected by Time.timeScale. <c>realtimeSinceStartup</c> also keeps increasing while the player is paused (in the background). Using <c>realtimeSinceStartup</c> is useful when you want to pause the game by setting Time.timeScale to zero, but still want to be able to measure time somehow.Note that <c>realtimeSinceStartup</c> returns time as reported by system timer. Depending on the platform and the hardware, it may report the same time even in several consecutive frames. If you're dividing something by time difference, take this into account (time difference may become zero!).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.smoothDeltaTime">
      <summary>A smoothed out Time.deltaTime (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Time.time">
      <summary>
        <para>The time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Returns the same value if called multiple times in a single frame. When called from inside MonoBehaviour's <c>FixedUpdate</c>, returns <see cref="P:UnityEngine.Time.fixedTime" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.timeScale">
      <summary>
        <para>The scale at which the time is passing. This can be used for slow motion effects.</para>
        <para>When <c>timeScale</c> is 1.0 the time is passing as fast as realtime. When <c>timeScale</c> is 0.5 the time is passing 2x slower than realtime.When <c>timeScale</c> is set to zero the game is basically paused if all your functions are frame rate independent.Except for <see cref="P:UnityEngine.Time.realtimeSinceStartup" />, <c>timeScale</c> affects all the time and delta time measuring variables of the <see cref="T:UnityEngine.Time" /> class.If you lower <c>timeScale</c> it is recommended to also lower Time.fixedDeltaTime by the same amount.<c>FixedUpdate</c> functions will not be called when <c>timeScale</c> is set to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.timeSinceLevelLoad">
      <summary>The time this frame has started (Read Only). This is the time in seconds since the last level has been loaded.</summary>
    </member>
    <member name="P:UnityEngine.Time.unscaledDeltaTime">
      <summary>The timeScale-independent time in seconds it took to complete the last frame (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Time.unscaledTime">
      <summary>
        <para>The timeScale-independant time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Returns the same value if called multiple times in a single frame. Unlike <see cref="P:UnityEngine.Time.time" /> this value is not affected by <see cref="P:UnityEngine.Time.timeScale" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.deltaPosition">
      <summary>
        <para>The position delta since last change.</para>
        <para>The absolute position of the touch is recorded periodically and available in the <see cref="P:UnityEngine.Touch.position" /> property. The deltaPosition value is a Vector2 that represents the difference between the touch position recorded on the most recent update and that recorded on the previous update. The <see cref="P:UnityEngine.Touch.deltaTime" /> value gives the time that elapsed between the previous and current updates; you can calculate the touch's speed of motion by dividing deltaPosition.magnitude by deltaTime.See Also: deltaTime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.deltaTime">
      <summary>
        <para>Amount of time that has passed since the last recorded change in Touch values.</para>
        <para>Values for the various touch properties are updated periodically. The deltaTime value is simply the amount of time that elapsed between the previous update and the current one.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.fingerId">
      <summary>
        <para>The unique index for the touch.</para>
        <para>All current touches are reported in the <see cref="P:UnityEngine.Input.touches" /> array or by using the <see cref="M:UnityEngine.Input.GetTouch(System.Int32)" /> function with the equivalent array index. However, the array index is not guaranteed to be the same from one frame to the next. The <c>fingerId</c> value, however, consistently refers to the same touch across frames. This ID value is very useful when analysing gestures and is more reliable than identifying fingers by their proximity to previous position, etc.Touch.fingerId is not the same as "first" touch, "second" touch and so on. It is merely a unique id per gesture. You cannot make any assumptions about fingerId and the number of fingers actually on screen, since virtual touches will be introduced to handle the fact that the touch structure is constant for an entire frame (while in reality the number of touches obviously might not be true, e.g. if multiple tappings occur within a single frame).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.phase">
      <summary>
        <para>Describes the phase of the touch.</para>
        <para>The touch <c>phase</c> refers to the action the finger has taken on the most recent frame update. Since a touch is tracked over its "lifetime" by the device, the start and end of a touch and movements in between can be reported on the frames they occur. The <c>phase</c> property can be used as the basis of a "switch' statement or as part of a more sophisitcated state handling system.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.position">
      <summary>The position of the touch in pixel coordinates.</summary>
    </member>
    <member name="P:UnityEngine.Touch.tapCount">
      <summary>
        <para>Number of taps.</para>
        <para>This is intended as a way to detect "double-clicks", etc, from the finger in a particular position. In some circumstances, two fingers may be tapped alternately and this may incorrectly register as a single finger tapping and simultaneously moving.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.area">
      <summary>
        <para>Returns portion of the screen which is covered by the keyboard.</para>
        <para>Returns zero-Rect on Android.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.hideInput">
      <summary>
        <para>Will text input field above the keyboard be hidden when the keyboard is on screen?</para>
        <para>This property is applicable for single line text fields that have assigned keyboard with alphanumeric keys. When TouchScreenKeyboard.hideInputs is set to true, the only type of keyboard that can be opened is <see cref="F:UnityEngine.TouchScreenKeyboardType.Default" />. This type of keyboard will be opened even if other types are specified to be opened.Note: Android: only <see cref="P:UnityEngine.TouchScreenKeyboard.visible" /> input field is supported, hence this value is always false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.isSupported">
      <summary>
        <para>Is touch screen keyboard supported.</para>
        <para>Returns true if platform supports touch screen keyboard. On Windows Store Apps this value will be false on desktop and can change on tablet depending on whether touch cover keyboard is connected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.visible">
      <summary>Returns true whenever any keyboard is completely visible on the screen.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.active">
      <summary>
        <para>Is the keyboard visible or sliding into the position on the screen?</para>
        <para>Use this property to bring previously hidden keyboard back on the screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.done">
      <summary>
        <para>Specifies if input process was finished. (Read Only)</para>
        <para>Keyboard input process can be finished either by user tapping "Done" button or script setting <c>active</c> property to false. Note that keyboard might be temporarily inactive (either by sliding in/out due to orientation change or by appearance of another keyboard), however its input process might still be not finished and will be resumed automatically.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.targetDisplay">
      <summary>Specified on which display the software keyboard will appear.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.text">
      <summary>
        <para>Returns the text displayed by the input field of the keyboard.</para>
        <para>This value can be accessed at any moment, even if user has not yet finished input process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.wasCanceled">
      <summary>Specifies if input process was canceled. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
      <param name="alert">Is the keyboard opened in alert mode?</param>
      <param name="textPlaceholder">Text to be used if no other text is present.</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
      <param name="alert">Is the keyboard opened in alert mode?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
    </member>
    <member name="P:UnityEngine.TrailRenderer.autodestruct">
      <summary>
        <para>Does the <see cref="T:UnityEngine.GameObject" /> of this trail renderer auto destructs?</para>
        <para>When set to <c>true</c>, the <see cref="T:UnityEngine.GameObject" /> will be destroyed when it is not moving anymore.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.endWidth">
      <summary>The width of the trail at the end of the trail.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.startWidth">
      <summary>The width of the trail at the spawning point.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.time">
      <summary>How long does the trail take to fade out.</summary>
    </member>
    <member name="P:UnityEngine.Transform.childCount">
      <summary>The number of children the Transform has.</summary>
    </member>
    <member name="P:UnityEngine.Transform.eulerAngles">
      <summary>
        <para>The rotation as Euler angles in degrees.</para>
        <para>The x, y, and z angles represent a rotation z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).Only use this variable to read and set the angles to absolute values. Don't increment them, as it will fail when the angle exceeds 360 degrees. Use Transform.Rotate instead.</para>
        <para>Do not set one of the eulerAngles axis separately (eg. eulerAngles.x = 10; ) since this will lead to drift and undesired rotations. When setting them to a new value set them all at once as shown above. Unity will convert the angles to and from the rotation stored in Transform.rotation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.forward">
      <summary>The blue axis of the transform in world space.</summary>
    </member>
    <member name="P:UnityEngine.Transform.hasChanged">
      <summary>
        <para>Has the transform changed since the last time the flag was set to 'false'?</para>
        <para>A change to the transform can be anything that can cause its matrix to be recalculated: any adjustment to its position, rotation or scale. Note that operations which can change the transform will not actually check if the old and new value are different before setting this flag. So setting, for instance, transform.position will always set hasChanged on the transform, regardless of there being any actual change.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localEulerAngles">
      <summary>
        <para>The rotation as Euler angles in degrees relative to the parent transform's rotation.</para>
        <para>The x, y, and z angles represent a rotation z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).Only use this variable to read and set the angles to absolute values. Don't increment them, as it will fail when the angle exceeds 360 degrees. Use Transform.Rotate instead.</para>
        <para>Unity automatically converts the angles to and from the rotation stored in Transform.localRotation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localPosition">
      <summary>
        <para>Position of the transform relative to the parent transform.</para>
        <para>If the transform has no parent, it is the same as Transform.position.</para>
        <para>Note that the parent transform's world rotation and scale are applied to the local position when calculating the world position. This means that while 1 unit in Transform.position is always 1 unit, 1 unit in Transform.localPosition will get scaled by the scale of all ancestors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localRotation">
      <summary>
        <para>The rotation of the transform relative to the parent transform's rotation.</para>
        <para>Unity stores rotations as Quaternions internally. To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles for modifying the rotation as euler angles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localScale">
      <summary>The scale of the transform relative to the parent.</summary>
    </member>
    <member name="P:UnityEngine.Transform.localToWorldMatrix">
      <summary>
        <para>Matrix that transforms a point from local space into world space (Read Only).</para>
        <para>If you're not familiar with using matrices for coordinate transformations, use Transform.TransformPoint instead.IMPORTANT: If you're setting shader parameters you MUST use Renderer.localToWorldMatrix instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.lossyScale">
      <summary>
        <para>The global scale of the object (Read Only).</para>
        <para>Please note that if you have a parent transform with scale and a child that is arbitrarily rotated, the scale will be skewed. Thus scale can not be represented correctly in a 3 component vector but only a 3x3 matrix. Such a representation is quite inconvenient to work with however. lossyScale is a convenience property that attempts to match the actual world scale as much as it can. If your objects are not skewed the value will be completely correct and most likely the value will not be very different if it contains skew too.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.parent">
      <summary>
        <para>The parent of the transform.</para>
        <para>Changing the parent will modify the parent-relative position, scale and rotation but keep the world space position, rotation and scale the same.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.position">
      <summary>The position of the transform in world space.</summary>
    </member>
    <member name="P:UnityEngine.Transform.right">
      <summary>The red axis of the transform in world space.</summary>
    </member>
    <member name="P:UnityEngine.Transform.root">
      <summary>
        <para>Returns the topmost transform in the hierarchy.</para>
        <para>(This never returns null, if this Transform doesn't have a parent it returns itself.)</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.rotation">
      <summary>
        <para>The rotation of the transform in world space stored as a <see cref="T:UnityEngine.Quaternion" />.</para>
        <para>Unity stores rotations as Quaternions internally. To rotate an object, use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as euler angles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.up">
      <summary>The green axis of the transform in world space.</summary>
    </member>
    <member name="P:UnityEngine.Transform.worldToLocalMatrix">
      <summary>
        <para>Matrix that transforms a point from world space into local space (Read Only).</para>
        <para>If you're not familiar with using matrices for coordinate transformations, use Transform.InverseTransformPoint instead.IMPORTANT: If you're setting shader parameters you MUST use Renderer.worldToLocalMatrix instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.DetachChildren">
      <summary>
        <para>Unparents all children.</para>
        <para>Useful if you want to destroy the root of a hierarchy without destroying the children.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Find(System.String)">
      <summary>
        <para>Finds a child by <c>name</c> and returns it.</para>
        <para>If no child with <c>name</c> can be found, null is returned. If <c>name</c> contains a '/' character it will traverse the hierarchy like a path name.</para>
      </summary>
      <param name="name">Name of child to be found.</param>
    </member>
    <member name="M:UnityEngine.Transform.GetChild(System.Int32)">
      <summary>Returns a transform child by index.</summary>
      <param name="index">Index of the child transform to return. Must be smaller than Transform.childCount.</param>
      <returns>Transform child by index.</returns>
    </member>
    <member name="M:UnityEngine.Transform.GetSiblingIndex">
      <summary>Gets the sibling index.</summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformDirection(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a <c>direction</c> from world space to local space. The opposite of Transform.TransformDirection.</para>
        <para>This operation is unaffected by scale.You should use <see cref="M:UnityEngine.Transform.InverseTransformPoint(UnityEngine.Vector3)" /> if the vector represents a position in space rather than a direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformDirection(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the direction <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformDirection.</para>
        <para>This operation is unaffected by scale.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space to local space.</para>
        <para>This function is essentially the opposite of <see cref="M:UnityEngine.Transform.TransformPoint(UnityEngine.Vector3)" />, which is used to convert from local to world space. Note that the returned position is affected by scale. Use <see cref="M:UnityEngine.Transform.InverseTransformDirection(UnityEngine.Vector3)" /> if you are dealing with direction vectors rather than positions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformPoint(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the position <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformPoint.</para>
        <para>Note that the returned position is affected by scale. Use <see cref="M:UnityEngine.Transform.InverseTransformDirection(UnityEngine.Vector3)" /> if you are dealing with directions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a <c>vector</c> from world space to local space. The opposite of Transform.TransformVector.</para>
        <para>This operation is affected by scale.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformVector(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the vector <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformVector.</para>
        <para>This operation is affected by scale.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.IsChildOf(UnityEngine.Transform)">
      <summary>
        <para>Is this transform a child of <c>parent</c>?</para>
        <para>Returns a boolean value that indicates whether the transform is a child of a given transform. true if this transform is a child, deep child (child of a child) or identical to this transform, otherwise false.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Transform,UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>target</c>'s current position.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="target">Object to point towards.</param>
      <param name="worldUp">Vector specifying the upward direction.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Transform)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>target</c>'s current position.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="target">Object to point towards.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>worldPosition</c>.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="worldPosition">Point to look at.</param>
      <param name="worldUp">Vector specifying the upward direction.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>worldPosition</c>.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="worldPosition">Point to look at.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,UnityEngine.Space)">
      <summary>
        <para>Applies a rotation of <c>eulerAngles.z</c> degrees around the z axis, <c>eulerAngles.x</c> degrees around the x axis, and <c>eulerAngles.y</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the rotation is applied around the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the rotation is applied around the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3)">
      <summary>
        <para>Applies a rotation of <c>eulerAngles.z</c> degrees around the z axis, <c>eulerAngles.x</c> degrees around the x axis, and <c>eulerAngles.y</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the rotation is applied around the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the rotation is applied around the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(System.Single,System.Single,System.Single,UnityEngine.Space)">
      <summary>
        <para>Applies a rotation of <c>zAngle</c> degrees around the z axis, <c>xAngle</c> degrees around the x axis, and <c>yAngle</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is left out or sot to Space.Self the rotation is applied around the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the rotation is applied around the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(System.Single,System.Single,System.Single)">
      <summary>
        <para>Applies a rotation of <c>zAngle</c> degrees around the z axis, <c>xAngle</c> degrees around the x axis, and <c>yAngle</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is left out or sot to Space.Self the rotation is applied around the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the rotation is applied around the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,System.Single,UnityEngine.Space)">
      <summary>
        <para>Rotates the transform around <c>axis</c> by <c>angle</c> degrees.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the <c>axis</c> parameter is relative to the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the <c>axis</c> parameter is relative to the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Rotates the transform around <c>axis</c> by <c>angle</c> degrees.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the <c>axis</c> parameter is relative to the transform's local axes. (The x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the <c>axis</c> parameter is relative to the world x, y, z axes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.RotateAround(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Rotates the transform about <c>axis</c> passing through <c>point</c> in world coordinates by <c>angle</c> degrees.</para>
        <para>This modifies both the position and the rotation of the transform.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.SetAsFirstSibling">
      <summary>Move the transform to the start of the local transform list.</summary>
    </member>
    <member name="M:UnityEngine.Transform.SetAsLastSibling">
      <summary>Move the transform to the end of the local transform list.</summary>
    </member>
    <member name="M:UnityEngine.Transform.SetParent(UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Set the parent of the transform.</para>
        <para>This method is the same as the <see cref="P:UnityEngine.Transform.parent" /> property except that it's possible to make the Transform keep its local orientation rather than its global orientation by setting the worldPositionStays parameter to false.</para>
      </summary>
      <param name="parent">The parent Transform to use.</param>
      <param name="worldPositionStays">If true, the parent-relative position, scale and rotation is modified such that the object keeps the same world space position, rotation and scale as before.</param>
    </member>
    <member name="M:UnityEngine.Transform.SetSiblingIndex(System.Int32)">
      <summary>Sets the sibling index.</summary>
      <param name="index">Index to set.</param>
    </member>
    <member name="M:UnityEngine.Transform.TransformDirection(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>direction</c> from local space to world space.</para>
        <para>This operation is not affected by scale or position of the transform. The returned vector has the same length as <c>direction</c>.You should use <see cref="M:UnityEngine.Transform.TransformPoint(UnityEngine.Vector3)" /> for the conversion if the vector represents a position rather than a direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformDirection(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms direction <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>This operation is not affected by scale or position of the transform. The returned vector has the same length as <c>direction</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from local space to world space.</para>
        <para>Note that the returned position is affected by scale. Use <see cref="M:UnityEngine.Transform.TransformDirection(UnityEngine.Vector3)" /> if you are dealing with direction vectors. You can perform the opposite conversion, from world to local space using <see cref="M:UnityEngine.Transform.InverseTransformPoint(UnityEngine.Vector3)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformPoint(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the position <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>Note that the returned position is affected by scale. Use Transform.TransformDirection if you are dealing with directions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>vector</c> from local space to world space.</para>
        <para>This operation is not affected by position of the transform, but is is affected by scale. The returned vector may have a different length than <c>vector</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformVector(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms vector <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>This operation is not affected by position of the transform, but is is affected by scale. The returned vector may have a different length than <c>vector</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3,UnityEngine.Space)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single,UnityEngine.Space)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3,UnityEngine.Transform)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>The movement is applied relative to <c>relativeTo</c>'s local coordinate system. If <c>relativeTo</c> is null, the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single,UnityEngine.Transform)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>The movement is applied relative to <c>relativeTo</c>'s local coordinate system. If <c>relativeTo</c> is null, the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Tree.data">
      <summary>
        <para>Data asociated to the Tree.</para>
        <para>Check the tree creator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Tree.hasSpeedTreeWind">
      <summary>Tells if there is wind data exported from SpeedTree are saved on this component.</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.color">
      <summary>Color of this instance.</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.heightScale">
      <summary>Height scale of this instance (compared to the prototype's size).</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.lightmapColor">
      <summary>Lightmap color calculated for this instance.</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.position">
      <summary>Position of the tree.</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.prototypeIndex">
      <summary>Index of this instance in the TerrainData.treePrototypes array.</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.rotation">
      <summary>Rotation of the tree on X-Z plane (in radians).</summary>
    </member>
    <member name="F:UnityEngine.TreeInstance.widthScale">
      <summary>Width scale of this instance (compared to the prototype's size).</summary>
    </member>
    <member name="P:UnityEngine.TreePrototype.bendFactor">
      <summary>Bend factor of the tree prototype.</summary>
    </member>
    <member name="P:UnityEngine.TreePrototype.prefab">
      <summary>Retrieves the actual GameObect used by the tree.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.down">
      <summary>Shorthand for writing <c>Vector2(0, -1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.left">
      <summary>Shorthand for writing <c>Vector2(-1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.one">
      <summary>Shorthand for writing <c>Vector2(1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.right">
      <summary>Shorthand for writing <c>Vector2(1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.up">
      <summary>Shorthand for writing <c>Vector2(0, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.zero">
      <summary>Shorthand for writing <c>Vector2(0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y)</c>.If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="P:UnityEngine.Vector2.sqrMagnitude" /> (computing squared magnitudes is faster).See Also: <see cref="P:UnityEngine.Vector2.sqrMagnitude" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector2.normalized">
      <summary>
        <para>Returns this vector with a <see cref="P:UnityEngine.Vector2.magnitude" /> of 1 (Read Only).</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0.Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="M:UnityEngine.Vector2.Normalize" /> function.If the vector is too small to be normalized a zero vector will be returned.See Also: <see cref="M:UnityEngine.Vector2.Normalize" /> function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector2.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="P:UnityEngine.Vector2.magnitude" /> is much faster. Often if you are comparing magnitudes of two vectors you can just compare their squared magnitudes.See Also: <see cref="P:UnityEngine.Vector2.magnitude" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector2.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector2.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.#ctor(System.Single,System.Single)">
      <summary>Constructs a new vector with given x, y components.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Normalize">
      <summary>
        <para>Makes this vector have a <see cref="P:UnityEngine.Vector2.magnitude" /> of 1.</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0.Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="P:UnityEngine.Vector2.normalized" /> variable.If this vector is too small to be normalized it will be set to zero.See Also: <see cref="P:UnityEngine.Vector2.normalized" /> variable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Set(System.Single,System.Single)">
      <summary>Set x and y components of an existing Vector2.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Angle(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Returns the angle in degrees between <c>from</c> and <c>to</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.ClampMagnitude(UnityEngine.Vector2,System.Single)">
      <summary>Returns a copy of <c>vector</c> with its magnitude clamped to <c>maxLength</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Distance(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector2.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Dot(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>Returns <c>lhs</c><c>.</c><c>rhs</c>.For normalized vectors Dot returns 1 if they point in exactly the same direction; -1 if they point in completely opposite directions; and a number in between for other cases (e.g. Dot returns zero if vectors are perpendicular).For vectors of arbitrary length the Dot return values are similar: they get larger when the angle between vectors decreases.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Lerp(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Linearly interpolates between vectors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1].When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Vector2.LerpUnclamped(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.LerpUnclamped(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Linearly interpolates between vectors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Vector2.Lerp(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Max(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2.Min(UnityEngine.Vector2,UnityEngine.Vector2)" />
    </member>
    <member name="M:UnityEngine.Vector2.Min(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2.Max(UnityEngine.Vector2,UnityEngine.Vector2)" />
    </member>
    <member name="M:UnityEngine.Vector2.MoveTowards(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Vector2.Lerp but instead the function will ensure that the speed never exceeds <c>maxDistanceDelta</c>. Negative values of <c>maxDistanceDelta</c> pushes the vector away from <c>target</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Reflect(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Reflects a vector off the vector defined by a normal.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Scale(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Scale(UnityEngine.Vector2)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.SmoothDamp(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Vector2.SmoothDamp(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Vector2.SmoothDamp(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="M:UnityEngine.Vector2.(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Subtracts one vector from another.</para>
        <para>Subtracts each component of <c>b</c> from <c>a</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.(UnityEngine.Vector2)">
      <summary>
        <para>Negates a vector.</para>
        <para>Each component in the result is negated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator !=(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns true if vectors different.</para>
        <para>Very close vectors are treated as being equal.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator *(UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator *(System.Single,UnityEngine.Vector2)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator /(UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Divides a vector by a number.</para>
        <para>Divides each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator +(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Adds two vectors.</para>
        <para>Adds corresponding components together.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.operator ==(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns true if the vectors are equal.</para>
        <para>This will also return true for vectors that are really close to being equal.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3.back">
      <summary>Shorthand for writing <c>Vector3(0, 0, -1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.down">
      <summary>Shorthand for writing <c>Vector3(0, -1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.forward">
      <summary>Shorthand for writing <c>Vector3(0, 0, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.left">
      <summary>Shorthand for writing <c>Vector3(-1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.one">
      <summary>Shorthand for writing <c>Vector3(1, 1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.right">
      <summary>Shorthand for writing <c>Vector3(1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.up">
      <summary>Shorthand for writing <c>Vector3(0, 1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.zero">
      <summary>Shorthand for writing <c>Vector3(0, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y+z*z)</c>.If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="P:UnityEngine.Vector3.sqrMagnitude" /> (computing squared magnitudes is faster).See Also: <see cref="P:UnityEngine.Vector3.sqrMagnitude" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3.normalized">
      <summary>
        <para>Returns this vector with a <see cref="P:UnityEngine.Vector3.magnitude" /> of 1 (Read Only).</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0.Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="M:UnityEngine.Vector3.Normalize" /> function.If the vector is too small to be normalized a zero vector will be returned.See Also: <see cref="M:UnityEngine.Vector3.Normalize" /> function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>The magnitude of a vector <c>v</c> is calculated as Mathf.Sqrt(Vector3.Dot(v, v)). However, the Sqrt calculation is quite complicated and takes longer to execute than the normal arithmetic operations. Calculating the squared magnitude instead of using the <see cref="P:UnityEngine.Vector3.magnitude" /> property is much faster - the calculation is basically the same only without the slow Sqrt call. If you are using magnitudes simply to compare distances, then you can just as well compare squared magnitudes against the squares of distances since the comparison will give the same result.See Also: <see cref="P:UnityEngine.Vector3.magnitude" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector3.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector3.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector3.z">
      <summary>Z component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.#ctor(System.Single,System.Single,System.Single)">
      <summary>Creates a new vector with given x, y, z components.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.#ctor(System.Single,System.Single)">
      <summary>Creates a new vector with given x, y components and sets <c>z</c> to zero.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Set(System.Single,System.Single,System.Single)">
      <summary>Set x, y and z components of an existing Vector3.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Angle(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns the angle in degrees between <c>from</c> and <c>to</c>.</para>
        <para>The angle returned is always the <c>acute</c> angle between the two vector (ie, the smaller of the two possible angles between them and never greater than 180 degrees).</para>
      </summary>
      <param name="from">The angle extends round from this vector.</param>
      <param name="to">The angle extends round to this vector.</param>
    </member>
    <member name="M:UnityEngine.Vector3.ClampMagnitude(UnityEngine.Vector3,System.Single)">
      <summary>Returns a copy of <c>vector</c> with its magnitude clamped to <c>maxLength</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Cross(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Cross Product of two vectors.</para>
        <para>The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the "left hand rule".<c>The left hand rule applied to Cross(a, b).</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Distance(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector3.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Dot(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them.For <see cref="P:UnityEngine.Vector3.normalized" /> vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between the vectors <c>a</c> and <c>b</c> by the interpolant <c>t</c>. The parameter <c>t</c> is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points).When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the point midway between <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />
      <seealso cref="M:UnityEngine.Vector3.LerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />
    </member>
    <member name="M:UnityEngine.Vector3.LerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between the vectors <c>a</c> and <c>b</c> by the interpolant <c>t</c>. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points).When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the point midway between <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Max(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3.Min(UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Vector3.Min(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3.Max(UnityEngine.Vector3,UnityEngine.Vector3)" />
    </member>
    <member name="M:UnityEngine.Vector3.MoveTowards(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> in a straight line towards a <c>target</c> point.</para>
        <para>The value returned by this function is a point <c>maxDistanceDelta</c> units closer to a <c>target/</c> point along a line between <c>current</c> and <c>target</c>. If the target is closer than <c>maxDistanceDelta/</c> then the returned value will be equal to target (ie, the movement will not overshoot the target). Negative values of <c>maxDistanceDelta</c> can be used to push the point away from the target.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Normalize">
      <summary>
        <para>Makes this vector have a <see cref="P:UnityEngine.Vector3.magnitude" /> of 1.</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0.Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="P:UnityEngine.Vector3.normalized" /> variable.If this vector is too small to be normalized it will be set to zero.See Also: <see cref="P:UnityEngine.Vector3.normalized" /> variable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.OrthoNormalize(UnityEngine.Vector3@,UnityEngine.Vector3@)">
      <summary>
        <para>Makes vectors normalized and orthogonal to each other.</para>
        <para>Normalizes <c>normal</c>. Normalizes <c>tangent</c> and makes sure it is orthogonal to <c>normal</c> (that is, angle between them is 90 degrees).See Also: <see cref="M:UnityEngine.Vector3.Normalize" /> function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.OrthoNormalize(UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
      <summary>
        <para>Makes vectors normalized and orthogonal to each other.</para>
        <para>Normalizes <c>normal</c>. Normalizes <c>tangent</c> and makes sure it is orthogonal to <c>normal</c>. Normalizes <c>binormal</c> and makes sure it is orthogonal to both <c>normal</c> and <c>tangent</c>.Points in space are usually specified with coordinates in the standard XYZ axis system. However, you can interpret any three vectors as "axes" if they are normalized (ie, have a magnitude of 1) and are orthogonal (ie, perpendicular to each other).Creating your own coordinate axes is useful, say, if you want to scale a mesh in arbitrary directions rather than just along the XYZ axes - you can transform the vertices to your own coordinate system, scale them and then transform back. Often, a transformation like this will be carried out along only one axis while the other two are either left as they are or treated equally. For example, a stretching effect can be applied to a mesh by scaling up on one axis while scaling down proportionally on the other two. This means that once the first axis vector is specified, it doesn't greatly matter what the other two are as long as they are normalized and orthogonal. OrthoNormalize can be used to ensure the first vector is normal and then generate two normalized, orthogonal vectors for the other two axes.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Normalize" />
    </member>
    <member name="M:UnityEngine.Vector3.Project(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Projects a vector onto another vector.</para>
        <para>To understand vector projection, imagine that <c>onNormal</c> is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of <c>vector</c>. The projection is just <c>onNormal</c> rescaled so that it reaches that point on the line.The function will return a zero vector if <c>onNormal</c> is almost zero.An example of the usage of projection is a rail-mounted gun that should slide so that it gets as close as possible to a target object. The projection of the target heading along the direction of the rail can be used to move the gun by applying a force to a rigidbody, say.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.ProjectOnPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Projects a vector onto a plane defined by a normal orthogonal to the plane.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Reflect(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Reflects a vector off the plane defined by a normal.</para>
        <para>The <c>inNormal</c> vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). the <c>inDirection</c> vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to <c>inDirection</c> but with its direction reflected.<c>Reflection of a vector off a plane.</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.RotateTowards(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single)">
      <summary>
        <para>Rotates a vector <c>current</c> towards <c>target</c>.</para>
        <para>This function is similar to <see cref="M:UnityEngine.Vector3.MoveTowards(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" /> except that the vector is treated as a direction rather than a position. The <c>current</c> vector will be rotated round toward the <c>target</c> direction by an angle of <c>maxRadiansDelta</c>, although it will land exactly on the target rather than overshoot. If the magnitudes of <c>current</c> and <c>target</c> are different then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for <c>maxRadiansDelta</c>, the vector will rotate away from <c>target/</c> until it is pointing in exactly the opposite direction, then stop.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Scale(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Scale(UnityEngine.Vector3)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Spherically interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. The difference between this and linear interpolation (aka, "lerp") is that the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated by the angle and its <see cref="P:UnityEngine.Vector3.magnitude" /> is interpolated between the magnitudes of <c>from</c> and <c>to</c>.The parameter <c>t</c> is clamped to the range [0, 1].</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />
      <seealso cref="M:UnityEngine.Vector3.SlerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />
    </member>
    <member name="M:UnityEngine.Vector3.SlerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Spherically interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. The difference between this and linear interpolation (aka, "lerp") is that the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated by the angle and its <see cref="P:UnityEngine.Vector3.magnitude" /> is interpolated between the magnitudes of <c>from</c> and <c>to</c>.See Also: <see cref="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="M:UnityEngine.Vector3.(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Subtracts one vector from another.</para>
        <para>Subtracts each component of <c>b</c> from <c>a</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.(UnityEngine.Vector3)">
      <summary>
        <para>Negates a vector.</para>
        <para>Each component in the result is negated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator !=(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns true if vectors different.</para>
        <para>Very close vectors are treated as being equal.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator *(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator *(System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator /(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Divides a vector by a number.</para>
        <para>Divides each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator +(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Adds two vectors.</para>
        <para>Adds corresponding components together.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.operator ==(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns true if the vectors are equal.</para>
        <para>This will also return true for vectors that are really close to being equal.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.one">
      <summary>Shorthand for writing <c>Vector4(1,1,1,1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector4.zero">
      <summary>Shorthand for writing <c>Vector4(0,0,0,0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector4.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y+z*z+w*w)</c>.If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="P:UnityEngine.Vector4.sqrMagnitude" /> (computing squared magnitudes is faster).See Also: <see cref="P:UnityEngine.Vector4.sqrMagnitude" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.normalized">
      <summary>
        <para>Returns this vector with a <see cref="P:UnityEngine.Vector4.magnitude" /> of 1 (Read Only).</para>
        <para>Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="M:UnityEngine.Vector4.Normalize" /> function.If the vector is too small to be normalized a zero vector will be returned.See Also: <see cref="M:UnityEngine.Vector4.Normalize" /> function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="P:UnityEngine.Vector4.magnitude" /> is much faster.See Also: <see cref="P:UnityEngine.Vector4.magnitude" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector4.w">
      <summary>W component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.z">
      <summary>Z component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates a new vector with given x, y, z, w components.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.#ctor(System.Single,System.Single,System.Single)">
      <summary>Creates a new vector with given x, y, z components and sets <c>w</c> to zero.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.#ctor(System.Single,System.Single)">
      <summary>Creates a new vector with given x, y components and sets <c>z</c> and <c>w</c> to zero.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set x, y, z and w components of an existing Vector4.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.Distance(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector4.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Dot(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>Returns <c>lhs</c><c>.</c><c>rhs</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Lerp(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>.The parameter <c>t</c> is clamped between [0...1].When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Vector4.LerpUnclamped(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.LerpUnclamped(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>.When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.See Also: <see cref="M:UnityEngine.Vector4.Lerp(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Max(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector4.Min(UnityEngine.Vector4,UnityEngine.Vector4)" />
    </member>
    <member name="M:UnityEngine.Vector4.Min(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector4.Max(UnityEngine.Vector4,UnityEngine.Vector4)" />
    </member>
    <member name="M:UnityEngine.Vector4.MoveTowards(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Vector4.Lerp but instead the function will ensure that the speed never exceeds <c>maxDistanceDelta</c>. Negative values of <c>maxDistanceDelta</c> pushes the vector away from <c>target</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Normalize">
      <summary>
        <para>Makes this vector have a <see cref="P:UnityEngine.Vector4.magnitude" /> of 1.</para>
        <para>Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="P:UnityEngine.Vector4.normalized" /> variable.If this vector is too small to be normalized it will be set to zero.See Also: <see cref="P:UnityEngine.Vector4.normalized" /> variable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Project(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Projects a vector onto another vector.</para>
        <para>Returns <c>a</c> projected onto <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Scale(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Scale(UnityEngine.Vector4)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Subtracts one vector from another.</para>
        <para>Subtracts each component of <c>b</c> from <c>a</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.(UnityEngine.Vector4)">
      <summary>
        <para>Negates a vector.</para>
        <para>Each component in the result is negated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator !=(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Returns true if vectors different.</para>
        <para>Very close vectors are treated as being equal.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator *(UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator *(System.Single,UnityEngine.Vector4)">
      <summary>
        <para>Multiplies a vector by a number.</para>
        <para>Multiplies each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator /(UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Divides a vector by a number.</para>
        <para>Divides each component of <c>a</c> by a number <c>d</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator +(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Adds two vectors.</para>
        <para>Adds corresponding components together.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.operator ==(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Returns true if the vectors are equal.</para>
        <para>This will also return true for vectors that are really close to being equal.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WaitForSeconds.#ctor(System.Single)">
      <summary>Creates a yield instruction to wait for a given number of seconds.</summary>
    </member>
    <member name="P:UnityEngine.WebCamDevice.isFrontFacing">
      <summary>True if camera faces the same direction a screen does, false otherwise.</summary>
    </member>
    <member name="P:UnityEngine.WebCamDevice.name">
      <summary>A human-readable name of the device. Varies across different systems.</summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.devices">
      <summary>
        <para>Return a list of available devices.</para>
        <para>This queries the system for the list of devices connected and it can be slow. You should cache this value by keeping a copy of the result if you want to use it repeatedly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.deviceName">
      <summary>
        <para>Set this to specify the name of the device to use.</para>
        <para>This only has an effect when set while the camera is not running.Note: if you want to use WebCamTexture to get the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. It's not possible to change device using WebCamTexture.deviceName from regular devices to remote devices and vice versa.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.didUpdateThisFrame">
      <summary>
        <para>Did the video buffer update this frame?</para>
        <para>Use this to check if the video buffer has changed since the last frame. When setting a low frame rate, it is likely that the video updates slower then the game, so it does not make sense to do expensive video processing in each Update call, so check this value before doing any processing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.isPlaying">
      <summary>Returns if the camera is currently playing.</summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.requestedFPS">
      <summary>
        <para>Set the requested frame rate of the camera device (in frames per second).</para>
        <para>It will use a closest frame rate to the one requested which is supported by the camera. The requested values only have an effect when set while the camera is not running.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.requestedHeight">
      <summary>
        <para>Set the requested height of the camera device.</para>
        <para>It will use a closest resolution to the one requested which is supported by the camera. The requested values only have an effect when set while the camera is not running.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.requestedWidth">
      <summary>
        <para>Set the requested width of the camera device.</para>
        <para>It will use a closest resolution to the one requested which is supported by the camera. The requested values only have an effect when set while the camera is not running.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.videoRotationAngle">
      <summary>
        <para>Returns an clockwise angle (in degrees), which can be used to rotate a polygon so camera contents are shown in correct orientation.</para>
        <para>Note that if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WebCamTexture.videoVerticallyMirrored">
      <summary>
        <para>Returns if the texture image is vertically flipped.</para>
        <para>Please note, that this will query platform-specific part, which might be not ready before actual video feed started; so it is not enough to call it once after play.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
      <param name="requestedWidth">The requested width of the texture.</param>
      <param name="requestedHeight">The requested height of the texture.</param>
      <param name="requestedFPS">The requested frame rate of the texture.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor(System.Int32,System.Int32)">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
      <param name="requestedWidth">The requested width of the texture.</param>
      <param name="requestedHeight">The requested height of the texture.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor(System.String)">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
      <param name="deviceName">The name of the video input device to be used.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor(System.String,System.Int32,System.Int32)">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
      <param name="deviceName">The name of the video input device to be used.</param>
      <param name="requestedWidth">The requested width of the texture.</param>
      <param name="requestedHeight">The requested height of the texture.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Create a WebCamTexture.</para>
        <para>Use <see cref="P:UnityEngine.WebCamTexture.devices" /> to get a list of the names of available camera devices. If no device name is supplied to the constructor or is passed as a null string, the first device found will be used.The requested width, height and framerate specified by the parameters may not be supported by the chosen camera. In such cases, the closest available values will be used.Note: if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.Note: if you want to use WebCamTexture to play the camera stream from device connected through Unity Remote, then you must initalize it through the constructor. Later it's not possible to change device using <see cref="P:UnityEngine.WebCamTexture.deviceName" /> from regular devices to remote devices and vice versa.</para>
      </summary>
      <param name="deviceName">The name of the video input device to be used.</param>
      <param name="requestedWidth">The requested width of the texture.</param>
      <param name="requestedHeight">The requested height of the texture.</param>
      <param name="requestedFPS">The requested frame rate of the texture.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.GetPixel(System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel color at coordinates (x, y).</para>
        <para>If the pixel coordinates are out of bounds (larger than width/height or small than 0), they will be clamped or repeat based on the texture's wrap mode.If you are reading a large block of pixels from the texture, it may be faster to use <see cref="M:UnityEngine.WebCamTexture.GetPixels" /> which returns a whole block of pixel colors.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.GetPixels">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture.The returned array is a flattened 2D array, where pixels are laid out left to right, top to bottom (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height.Using <c>GetPixels</c> can be faster than calling <see cref="M:UnityEngine.WebCamTexture.GetPixel(System.Int32,System.Int32)" /> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function is an extended version of <c>GetPixels</c> above; it does not return the whole mip level but only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The block must fit into the used mip level. The returned array is <c>blockWidth*blockHeight</c> size.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.GetPixels32(UnityEngine.Color32[])">
      <summary>
        <para>Returns the pixels data in raw format.</para>
        <para>This can be faster then calling <c>GetPixels</c>, as pixel data does not have to be converted to color structs, so you may want to use it if you need to do continuous processing on the video feed. You can optionally pass in an array of Color32s to use in <c>colors</c> to avoid allocating new memory each frame, which is faster when you are continuously reading data from the camera. The array needs to be initialized to a length matching width * height of the texture. If you don't pass an array, GetPixels32 will allocate one for you and return it.</para>
      </summary>
      <param name="colors">Optional array to receive pixel data.</param>
    </member>
    <member name="M:UnityEngine.WebCamTexture.GetPixels32">
      <summary>
        <para>Returns the pixels data in raw format.</para>
        <para>This can be faster then calling <c>GetPixels</c>, as pixel data does not have to be converted to color structs, so you may want to use it if you need to do continuous processing on the video feed. You can optionally pass in an array of Color32s to use in <c>colors</c> to avoid allocating new memory each frame, which is faster when you are continuously reading data from the camera. The array needs to be initialized to a length matching width * height of the texture. If you don't pass an array, GetPixels32 will allocate one for you and return it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.Pause">
      <summary>
        <para>Pauses the camera.</para>
        <para>Note that if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.Play">
      <summary>
        <para>Starts the camera.</para>
        <para>Note that if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WebCamTexture.Stop">
      <summary>
        <para>Stops the camera.</para>
        <para>Note that if you want to use WebCamTextures in the web player, you need to get the user's permission to do so. Call <see cref="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)" /> before creating a WebCamTexture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.brakeTorque">
      <summary>
        <para>Brake torque expressed in Newton metres.</para>
        <para>Must be positive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.center">
      <summary>
        <para>The center of the wheel, measured in the object's local space.</para>
        <para>The center of the wheel describes the coordinate that the wheel would achieve if the car was suspended in mid-air. This is equivalent to the coordinate of the wheel center when the spring is at maximum elongation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.forceAppPointDistance">
      <summary>
        <para>Application point of the suspension and tire forces measured from the base of the resting wheel.</para>
        <para>This is specified as a distance along the local up vector of the vehicle's rigid body from the base of the wheel at its rest coordinate (the rest coordinate of the wheel is determined by the value WheelCollider.spring.targetPosition). This parameter simulates the effective roll center of the suspension geometry. For a standard family car the value of forceAppPointDistance should be tuned to place the application point approximately 0.3m below the rigid body center of mass. Moving the application point downwards introduces more roll when cornering, while moving it upwards results in less roll when cornering. The force application point is typically below the rigid body center of mass.Please note that having this parameter equal to zero could be undesirable as it contributes to simulation instability in certain configurations. Once you observe your vehicle failing to go asleep resting on flat surface, exhibiting jittering behavior or drifting along the surface when no user input is applied, check the forceAppPointDistance values. In the editor, when a WheelCollider game object is selected, there is a green spherical gizmo displayed to show where the force application point is at the moment. Try increasing forceAppPointDistance value gradually, until you're satisfied with the result.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.forwardFriction">
      <summary>Properties of tire friction in the direction the wheel is pointing in.</summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.isGrounded">
      <summary>Indicates whether the wheel currently collides with something (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.mass">
      <summary>The mass of the wheel, expressed in kilograms. Must be larger than zero. Typical values would be in range (20,80).</summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.motorTorque">
      <summary>
        <para>Motor torque on the wheel axle expressed in Newton metres. Positive or negative depending on direction.</para>
        <para>To simulate brakes, do not use negative motor torque - use <see cref="P:UnityEngine.WheelCollider.brakeTorque" /> instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.radius">
      <summary>
        <para>The radius of the wheel, measured in local space.</para>
        <para>The radius will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.rpm">
      <summary>Current wheel axle rotation speed, in rotations per minute (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.sidewaysFriction">
      <summary>Properties of tire friction in the sideways direction.</summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.sprungMass">
      <summary>
        <para>The mass supported by this WheelCollider.</para>
        <para>Vehicle simulation uses the sprung mass model where it would decompose the full mass of the car supported by all wheels at once into a set of sprung masses supported by each individual wheel. Then it would work out all the suspension and tire forces for each wheel-mass pair and, as the last step, it would integrate all forces applied to the vehicle's body. In the simplest case of a perfectly symmetric car with four wheels, all sprung masses would be equal to a quarter of the car's mass. This property is automatically computed based on the car's configuration.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.steerAngle">
      <summary>
        <para>Steering angle in degrees, always around the local y-axis.</para>
        <para>At high velocities use only small steer angles; a few degrees should suffice.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.suspensionDistance">
      <summary>
        <para>Maximum extension distance of wheel suspension, measured in local space.</para>
        <para>Suspension always extends downwards the local y-axis. Suspension travel will be scaled by the transform's scale. The value <c>suspensionDistance</c> is the distance that the wheel travels as it moves along the local up vector of the rigid body from the coordinate of the wheel center at maximum spring elongation to the coordinateof the wheel center at maximum spring compression. It is expressed in metres. The range of suspension travel will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.suspensionSpring">
      <summary>
        <para>The parameters of wheel's suspension. The suspension attempts to reach a target position by applying a linear force and a damping force.</para>
        <para>The value <see cref="F:UnityEngine.JointSpring.spring" /> describes the stiffness of the spring. It is expressed in Newtons per metre. The spring strength has a profound influence on handling by modulating the time it takes for the vehicle to respond to bumps in the road and on the amount of load experienced by the tire. Larger values make the suspension reach the target position faster but at the cost of increased load and handling variability. Smaller values provide a smoother but less responsive ride.The value <see cref="F:UnityEngine.JointSpring.spring" /> describes the rate at which the spring dissipates the energy stored in the spring. It is expressed in Newtons seconds per metre (equivalent to Newtons per unit speed). Larger values make the suspension reach the target position slower, while lower values make the car appear more bouncy. Vehicle suspensions typically have a response close to critical damping.The rest coordinate of the wheel is specified by <see cref="F:UnityEngine.JointSpring.targetPosition" />. This value describes the rest coordinate of the wheel as a fraction in range (0, 1) along the <c>suspensionDistance</c>. Zero value maps to full extension along the suspension travel, while a value of one maps to fully compressed suspension. Default value is 0.5, which sets the rest coordinate of the wheel to the mid-point between the suspension at maximum elongation and maximum compression. Typical values would be in range (0.3, 0.7).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelCollider.wheelDampingRate">
      <summary>The damping rate of the wheel. Must be larger than zero.</summary>
    </member>
    <member name="M:UnityEngine.WheelCollider.ConfigureVehicleSubsteps(System.Single,System.Int32,System.Int32)">
      <summary>
        <para>Configure vehicle sub-stepping parameters.</para>
        <para>Every time a fixed update happens, the vehicle simulation splits this fixed delta time into smaller sub-steps and calculates suspension and tire forces per each smaller delta. Then, it would sum up all resulting forces and torques, integrate them, and apply to the vehicle's body.Using this function you can customize how many sub-steps will be performed by the simulation above and below the speed threshold.It's enough to call this function only once per each vehicle, as it actually sets parameters to the vehicle but not to a wheel.</para>
      </summary>
      <param name="speedThreshold">The speed threshold of the sub-stepping algorithm.</param>
      <param name="stepsBelowThreshold">Amount of simulation sub-steps when vehicle's speed is below speedThreshold.</param>
      <param name="stepsAboveThreshold">Amount of simulation sub-steps when vehicle's speed is above speedThreshold.</param>
    </member>
    <member name="M:UnityEngine.WheelCollider.GetGroundHit(UnityEngine.WheelHit@)">
      <summary>
        <para>Gets ground collision data for the wheel.</para>
        <para>If the wheel collides with something, returns <c>true</c> and fills the <c>hit</c> structure. If the wheel is not colliding, returns <c>false</c> and leaves <c>hit</c> structure unchanged.The reported hit is always the closest one. Because the tire friction model does not automatically respond to other <see cref="T:UnityEngine.PhysicMaterial" />s, any simulation of different ground materials must be done manually by adjusting <see cref="P:UnityEngine.WheelCollider.forwardFriction" /> and <see cref="P:UnityEngine.WheelCollider.sidewaysFriction" /> based on collider's material returned here.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WheelCollider.GetWorldPose(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
      <summary>Gets the world space pose of the wheel accounting for ground contact, suspension limits, steer angle, and rotation angle (angles in degrees).</summary>
      <param name="pos">Position of the wheel in world space.</param>
      <param name="quat">Rotation of the wheel in world space.</param>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.asymptoteSlip">
      <summary>Asymptote point slip (default 2).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.asymptoteValue">
      <summary>Force at the asymptote slip (default 10000).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.extremumSlip">
      <summary>Extremum point slip (default 1).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.extremumValue">
      <summary>Force at the extremum slip (default 20000).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.stiffness">
      <summary>
        <para>Multiplier for the <see cref="P:UnityEngine.WheelFrictionCurve.extremumValue" /> and <see cref="P:UnityEngine.WheelFrictionCurve.asymptoteValue" /> values (default 1).</para>
        <para>Changes the stiffness of the friction. Setting this to zero will completely disable all friction from the wheel.Usually you modify <c>stiffness</c> to simulate various ground materials (e.g. lower the stiffness when driving on grass).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelHit.collider">
      <summary>The other <see cref="T:UnityEngine.Collider" /> the wheel is hitting.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.force">
      <summary>The magnitude of the force being applied for the contact.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.forwardDir">
      <summary>The direction the wheel is pointing in.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.forwardSlip">
      <summary>Tire slip in the rolling direction. Acceleration slip is negative, braking slip is positive.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.normal">
      <summary>The normal at the point of contact.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.point">
      <summary>The point of contact between the wheel and the ground.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.sidewaysDir">
      <summary>The sideways direction of the wheel.</summary>
    </member>
    <member name="P:UnityEngine.WheelHit.sidewaysSlip">
      <summary>Tire slip in the sideways direction.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointSpeed">
      <summary>The current joint speed.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointTranslation">
      <summary>The current joint translation.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.motor">
      <summary>Parameters for a motor force that is applied automatically to the Rigibody2D along the line.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.suspension">
      <summary>Set the joint suspension configuration.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.useMotor">
      <summary>Should a motor force be applied automatically to the Rigidbody2D?</summary>
    </member>
    <member name="M:UnityEngine.WheelJoint2D.GetMotorTorque(System.Single)">
      <summary>Gets the motor torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor torque for.</param>
    </member>
    <member name="P:UnityEngine.WindZone.mode">
      <summary>Defines the type of wind zone to be used (Spherical or Directional).</summary>
    </member>
    <member name="P:UnityEngine.WindZone.radius">
      <summary>Radius of the Spherical Wind Zone (only active if the WindZoneMode is set to Spherical).</summary>
    </member>
    <member name="P:UnityEngine.WindZone.windMain">
      <summary>
        <para>The primary wind force.</para>
        <para>It produces a softly changing wind Pressure.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WindZone.windPulseFrequency">
      <summary>Defines the frequency of the wind changes.</summary>
    </member>
    <member name="P:UnityEngine.WindZone.windPulseMagnitude">
      <summary>Defines ow much the wind changes over time.</summary>
    </member>
    <member name="P:UnityEngine.WindZone.windTurbulence">
      <summary>
        <para>The turbulence wind force.</para>
        <para>Produces a rapidly changing wind pressure.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WindZone.#ctor">
      <summary>The constructor.</summary>
    </member>
    <member name="P:UnityEngine.WWW.assetBundle">
      <summary>Streams an AssetBundle that can contain any kind of asset from the project folder.</summary>
    </member>
    <member name="P:UnityEngine.WWW.audioClip">
      <summary>
        <para>Returns a <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be an audio clip in Ogg(Web/Standalones), MP3(phones), WAV, XM, IT, MOD or S3M format. The clip will be downloaded completely before it's ready to play. Use the overloaded <see cref="M:UnityEngine.WWW.GetAudioClip(System.Boolean)" /> (bool threeD, bool stream) to stream the audio, instead of downloading the entire clip.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.bytes">
      <summary>
        <para>Returns the contents of the fetched web page as a byte array (Read Only).</para>
        <para>If the object has not finished downloading the data, it will return an empty byte array. Use <see cref="P:UnityEngine.WWW.isDone" /> or <c>yield</c> to see if the data is available.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.bytesDownloaded">
      <summary>
        <para>The number of bytes downloaded by this WWW query (read only).</para>
        <para>Returns the number of bytes downloaded when fetching content from a WWW source.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.error">
      <summary>
        <para>Returns an error message if there was an error during the download (Read Only).</para>
        <para>If there was no error, <c>error</c> will return <c>null</c> or an empty string (this is because some platforms don't allow nulls for string values). We recommend that you use String.IsNullOrEmpty to check for the presence of an error so that both cases are covered.If the object has not finished downloading the data, it will block until the download has finished. Use <see cref="P:UnityEngine.WWW.isDone" /> or <c>yield</c> to see if the data is available.</para>
        <para>In the example the URL is not valid so the error message will be "Couldn't resolve host".</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.isDone">
      <summary>
        <para>Is the download already finished? (Read Only)</para>
        <para>You should not write loops that spin until download is done; use coroutines instead. An empty loop that waits for <c>isDone</c> will block in the web player.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.movie">
      <summary>
        <para>Returns a <see cref="T:UnityEngine.MovieTexture" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be a movie in Ogg Theora format.Even if the movie is not yet completely downloaded, this returns immediately, allowing you to start playing the partial movie as it downloads.See Also: <see cref="P:UnityEngine.MovieTexture.audioClip" />.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.progress">
      <summary>
        <para>How far has the download progressed (Read Only).</para>
        <para>This is a value between zero and one; 0 means nothing is downloaded, 1 means download complete.<c>progress</c> will remain at 0.0 while sending the request to the server. For monitoring progress when uploading files to a web server, see WWW.uploadProgress.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.responseHeaders">
      <summary>
        <para>Dictionary of headers returned by the request.</para>
        <para>Note when using these code examples you will want to set the WWW Security Emulation Host URL to "http://unity3d.com" in Editor Settings. Failure to do this may give you security exceptions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.text">
      <summary>
        <para>Returns the contents of the fetched web page as a string (Read Only).</para>
        <para>If the object has not finished downloading the data, it will return an empty string. Use <see cref="P:UnityEngine.WWW.isDone" /> or <c>yield</c> to see if the data is available.This function expects the web page contents in UTF-8 or ASCII character set. The returned string might be not correct for other characters or binary data. Use <see cref="P:UnityEngine.WWW.bytes" /> property to get raw byte array in these cases.See Also: <see cref="P:UnityEngine.WWW.bytes" /> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.texture">
      <summary>
        <para>Returns a <see cref="T:UnityEngine.Texture2D" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be an image in JPG or PNG format. If the data is not a valid image, the generated texture will be a small image of a question mark. It is recommended to use power-of-two size for each dimension of the image; arbitrary sizes will also work but can load slightly slower and take up a bit more memory. Each invocation of texture property allocates a new <see cref="T:UnityEngine.Texture2D" />. If you continously download textures you must use <see cref="M:UnityEngine.WWW.LoadImageIntoTexture(UnityEngine.Texture2D)" /> or <see cref="M:UnityEngine.Object.Destroy(UnityEngine.Object,System.Single)" /> the previously created texture.For PNG files, gamma correction is applied to the texture if PNG file contains gamma information. Display gamma for correction is assumed to be 2.0. If file does not contain gamma information, no color correction will be performed.JPG files are loaded into <see cref="F:UnityEngine.TextureFormat.RGB24" /> format, PNG files are loaded into <see cref="F:UnityEngine.TextureFormat.ARGB32" /> format. If you want to DXT-compress the downloaded image, use <see cref="M:UnityEngine.WWW.LoadImageIntoTexture(UnityEngine.Texture2D)" /> instead.If the object has not finished downloading the data a dummy image will be returned. Use <see cref="P:UnityEngine.WWW.isDone" /> or <c>yield</c> to see if the data is available.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.textureNonReadable">
      <summary>
        <para>Returns a non-readable <see cref="T:UnityEngine.Texture2D" /> generated from the downloaded data (Read Only).</para>
        <para>Same as <see cref="P:UnityEngine.WWW.texture" />, but marks texture as non-readable, effectively freeing system memory.SA TextureImporter.isReadable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.threadPriority">
      <summary>
        <para>Priority of <see cref="T:UnityEngine.AssetBundle" /> decompression thread.</para>
        <para>You can control decompression speed vs. impact on frame rate tradeoff when downloading Asset Bundles in the background. When using lower priority, decompression will take longer, but will not have such a big impact on frame rates. Default value is ThreadPriority.Normal.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.uploadProgress">
      <summary>
        <para>How far has the upload progressed (Read Only).</para>
        <para>This is a value between zero and one; 0 means nothing is sent yet, 1 means upload complete.<c>uploadProgress</c> is currently not fully implemented in the Web Player. If used in a Web Player it will report 0.5 during the upload and 1.0 when the upload is complete.Since all sending of data to the server is done before receiving data, <c>uploadProgress</c> will always be 1.0 when <c>progress</c> is larger than 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWW.url">
      <summary>The URL of this WWW request (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.WWW.#ctor(System.String)">
      <summary>
        <para>Creates a WWW request with the given URL.</para>
        <para>This function creates and sends a GET request. The stream will automatically start downloading the response.After the stream is created you have to wait for it to complete, then you can access the downloaded data. As a convenience the stream can be yielded, so you can very easily tell Unity to wait for the download to complete.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The url to download. Must be '%' escaped.</param>
      <returns>A new WWW object. When it has been downloaded, the results can be fetched from the returned object.</returns>
    </member>
    <member name="M:UnityEngine.WWW.#ctor(System.String,UnityEngine.WWWForm)">
      <summary>
        <para>Creates a WWW request with the given URL.</para>
        <para>This function creates and sends a POST request with form data contained in a <see cref="T:UnityEngine.WWWForm" /> parameter. This is the same as calling <c>new WWW(url,form.data, form.headers)</c>. The stream will automatically start downloading the response.After the stream is created you have to wait for it to complete, then you can access the downloaded data. As a convenience the stream can be yielded, so you can very easily tell Unity to wait for the download to complete.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The url to download. Must be '%' escaped.</param>
      <param name="form">A <see cref="T:UnityEngine.WWWForm" /> instance containing the form data to post.</param>
      <returns>A new WWW object. When it has been downloaded, the results can be fetched from the returned object.</returns>
    </member>
    <member name="M:UnityEngine.WWW.#ctor(System.String,System.Byte[])">
      <summary>
        <para>Creates a WWW request with the given URL.</para>
        <para>This function creates and sends a POST request with raw post data contained in postData. The stream will automatically start downloading the response. Use this version if you need to post raw post data in a custom format to the server.After the stream is created you have to wait for it to complete, then you can access the downloaded data. As a convenience the stream can be yielded, so you can very easily tell Unity to wait for the download to complete.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The url to download. Must be '%' escaped.</param>
      <param name="postData">A byte array of data to be posted to the url.</param>
      <returns>A new WWW object. When it has been downloaded, the results can be fetched from the returned object.</returns>
    </member>
    <member name="M:UnityEngine.WWW.#ctor(System.String,System.Byte[],System.Collections.Hashtable)">
      <summary>
        <para>Creates a WWW request with the given URL.</para>
        <para>This function creates and sends a POST request with raw post data contained in postData and custom request headers supplied in the <c>headers</c> hashtable. The stream will automatically start downloading the response. Use this version if you need to post raw post data in a custom format to the server or if you need to supply custom request headers.After the stream is created you have to wait for it to complete, then you can access the downloaded data. As a convenience the stream can be yielded, so you can very easily tell Unity to wait for the download to complete.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The url to download. Must be '%' escaped.</param>
      <param name="postData">A byte array of data to be posted to the url.</param>
      <param name="headers">A hash table of custom headers to send with the request.</param>
      <returns>A new WWW object. When it has been downloaded, the results can be fetched from the returned object.</returns>
    </member>
    <member name="M:UnityEngine.WWW.#ctor(System.String,System.Byte[])">
      <summary>
        <para>Creates a WWW request with the given URL.</para>
        <para>This function creates and sends a POST request with raw post data contained in postData and custom request headers supplied in the <c>headers</c> Dictionary. The stream will automatically start downloading the response. Use this version if you need to post raw post data in a custom format to the server or if you need to supply custom request headers.After the stream is created you have to wait for it to complete, then you can access the downloaded data. As a convenience the stream can be yielded, so you can very easily tell Unity to wait for the download to complete.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The url to download. Must be '%' escaped.</param>
      <param name="postData">A byte array of data to be posted to the url.</param>
      <returns>A new WWW object. When it has been downloaded, the results can be fetched from the returned object.</returns>
    </member>
    <member name="M:UnityEngine.WWW.Dispose">
      <summary>
        <para>Disposes of an existing WWW object.</para>
        <para>This function can be used to abort a download in progress. This can be useful, say, if you want to give the user an option to cancel the remote loading of a level in the game.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClip(System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV. Note that the XM, IT, MOD or S3M format can also be streamed in, but realtime playback of these is not supported, because all the data must be present before playback can begin, so for these tracker formats AudioClip.isReadyToPlay must switch to true before the clip may be assigned to and AudioSource and played back.Note: In Unity 5.x the <c>threeD</c> argument is ignored. The <see cref="T:UnityEngine.AudioSource" /> component controls whether the sound is 3D or 2D.</para>
      </summary>
      <param name="threeD">Use this to specify whether the clip should be a 2D or 3D clip the .audioClip property defaults to 3D.</param>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClip(System.Boolean,System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV. Note that the XM, IT, MOD or S3M format can also be streamed in, but realtime playback of these is not supported, because all the data must be present before playback can begin, so for these tracker formats AudioClip.isReadyToPlay must switch to true before the clip may be assigned to and AudioSource and played back.Note: In Unity 5.x the <c>threeD</c> argument is ignored. The <see cref="T:UnityEngine.AudioSource" /> component controls whether the sound is 3D or 2D.</para>
      </summary>
      <param name="threeD">Use this to specify whether the clip should be a 2D or 3D clip the .audioClip property defaults to 3D.</param>
      <param name="stream">Sets whether the clip should be completely downloaded before it's ready to play (false) or the stream can be played even if only part of the clip is downloaded (true). The latter will disable seeking on the clip (with .time and/or .timeSamples).</param>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClip(System.Boolean,System.Boolean,UnityEngine.AudioType)">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data (Read Only).</para>
        <para>The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV. Note that the XM, IT, MOD or S3M format can also be streamed in, but realtime playback of these is not supported, because all the data must be present before playback can begin, so for these tracker formats AudioClip.isReadyToPlay must switch to true before the clip may be assigned to and AudioSource and played back.Note: In Unity 5.x the <c>threeD</c> argument is ignored. The <see cref="T:UnityEngine.AudioSource" /> component controls whether the sound is 3D or 2D.</para>
      </summary>
      <param name="threeD">Use this to specify whether the clip should be a 2D or 3D clip the .audioClip property defaults to 3D.</param>
      <param name="stream">Sets whether the clip should be completely downloaded before it's ready to play (false) or the stream can be played even if only part of the clip is downloaded (true). The latter will disable seeking on the clip (with .time and/or .timeSamples).</param>
      <param name="audioType">The AudioType of the content your downloading. If this is not set Unity will try to determine the type from URL.</param>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClipCompressed">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data that is compressed in memory (Read Only).</para>
        <para>By default GetAudioClip will load the file into memory decompressed. This version will load the data compressed and decompress it as it plays. The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV.</para>
      </summary>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClipCompressed(System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data that is compressed in memory (Read Only).</para>
        <para>By default GetAudioClip will load the file into memory decompressed. This version will load the data compressed and decompress it as it plays. The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV.</para>
      </summary>
      <param name="threeD">Use this to specify whether the clip should be a 2D or 3D clip.</param>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.GetAudioClipCompressed(System.Boolean,UnityEngine.AudioType)">
      <summary>
        <para>Returns an <see cref="T:UnityEngine.AudioClip" /> generated from the downloaded data that is compressed in memory (Read Only).</para>
        <para>By default GetAudioClip will load the file into memory decompressed. This version will load the data compressed and decompress it as it plays. The data must be an audio clip in Ogg(Web/Standalones), MP3(phones) or WAV.</para>
      </summary>
      <param name="threeD">Use this to specify whether the clip should be a 2D or 3D clip.</param>
      <param name="audioType">The AudioType of the content your downloading. If this is not set Unity will try to determine the type from URL.</param>
      <returns>The returned <see cref="T:UnityEngine.AudioClip" />.</returns>
    </member>
    <member name="M:UnityEngine.WWW.LoadImageIntoTexture(UnityEngine.Texture2D)">
      <summary>
        <para>Replaces the contents of an existing <see cref="T:UnityEngine.Texture2D" /> with an image from the downloaded data.</para>
        <para>The data must be an image in JPG or PNG format. If the data is not a valid image, the generated texture will be a small image of a question mark. It is recommended to use power-of-two size for each dimension of the image; arbitrary sizes will also work but can load slightly slower and take up a bit more memory.For PNG files, gamma correction is applied to the texture if PNG file contains gamma information. Display gamma for correction is assumed to be 2.0. If file does not contain gamma information, no color correction will be performed.This function replaces texture contents with downloaded image data, so texture size and format might change. JPG files are loaded into <see cref="F:UnityEngine.TextureFormat.RGB24" /> format, PNG files are loaded into <see cref="F:UnityEngine.TextureFormat.ARGB32" /> format. If texture format before calling LoadImage is <see cref="F:UnityEngine.TextureFormat.DXT1" /> or <see cref="F:UnityEngine.TextureFormat.DXT5" />, then the loaded image will be DXT-compressed (into DXT1 for JPG images and DXT5 for PNG images).If the data has not finished downloading the texture will be left untouched. Use <see cref="P:UnityEngine.WWW.isDone" /> or <c>yield</c> to see if the data is available.</para>
      </summary>
      <param name="tex">An existing texture object to be overwritten with the image data.</param>
    </member>
    <member name="M:UnityEngine.WWW.EscapeURL(System.String,System.Text.Encoding)">
      <summary>
        <para>Escapes characters in a string to ensure they are URL-friendly.</para>
        <para>Certain text characters have special meanings when present in URLs. If you need to include those characters in URL parameters then you must represent them with escape sequences. It is recommended that you use this function on any text supplied by a user before passing the text as a URL parameter. This will ensure that a malicious user can't manipulate the contents of the URL to attack the webserver.</para>
      </summary>
      <param name="s">A string with characters to be escaped.</param>
      <param name="e">The text encoding to use.</param>
    </member>
    <member name="M:UnityEngine.WWW.EscapeURL(System.String)">
      <summary>
        <para>Escapes characters in a string to ensure they are URL-friendly.</para>
        <para>Certain text characters have special meanings when present in URLs. If you need to include those characters in URL parameters then you must represent them with escape sequences. It is recommended that you use this function on any text supplied by a user before passing the text as a URL parameter. This will ensure that a malicious user can't manipulate the contents of the URL to attack the webserver.</para>
      </summary>
      <param name="s">A string with characters to be escaped.</param>
    </member>
    <member name="M:UnityEngine.WWW.LoadFromCacheOrDownload(System.String,System.Int32,System.UInt32)">
      <summary>
        <para>Loads an AssetBundle with the specified version number from the cache. If the AssetBundle is not currently cached, it will automatically be downloaded and stored in the cache for future retrieval from local storage.</para>
        <para>LoadFromCacheOrDownload() must be used in place of "new WWW (url)" in order to utilize caching functionality.Cached AssetBundles are uniquely identified solely by the filename and version number; all domain and path information in <c>url</c> is ignored by Caching. Since cached AssetBundles are identified by filename instead of the full URL, you can change the directory from where the asset bundle is downloaded at any time. This is useful for pushing out new versions of the game and ensuring that files are not cached incorrectly by the browser or by a CDN. For WebPlayer applications that use the shared cache, Caching adds unique identifying information to identically-named AssetBundles in order to prevent name collisions between applications.If the cache folder does not have any space for caching additional files, LoadFromCacheOrDownload will iteratively delete the least-recently-used AssetBundles from the Cache until sufficient space is available to store the new AssetBundle. If making space is not possible (because the hard disk is full, or all files in the cache are currently in use), LoadFromCacheOrDownload() will bypass Caching and stream the file into memory like a normal "new WWW()" call.This function can only be used to access AssetBundles. No other types or content are cacheable.The CRC passed into this function is computed during Asset Bundle build time, see BuildPipeline.BuildAssetBundle.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The URL to download the AssetBundle from, if it is not present in the cache. Must be '%' escaped.</param>
      <param name="version">Version of the AssetBundle. The file will only be loaded from the disk cache if it has previously been downloaded with the same <c>version</c> parameter. By incrementing the version number requested by your application, you can force Caching to download a new copy of the AssetBundle from <c>url</c>.</param>
      <param name="crc">An optional CRC-32 Checksum of the uncompressed contents. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match. You can use this to avoid data corruption from bad downloads or users tampering with the cached files on disk. If the CRC does not match, Unity will try to redownload the data, and if the CRC on the server does not match it will fail with an error. Look at the error string returned to see the correct CRC value to use for an AssetBundle.</param>
      <returns>A WWW instance, which can be used to access the data once the load/download operation is completed.</returns>
    </member>
    <member name="M:UnityEngine.WWW.LoadFromCacheOrDownload(System.String,System.Int32)">
      <summary>
        <para>Loads an AssetBundle with the specified version number from the cache. If the AssetBundle is not currently cached, it will automatically be downloaded and stored in the cache for future retrieval from local storage.</para>
        <para>LoadFromCacheOrDownload() must be used in place of "new WWW (url)" in order to utilize caching functionality.Cached AssetBundles are uniquely identified solely by the filename and version number; all domain and path information in <c>url</c> is ignored by Caching. Since cached AssetBundles are identified by filename instead of the full URL, you can change the directory from where the asset bundle is downloaded at any time. This is useful for pushing out new versions of the game and ensuring that files are not cached incorrectly by the browser or by a CDN. For WebPlayer applications that use the shared cache, Caching adds unique identifying information to identically-named AssetBundles in order to prevent name collisions between applications.If the cache folder does not have any space for caching additional files, LoadFromCacheOrDownload will iteratively delete the least-recently-used AssetBundles from the Cache until sufficient space is available to store the new AssetBundle. If making space is not possible (because the hard disk is full, or all files in the cache are currently in use), LoadFromCacheOrDownload() will bypass Caching and stream the file into memory like a normal "new WWW()" call.This function can only be used to access AssetBundles. No other types or content are cacheable.The CRC passed into this function is computed during Asset Bundle build time, see BuildPipeline.BuildAssetBundle.Note: URL must be '%' escaped.</para>
      </summary>
      <param name="url">The URL to download the AssetBundle from, if it is not present in the cache. Must be '%' escaped.</param>
      <param name="version">Version of the AssetBundle. The file will only be loaded from the disk cache if it has previously been downloaded with the same <c>version</c> parameter. By incrementing the version number requested by your application, you can force Caching to download a new copy of the AssetBundle from <c>url</c>.</param>
      <returns>A WWW instance, which can be used to access the data once the load/download operation is completed.</returns>
    </member>
    <member name="M:UnityEngine.WWW.UnEscapeURL(System.String,System.Text.Encoding)">
      <summary>
        <para>Converts URL-friendly escape sequences back to normal text.</para>
        <para>Certain text characters have special meanings when present in URLs. If you need to include those characters in URL parameters then you must represent them with escape sequences. This function takes a string containing these escape sequences and converts them back to normal text.</para>
      </summary>
      <param name="s">A string containing escaped characters.</param>
      <param name="e">The text encoding to use.</param>
    </member>
    <member name="M:UnityEngine.WWW.UnEscapeURL(System.String)">
      <summary>
        <para>Converts URL-friendly escape sequences back to normal text.</para>
        <para>Certain text characters have special meanings when present in URLs. If you need to include those characters in URL parameters then you must represent them with escape sequences. This function takes a string containing these escape sequences and converts them back to normal text.</para>
      </summary>
      <param name="s">A string containing escaped characters.</param>
    </member>
    <member name="P:UnityEngine.WWWForm.data">
      <summary>
        <para>(Read Only) The raw data to pass as the POST request body when sending the form.</para>
        <para>Usually, you just pass the WWWForm object directly to the <see cref="T:UnityEngine.WWW" /> constructor, but you will need this variable if you want to change the request headers sent to the web server.See Also: <see cref="P:UnityEngine.WWWForm.headers" /> variable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WWWForm.headers">
      <summary>
        <para>(Read Only) Returns the correct request headers for posting the form using the <see cref="T:UnityEngine.WWW" /> class.</para>
        <para>This field only contains one header, /"Content-Type"/, which is set to the correct mime type for the form: "<c>application/x-www-form-urlencoded</c>" for normal forms and "<c>multipart/form-data</c>" for forms containing data added using <see cref="M:UnityEngine.WWWForm.AddBinaryData(System.String,System.Byte[],System.String,System.String)" />.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.#ctor">
      <summary>
        <para>Creates an empty WWWForm object.</para>
        <para>Use the <see cref="M:UnityEngine.WWWForm.AddField(System.String,System.String,System.Text.Encoding)" /> and <see cref="M:UnityEngine.WWWForm.AddBinaryData(System.String,System.Byte[],System.String,System.String)" /> methods to insert data into the form.See Also: <see cref="T:UnityEngine.WWW" /> class.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddBinaryData(System.String,System.Byte[],System.String,System.String)">
      <summary>
        <para>Add binary data to the form.</para>
        <para>Use this function to upload files and images to a web server application. Note that the data is read from the contents of byte array and not from a file. The fileName parameter is for telling the server what filename to use when saving the uploaded file.If <c>mimeType</c> is not given and first 8 bytes of the data match PNG format header, then the data is sent with "<c>image/png</c>" mimetype. Otherwise it is sent with "<c>application/octet-stream</c>" mimetype.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddBinaryData(System.String,System.Byte[],System.String)">
      <summary>
        <para>Add binary data to the form.</para>
        <para>Use this function to upload files and images to a web server application. Note that the data is read from the contents of byte array and not from a file. The fileName parameter is for telling the server what filename to use when saving the uploaded file.If <c>mimeType</c> is not given and first 8 bytes of the data match PNG format header, then the data is sent with "<c>image/png</c>" mimetype. Otherwise it is sent with "<c>application/octet-stream</c>" mimetype.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddBinaryData(System.String,System.Byte[])">
      <summary>
        <para>Add binary data to the form.</para>
        <para>Use this function to upload files and images to a web server application. Note that the data is read from the contents of byte array and not from a file. The fileName parameter is for telling the server what filename to use when saving the uploaded file.If <c>mimeType</c> is not given and first 8 bytes of the data match PNG format header, then the data is sent with "<c>image/png</c>" mimetype. Otherwise it is sent with "<c>application/octet-stream</c>" mimetype.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddField(System.String,System.String,System.Text.Encoding)">
      <summary>
        <para>Add a simple field to the form.</para>
        <para>Adds field <c>fieldName</c> with a given string value.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddField(System.String,System.String)">
      <summary>
        <para>Add a simple field to the form.</para>
        <para>Adds field <c>fieldName</c> with a given string value.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WWWForm.AddField(System.String,System.Int32)">
      <summary>
        <para>Adds a simple field to the form.</para>
        <para>Adds field <c>fieldName</c> with a given integer value. A conveinience for calling AddField(fieldName, i.ToString).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.DontShow">
      <summary>Do not show ActivityIndicator.</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.Large">
      <summary>Large (android.R.attr.progressBarStyleLarge).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.InversedLarge">
      <summary>Large Inversed (android.R.attr.progressBarStyleLargeInverse).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.Small">
      <summary>Small (android.R.attr.progressBarStyleSmall).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.InversedSmall">
      <summary>Small Inversed (android.R.attr.progressBarStyleSmallInverse).</summary>
    </member>
    <member name="F:UnityEngine.AnimationBlendMode.Blend">
      <summary>Animations will be blended.</summary>
    </member>
    <member name="F:UnityEngine.AnimationBlendMode.Additive">
      <summary>Animations will be added.</summary>
    </member>
    <member name="F:UnityEngine.AnimationCullingType.AlwaysAnimate">
      <summary>Animation culling is disabled - object is animated even when offscreen.</summary>
    </member>
    <member name="F:UnityEngine.AnimationCullingType.BasedOnRenderers">
      <summary>
        <para>Animation is disabled when renderers are not visible.</para>
        <para>This culling method is more suitable when you have renderers attached after import - it will take renderers (like mesh renderers, particle renderers and so on) attached to this gameObject or children of this game object.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Float">
      <summary>Float type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Int">
      <summary>Int type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Bool">
      <summary>Boolean type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Trigger">
      <summary>
        <para>Trigger type parameter.</para>
        <para>Trigger work mostly like bool parameter, but their values are reset to false when used in a Transition.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.AlwaysAnimate">
      <summary>Always animate the entire character. Object is animated even when offscreen.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.CullUpdateTransforms">
      <summary>
        <para>Retarget, IK and write of Transforms are disabled when renderers are not visible.</para>
        <para>The statemachine and root motion will always be evaluated. Thus you will always receive the OnAnimatorMove callbacks. All other animation will be skipped if the character is not visible. Specifically evaluation of bone animation, IK, OnAnimatorIK will be skipped.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.CullCompletely">
      <summary>Animation is completely disabled when renderers are not visible.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Offline">
      <summary>The Animator recorder is offline.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Playback">
      <summary>The Animator recorder is in Playback.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Record">
      <summary>The Animator recorder is in Record.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.Normal">
      <summary>Normal update of the animator.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics">
      <summary>Updates the animator during the physic loop in order to have the animation system synchronized with the physics engine.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.UnscaledTime">
      <summary>
        <para>Animator updates independently of Time.timeScale.</para>
        <para>This is typically used when animating the UI while the game is paused.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.Disable">
      <summary>Disable anisotropic filtering for all textures.</summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.Enable">
      <summary>Enable anisotropic filtering, as set for each texture.</summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.ForceEnable">
      <summary>Enable anisotropic filtering for all textures.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Unknown">
      <summary>Application install mode unknown.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Store">
      <summary>Application installed via online store.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.DeveloperBuild">
      <summary>Application installed via developer build.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Adhoc">
      <summary>Application installed via ad hoc distribution.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Enterprise">
      <summary>Application installed via enterprise distribution.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Editor">
      <summary>Application running in editor.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.Unknown">
      <summary>Application sandbox type is unknown.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.NotSandboxed">
      <summary>Application not running in a sandbox.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.Sandboxed">
      <summary>Application is running in a sandbox.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.SandboxBroken">
      <summary>Application is running in broken sandbox.</summary>
    </member>
    <member name="F:UnityEngine.AudioClipLoadType.DecompressOnLoad">
      <summary>
        <para>The audio data is decompressed when the audio clip is loaded.</para>
        <para>The audio clip will load the data and make sure it's kept in memory in decompressed form, allowing scripts to modify the audio data.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioClipLoadType.CompressedInMemory">
      <summary>
        <para>The audio data of the clip will be kept in memory in compressed form.</para>
        <para>The data is fully loaded into memory, but in compressed form, and therefore takes up the least amount of space.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioClipLoadType.Streaming">
      <summary>
        <para>Streams audio data from disk.</para>
        <para>This generally results in the lowest memory-usage and offloads decoding to a dedicated streaming thread, therefore reducing CPU usage on the mixer thread.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.PCM">
      <summary>
        <para>Uncompressed pulse-code modulation.</para>
        <para>PCM is uncompressed raw audio data.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.Vorbis">
      <summary>
        <para>Vorbis compression format.</para>
        <para>Raw vorbis format, without Ogg headers. This format is an optimised version of Ogg Vorbis that is more performant.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.ADPCM">
      <summary>
        <para>Adaptive differential pulse-code modulation.</para>
        <para>This compression format is cheap to decode but contains additional noise artifacts over other compression types.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.MP3">
      <summary>
        <para>MPEG Audio Layer III.</para>
        <para>This codec has poor looping characteristics.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.VAG">
      <summary>Sony proprietary hardware format.</summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.HEVAG">
      <summary>Sony proprietory hardware codec.</summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.XMA">
      <summary>Xbox One proprietary hardware format.</summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.AAC">
      <summary>AAC Audio Compression.</summary>
    </member>
    <member name="F:UnityEngine.AudioCompressionFormat.GCADPCM">
      <summary>Nintendo ADPCM audio compression format.</summary>
    </member>
    <member name="F:UnityEngine.AudioDataLoadState.Unloaded">
      <summary>
        <para>Value returned by AudioClip.loadState for an AudioClip that has no audio data loaded and where loading has not been initiated yet.</para>
        <para>This is the initial value of AudioClip.loadState that has the option "Preload audio data" unchecked.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioDataLoadState.Loading">
      <summary>Value returned by AudioClip.loadState for an AudioClip that is currently loading audio data.</summary>
    </member>
    <member name="F:UnityEngine.AudioDataLoadState.Loaded">
      <summary>Value returned by AudioClip.loadState for an AudioClip that has succeeded loading its audio data.</summary>
    </member>
    <member name="F:UnityEngine.AudioDataLoadState.Failed">
      <summary>Value returned by AudioClip.loadState for an AudioClip that has failed loading its audio data.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Off">
      <summary>
        <para>No reverb preset selected.</para>
        <para>All the values are disabled and the sound is the default without any modifications.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Generic">
      <summary>Generic preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.PaddedCell">
      <summary>Padded cell preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Room">
      <summary>Room preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Bathroom">
      <summary>Bathroom preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Livingroom">
      <summary>Livingroom preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Stoneroom">
      <summary>Stoneroom preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Auditorium">
      <summary>Auditorium preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Concerthall">
      <summary>Concert hall preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Cave">
      <summary>Cave preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Arena">
      <summary>Arena preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Hangar">
      <summary>Hangar preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.CarpetedHallway">
      <summary>Carpeted hallway preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Hallway">
      <summary>Hallway preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.StoneCorridor">
      <summary>Stone corridor preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Alley">
      <summary>Alley preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Forest">
      <summary>Forest preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.City">
      <summary>City preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Mountains">
      <summary>Mountains preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Quarry">
      <summary>Quarry preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Plain">
      <summary>Plain preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.ParkingLot">
      <summary>Parking Lot preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.SewerPipe">
      <summary>Sewer pipe preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Underwater">
      <summary>Underwater presset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Drugged">
      <summary>Drugged preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Dizzy">
      <summary>Dizzy preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.Psychotic">
      <summary>Psychotic preset.</summary>
    </member>
    <member name="F:UnityEngine.AudioReverbPreset.User">
      <summary>
        <para>User defined preset.</para>
        <para>Select this preset if you want to change manually the values of your preset.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioRolloffMode.Logarithmic">
      <summary>Use this mode when you want a real-world rolloff.</summary>
    </member>
    <member name="F:UnityEngine.AudioRolloffMode.Linear">
      <summary>Use this mode when you want to lower the volume of your sound over the distance.</summary>
    </member>
    <member name="F:UnityEngine.AudioRolloffMode.Custom">
      <summary>
        <para>Use this when you want to use a custom rolloff.</para>
        <para>Note: Currently is not possible to modify the volume curve via scripting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioSourceCurveType.CustomRolloff">
      <summary>
        <para>Custom Volume Rolloff.</para>
        <para>This defines how the AudioSource volume is attenuated with distance from the AudioListener.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioSourceCurveType.SpatialBlend">
      <summary>
        <para>The Spatial Blend.</para>
        <para>This defines how 2D or 3D an AudioSource is. 0 means the AudioSource is fully 2D 1 corresponds to the AudioSource being fully 3D.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioSourceCurveType.ReverbZoneMix">
      <summary>
        <para>Reverb Zone Mix.</para>
        <para>This defines how much of the signal is given to the current Reverb Zone.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioSourceCurveType.Spread">
      <summary>
        <para>The 3D Spread.</para>
        <para>This defines the current 3D spread of the playing AudioSource.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Raw">
      <summary>Channel count is unaffected.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Mono">
      <summary>Channel count is set to 1. The speakers are monaural.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Stereo">
      <summary>Channel count is set to 2. The speakers are stereo. This is the editor default.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Quad">
      <summary>Channel count is set to 4. 4 speaker setup. This includes front left, front right, rear left, rear right.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Surround">
      <summary>Channel count is set to 5. 5 speaker setup. This includes front left, front right, center, rear left, rear right.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Mode5point1">
      <summary>Channel count is set to 6. 5.1 speaker setup. This includes front left, front right, center, rear left, rear right and a subwoofer.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Mode7point1">
      <summary>Channel count is set to 8. 7.1 speaker setup. This includes front left, front right, center, rear left, rear right, side left, side right and a subwoofer.</summary>
    </member>
    <member name="F:UnityEngine.AudioSpeakerMode.Prologic">
      <summary>Channel count is set to 2. Stereo output, but data is encoded in a way that is picked up by a Prologic/Prologic2 decoder and split into a 5.1 speaker setup.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.UNKNOWN">
      <summary>3rd party / unknown plugin format.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.ACC">
      <summary>Acc - not supported.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.AIFF">
      <summary>Aiff.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.IT">
      <summary>Impulse tracker.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.MOD">
      <summary>Protracker / Fasttracker MOD.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.MPEG">
      <summary>MP2/MP3 MPEG.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.OGGVORBIS">
      <summary>Ogg vorbis.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.S3M">
      <summary>ScreamTracker 3.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.WAV">
      <summary>Microsoft WAV.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.XM">
      <summary>FastTracker 2 XM.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.XMA">
      <summary>Xbox360 XMA.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.VAG">
      <summary>VAG.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.AUDIOQUEUE">
      <summary>iPhone hardware decoder, supports AAC, ALAC and MP3. Extracodecdata is a pointer to an FMOD_AUDIOQUEUE_EXTRACODECDATA structure.</summary>
    </member>
    <member name="F:UnityEngine.AudioVelocityUpdateMode.Auto">
      <summary>Updates the source or listener in the fixed update loop if it is attached to a <see cref="T:UnityEngine.Rigidbody" />, dynamic otherwise.</summary>
    </member>
    <member name="F:UnityEngine.AudioVelocityUpdateMode.Fixed">
      <summary>Updates the source or listener in the fixed update loop.</summary>
    </member>
    <member name="F:UnityEngine.AudioVelocityUpdateMode.Dynamic">
      <summary>Updates the source or listener in the dynamic update loop.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.LeftFoot">
      <summary>The left foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.RightFoot">
      <summary>The right foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.LeftHand">
      <summary>The left hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.RightHand">
      <summary>The right hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.LeftKnee">
      <summary>The left knee IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.RightKnee">
      <summary>The right knee IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.LeftElbow">
      <summary>The left elbow IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.RightElbow">
      <summary>The right elbow IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.Root">
      <summary>The root, the position of the game object.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.Body">
      <summary>The body, center of mass.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.LeftFoot">
      <summary>The left foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.RightFoot">
      <summary>The right foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.LeftHand">
      <summary>The left hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.RightHand">
      <summary>The right hand.</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.OneBone">
      <summary>One bone affects each vertex.</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.TwoBones">
      <summary>Two bones affect each vertex.</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.FourBones">
      <summary>Four bones affect each vertex.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Skybox">
      <summary>
        <para>Clear with the skybox.</para>
        <para>If a skybox is not set up, the Camera will clear with a <see cref="P:UnityEngine.Camera.backgroundColor" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.SolidColor">
      <summary>Clear with a background color.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Depth">
      <summary>
        <para>Clear only the depth buffer.</para>
        <para>This will leave colors from the previous frame or whatever was displayed before.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Nothing">
      <summary>
        <para>Don't clear anything.</para>
        <para>This will leave colors and depth buffer from the previous frame or whatever was displayed before.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CameraType.Game">
      <summary>Used to indicate a regular in-game camera.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.SceneView">
      <summary>Used to indicate that a camera is used for rendering the Scene View in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.Preview">
      <summary>Used to indicate a camera that is used for rendering previews in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.Discrete">
      <summary>
        <para>Continuous collision detection is off for this Rigidbody.</para>
        <para>This is the default collision detection mode, and it is the fastest mode. Collisions for this collider will only be checked at the content's <see cref="P:UnityEngine.Time.fixedDeltaTime" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.Continuous">
      <summary>
        <para>Continuous collision detection is on for colliding with static mesh geometry.</para>
        <para>Collisions will be detected for any static mesh geometry in the path of this Rigidbody, even if the collision occurs between two FixedUpdate steps. Static mesh geometry is any MeshCollider which does not have a Rigidbody attached. This also prevent Rigidbodies set to ContinuousDynamic mode from passing through this Rigidbody.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.ContinuousDynamic">
      <summary>
        <para>Continuous collision detection is on for colliding with static and dynamic geometry.</para>
        <para>Prevent this Rigidbody from passing through static mesh geometry, and through other Rigidbodies which have continuous collision detection enabled, when it is moving fast. This is the slowest collision detection mode, and should only be used for selected fast moving objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode2D.Discrete">
      <summary>
        <para>When a <see cref="T:UnityEngine.Rigidbody2D" /> moves, only collisions at the new position are detected.</para>
        <para>When using this mode, <see cref="T:UnityEngine.Rigidbody2D" /> that are moving fast can overlap or even pass through other colliders. This mode however is much faster to calculate and should only be used when objects are moving at relatively slow or moderate speeds and you are not encountering objects overlapping or passing through each other.See Also: <see cref="P:UnityEngine.Rigidbody2D.collisionDetectionMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode2D.Continuous">
      <summary>
        <para>Ensures that all collisions are detected when a <see cref="T:UnityEngine.Rigidbody2D" /> moves.</para>
        <para>When using this mode, the collision detection system will detect all collisions in the path that a <see cref="T:UnityEngine.Rigidbody2D" /> moves along therefore preventing colliders attached to the rigidbody passing through other colliders at higher speeds. The physics system will also calculate a time-of-time calculation to ensure that the new position of the <see cref="T:UnityEngine.Rigidbody2D" /> is at the correct contact position with no overlaps. This mode however is much more expensive to calculate and should only be used when objects are moving at higher speeds or you are encountering objects overlapping or passing through each other.See Also: <see cref="P:UnityEngine.Rigidbody2D.collisionDetectionMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.None">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Sides">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Above">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Below">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Uninitialized">
      <summary>Uninitialized colorspace.</summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Gamma">
      <summary>Lightmap has been baked for gamma rendering.</summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Linear">
      <summary>Lightmap has been baked for linear rendering.</summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Default">
      <summary>
        <para>Default <see cref="T:UnityEngine.ComputeBuffer" /> type.</para>
        <para>A simple structured buffer in DX11.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Raw">
      <summary>
        <para>Raw <see cref="T:UnityEngine.ComputeBuffer" /> type.</para>
        <para>Buffer that allows raw unstructured access; underlying DX11 format is typeless R32.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Append">
      <summary>
        <para>Append-consume <see cref="T:UnityEngine.ComputeBuffer" /> type.</para>
        <para>Allows a buffer to be treated like a stack in compute shaders.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Counter">
      <summary>
        <see cref="T:UnityEngine.ComputeBuffer" /> with a counter.</summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.DrawIndirect">
      <summary>
        <see cref="T:UnityEngine.ComputeBuffer" /> used for Graphics.DrawProceduralIndirect.</summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Locked">
      <summary>Motion along the axis will be locked.</summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Limited">
      <summary>Motion along the axis will be limited by the respective limit.</summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Free">
      <summary>Motion along the axis will be completely free and completely unconstrained.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.Error">
      <summary>
        <para>Some unknown error occurred.</para>
        <para>Possibly there is no network connectivity available.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.Undetermined">
      <summary>Test result undetermined, still in progress.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPIsConnectable">
      <summary>Public IP address detected and game listen port is accessible to the internet.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPPortBlocked">
      <summary>Public IP address detected but the port is not connectable from the internet.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPNoServerStarted">
      <summary>Public IP address detected but server is not initialized and no port is listening.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.LimitedNATPunchthroughPortRestricted">
      <summary>Port-restricted NAT type, can do NAT punchthrough to everyone except symmetric.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.LimitedNATPunchthroughSymmetric">
      <summary>Symmetric NAT type, cannot do NAT punchthrough to other symmetric types nor port restricted type.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.NATpunchthroughFullCone">
      <summary>Full cone type, NAT punchthrough fully supported.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.NATpunchthroughAddressRestrictedCone">
      <summary>Address-restricted cone type, NAT punchthrough fully supported.</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.Unknown">
      <summary>Cubemap face is unknown or unspecified.</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveX">
      <summary>Right facing side (+x).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeX">
      <summary>Left facing side (-x).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveY">
      <summary>Upwards facing side (+y).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeY">
      <summary>Downward facing side (-y).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveZ">
      <summary>Forward facing side (+z).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeZ">
      <summary>Backward facing side (-z).</summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.None">
      <summary>Cursor behavior is unmodified.</summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.Locked">
      <summary>Lock cursor to the center of the game window.</summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.Confined">
      <summary>Confine cursor to the game window.</summary>
    </member>
    <member name="F:UnityEngine.CursorMode.Auto">
      <summary>Use hardware cursors on supported platforms.</summary>
    </member>
    <member name="F:UnityEngine.CursorMode.ForceSoftware">
      <summary>Force the use of software cursors.</summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.None">
      <summary>Do not generate depth texture (Default).</summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.Depth">
      <summary>
        <para>Generate a depth texture.</para>
        <para>Will generate a screen-space depth texture as seen from this camera. Texture will be in RenderTextureFormat.Depth format and will be set as <c>_CameraDepthTexture</c> global shader property.See Also: Using camera's depth textures, <see cref="P:UnityEngine.Camera.depthTextureMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.DepthNormals">
      <summary>
        <para>Generate a depth + normals texture.</para>
        <para>Will generate a screen-space depth and view space normals texture as seen from this camera. Texture will be in RenderTextureFormat.ARGB32 format and will be set as <c>_CameraDepthNormalsTexture</c> global shader property.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DetailRenderMode.GrassBillboard">
      <summary>
        <para>The detail prototype will be rendered as billboards that are always facing the camera.</para>
        <para>Grass will take normals from terrain directly underneath it, so that the shading matches the terrain.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DetailRenderMode.VertexLit">
      <summary>Will show the prototype using diffuse shading.</summary>
    </member>
    <member name="F:UnityEngine.DetailRenderMode.Grass">
      <summary>
        <para>The detail prototype will use the grass shader.</para>
        <para>When using custom meshes in this mode, control the wave amount by setting vertex color's alpha channel. Grass will take normals from terrain directly underneath it, so that the shading matches the terrain.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.Unknown">
      <summary>The orientation of the device cannot be determined.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.Portrait">
      <summary>The device is in portrait mode, with the device held upright and the home button at the bottom.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.PortraitUpsideDown">
      <summary>The device is in portrait mode but upside down, with the device held upright and the home button at the top.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.LandscapeLeft">
      <summary>The device is in landscape mode, with the device held upright and the home button on the right side.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.LandscapeRight">
      <summary>The device is in landscape mode, with the device held upright and the home button on the left side.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.FaceUp">
      <summary>The device is held parallel to the ground with the screen facing upwards.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.FaceDown">
      <summary>The device is held parallel to the ground with the screen facing downwards.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Unknown">
      <summary>Device type is unknown. You should never see this in practice.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Handheld">
      <summary>A handheld device like mobile phone or a tablet.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Console">
      <summary>A stationary gaming console.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Desktop">
      <summary>Desktop or laptop computer.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.None">
      <summary>Deselects all driven properties.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.All">
      <summary>Selects all driven properties.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionX">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionY">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionZ">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition3D" />.z.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Rotation">
      <summary>Selects driven property <see cref="P:UnityEngine.Transform.localRotation" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleX">
      <summary>Selects driven property <see cref="P:UnityEngine.Transform.localScale" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleY">
      <summary>Selects driven property <see cref="P:UnityEngine.Transform.localScale" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleZ">
      <summary>Selects driven property <see cref="P:UnityEngine.Transform.localScale" />.z.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMinX">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchorMin" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMinY">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchorMin" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMaxX">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchorMax" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMaxY">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchorMax" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDeltaX">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.sizeDelta" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDeltaY">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.sizeDelta" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.PivotX">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.pivot" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.PivotY">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.pivot" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPosition">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPosition3D">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition3D" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Scale">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.ScaleX" />, <see cref="F:UnityEngine.DrivenTransformProperties.ScaleY" /> &amp;&amp; <see cref="F:UnityEngine.DrivenTransformProperties.ScaleZ" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMin">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMinX" /> and <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMinY" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMax">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMaxX" /> and <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMaxY" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Anchors">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMinX" />, <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMinY" />, <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMaxX" /> and <see cref="F:UnityEngine.DrivenTransformProperties.AnchorMaxY" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDelta">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.SizeDeltaX" /> and <see cref="F:UnityEngine.DrivenTransformProperties.SizeDeltaY" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Pivot">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties.PivotX" /> and <see cref="F:UnityEngine.DrivenTransformProperties.PivotY" />.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition" />.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.">
      <summary>Selects driven property <see cref="P:UnityEngine.RectTransform.anchoredPosition" />.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.">
      <summary>Selects driven property <see cref="P:UnityEngine.Transform.localPosition" />.z.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.">
      <summary>Selects driven property combining <see cref="F:UnityEngine.DrivenTransformProperties." />, <see cref="F:UnityEngine.DrivenTransformProperties." /> and <see cref="F:UnityEngine.DrivenTransformProperties." />.</summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.Constant">
      <summary>The force is applied at a constant rate.</summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.InverseLinear">
      <summary>
        <para>The force is applied inverse-linear relative to a point.</para>
        <para>Inverse-linear falls off at the same rate as the distance from the point i.e. at a distance of 2 meter, the force is also reduced by 2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.InverseSquared">
      <summary>
        <para>The force is applied inverse-squared relative to a point.</para>
        <para>Inverse-squared falls off at the square of the distance from the point i.e. at a distance of 2 meter, the force is reduced by 4.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorSelection2D.Rigidbody">
      <summary>
        <para>The source/target is defined by the <see cref="T:UnityEngine.Rigidbody2D" />.</para>
        <para>When used, this equates to the center-of-mass.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorSelection2D.Collider">
      <summary>The source/target is defined by the <see cref="T:UnityEngine.Collider2D" />.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.None">
      <summary>No modifier key pressed during a keystroke event.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.Shift">
      <summary>Shift key.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.Control">
      <summary>Control key.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.Alt">
      <summary>Alt key.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.Command">
      <summary>Command key (Mac).</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.Numeric">
      <summary>Num lock key.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.CapsLock">
      <summary>Caps lock key.</summary>
    </member>
    <member name="F:UnityEngine.EventModifiers.FunctionKey">
      <summary>Function key.</summary>
    </member>
    <member name="F:UnityEngine.EventType.MouseDown">
      <summary>
        <para>Mouse button was pressed.</para>
        <para>This event gets sent when any mouse button is pressed. Use Event.button to determine which button was pressed down.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.MouseUp">
      <summary>
        <para>Mouse button was released.</para>
        <para>This event gets sent when any mouse button is released. Use Event.button to determine which button was pressed down.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.MouseMove">
      <summary>
        <para>Mouse was moved (editor views only).</para>
        <para>The mouse was moved without any buttons being held down. Use Event.mousePosition and Event.delta to determine mouse motion.Note that this even is only sent in the Editor, for <see cref="T:UnityEditor.EditorWindow" /> windows which have EditorWindow.wantsMouseMove set to true. Mouse move events are never sent in the games.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.MouseDrag">
      <summary>
        <para>Mouse was dragged.</para>
        <para>The mouse was moved with a button held down - a mouse drag. Use Event.mousePosition and Event.delta to determine mouse motion.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.KeyDown">
      <summary>
        <para>A keyboard key was pressed.</para>
        <para>Use Event.character to find out what has been typed. Use Event.keyCode to handle arrow, home/end or other function keys, or to find out which physical key has been pressed. This event is sent repeatedly depending on the end user's keyboard repeat settings.Note that key presses can come as separate events, one with valid Event.keyCode, and another with valid Event.character. In case of keyboard layouts with dead keys, multiple Event.keyCode events can generate a single Event.character event.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.KeyUp">
      <summary>
        <para>A keyboard key was released.</para>
        <para>Use Event.keyCode to find which physical key was released. Note that depending on the system and keyboard layout, Event.character might not contain any character for a key release event.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.ScrollWheel">
      <summary>
        <para>The scroll wheel was moved.</para>
        <para>Use Event.delta to determine X &amp; Y scrolling amount.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.Repaint">
      <summary>
        <para>A repaint event. One is sent every frame.</para>
        <para>All other events are processed first, then the repaint event is sent.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.Layout">
      <summary>
        <para>A layout event.</para>
        <para>This event is sent prior to anything else - this is a chance to perform any initialization. It is used by the automatic layout system.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.DragUpdated">
      <summary>Editor only: drag &amp; drop operation updated.</summary>
    </member>
    <member name="F:UnityEngine.EventType.DragPerform">
      <summary>Editor only: drag &amp; drop operation performed.</summary>
    </member>
    <member name="F:UnityEngine.EventType.DragExited">
      <summary>Editor only: drag &amp; drop operation exited.</summary>
    </member>
    <member name="F:UnityEngine.EventType.Ignore">
      <summary>
        <para>
          <see cref="T:UnityEngine.Event" /> should be ignored.</para>
        <para>This event is temporarily disabled and should be ignored.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.Used">
      <summary>
        <para>Already processed event.</para>
        <para>This event has been used by some other control and should be ignored.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.ValidateCommand">
      <summary>
        <para>Validates a special command (e.g. copy &amp; paste).</para>
        <para>"Copy", "Cut", "Paste", "Delete", "FrameSelected", "Duplicate", "SelectAll" and so on. Sent only in the editor.Example: Make pasting work in current window or control:</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.ExecuteCommand">
      <summary>
        <para>Execute a special command (eg. copy &amp; paste).</para>
        <para>"Copy", "Cut", "Paste", "Delete", "FrameSelected", "Duplicate", "SelectAll" and so on. Sent only in the editor.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EventType.ContextClick">
      <summary>
        <para>User has right-clicked (or control-clicked on the mac).</para>
        <para>Window should show a context menu if applicable. Sent only in the editor.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.Rectangular">
      <summary>W[n] = 1.0.</summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.Triangle">
      <summary>W[n] = TRI(2n/N).</summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.Hamming">
      <summary>W[n] = 0.54 - (0.46 * COS(n/N) ).</summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.Hanning">
      <summary>W[n] = 0.5 * (1.0 - COS(n/N) ).</summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.Blackman">
      <summary>W[n] = 0.42 - (0.5 * COS(n/N) ) + (0.08 * COS(2.0 * n/N) ).</summary>
    </member>
    <member name="F:UnityEngine.FFTWindow.BlackmanHarris">
      <summary>W[n] = 0.35875 - (0.48829 * COS(1.0 * n/N)) + (0.14128 * COS(2.0 * n/N)) - (0.01168 * COS(3.0 * n/N)).</summary>
    </member>
    <member name="F:UnityEngine.FilterMode.Point">
      <summary>Point filtering - texture pixels become blocky up close.</summary>
    </member>
    <member name="F:UnityEngine.FilterMode.Bilinear">
      <summary>Bilinear filtering - texture samples are averaged.</summary>
    </member>
    <member name="F:UnityEngine.FilterMode.Trilinear">
      <summary>
        <para>Trilinear filtering - texture samples are averaged and also blended between mipmap levels.</para>
        <para>RenderTextures do not support mipmaps, so this setting reverts to Bilinear for those.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FocusType.Native">
      <summary>This control can get keyboard focus on Windows, but not on Mac. Used for buttons, checkboxes and other "pressable" things.</summary>
    </member>
    <member name="F:UnityEngine.FocusType.Keyboard">
      <summary>This is a proper keyboard control. It can have input focus on all platforms. Used for TextField and TextArea controls.</summary>
    </member>
    <member name="F:UnityEngine.FocusType.Passive">
      <summary>This control can never recieve keyboard focus.</summary>
    </member>
    <member name="F:UnityEngine.FogMode.Linear">
      <summary>Linear fog.</summary>
    </member>
    <member name="F:UnityEngine.FogMode.Exponential">
      <summary>Exponential fog.</summary>
    </member>
    <member name="F:UnityEngine.FogMode.ExponentialSquared">
      <summary>Exponential squared fog (default).</summary>
    </member>
    <member name="F:UnityEngine.FontStyle.Normal">
      <summary>No special style is applied.</summary>
    </member>
    <member name="F:UnityEngine.FontStyle.Bold">
      <summary>Bold style applied to your texts.</summary>
    </member>
    <member name="F:UnityEngine.FontStyle.Italic">
      <summary>Italic style applied to your texts.</summary>
    </member>
    <member name="F:UnityEngine.FontStyle.BoldAndItalic">
      <summary>Bold and Italic styles applied to your texts.</summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Force">
      <summary>
        <para>Add a continuous force to the rigidbody, using its mass.</para>
        <para>Apply the force in each FixedUpdate over a duration of time. This mode depends on the mass of rigidbody so more force must be applied to push or twist higher-mass objects the same amount as lower-mass objects. This mode is useful for setting up realistic physics where it takes more force to move heavier objects. In this mode, the unit of the force parameter is applied to the rigidbody as mass*distance/time^2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Acceleration">
      <summary>
        <para>Add a continuous acceleration to the rigidbody, ignoring its mass.</para>
        <para>Apply the acceleration in each FixedUpdate over a duration of time. In contrast to ForceMode.Force, Acceleration will move every rigidbody the same way regardless of differences in mass. This mode is useful if you just want to control the acceleration of an object directly. In this mode, the unit of the force parameter is applied to the rigidbody as distance/time^2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Impulse">
      <summary>
        <para>Add an instant force impulse to the rigidbody, using its mass.</para>
        <para>Apply the impulse force instantly with a single function call. This mode depends on the mass of rigidbody so more force must be applied to push or twist higher-mass objects the same amount as lower-mass objects. This mode is useful for applying forces that happen instantly, such as forces from explosions or collisions. In this mode, the unit of the force parameter is applied to the rigidbody as mass*distance/time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.VelocityChange">
      <summary>
        <para>Add an instant velocity change to the rigidbody, ignoring its mass.</para>
        <para>Apply the velocity change instantly with a single function call. In contrast to ForceMode.Impulse, VelocityChange will change the velocity of every rigidbody the same way regardless of differences in mass. This mode is useful for something like a fleet of differently-sized space ships that you want to control without accounting for differences in mass. In this mode, the unit of the force parameter is applied to the rigidbody as distance/time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode2D.Force">
      <summary>
        <para>Add a force to the Rigidbody2D, using its mass.</para>
        <para>Apply the force in each FixedUpdate over a duration of time. This mode depends on the mass of rigidbody so more force must be applied to move higher-mass objects the same amount as lower-mass objects.This mode is useful for setting up realistic physics where it takes more force to move heavier objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode2D.Impulse">
      <summary>
        <para>Add an instant force impulse to the rigidbody2D, using its mass.</para>
        <para>Apply the impulse force instantly. This mode depends on the mass of rigidbody so more force must be applied to move higher-mass objects the same amount as lower-mass objects.This mode is useful for applying forces that happen instantly, such as forces from explosions or collisions.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Full">
      <summary>
        <para>Display the standard controls for controlling movie playback.</para>
        <para>This includes play/pause controls, a volume slider, and a timeline control.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Minimal">
      <summary>
        <para>Display minimal set of controls controlling movie playback.</para>
        <para>The set of controls displayed might differ between OS versions.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.CancelOnInput">
      <summary>Do not display any controls, but cancel movie playback if input occurs.</summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Hidden">
      <summary>
        <para>Do not display any controls.</para>
        <para>This mode prevents the user from controlling playback.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.None">
      <summary>Do not scale the movie.</summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.AspectFit">
      <summary>
        <para>Scale the movie until one dimension fits on the screen exactly.</para>
        <para>In the other dimension, the region between the edge of the movie and the edge of the screen is filled with a black bar. The aspect ratio of the movie is preserved.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.AspectFill">
      <summary>
        <para>Scale the movie until the movie fills the entire screen.</para>
        <para>Content at the edges of the larger of the two dimensions is clipped so that the other dimension fits the screen exactly. The aspect ratio of the movie is preserved.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.Fill">
      <summary>
        <para>Scale the movie until both dimensions fit the screen exactly.</para>
        <para>The aspect ratio of the movie is not preserved.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.None">
      <summary>A normal, visible object. This is the default.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideInHierarchy">
      <summary>The object will not appear in the hierarchy.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideInInspector">
      <summary>It is not possible to view it in the inspector.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSaveInEditor">
      <summary>The object will not be saved to the scene in the editor.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.NotEditable">
      <summary>The object is not be editable in the inspector.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontUnloadUnusedAsset">
      <summary>
        <para>The object will not be unloaded by Resources.UnloadUnusedAssets.</para>
        <para>It is your responsibility to cleanup the object manually using DestroyImmediate, otherwise it will leak.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSaveInBuild">
      <summary>The object will not be saved when building a player.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSave">
      <summary>
        <para>The object will not be saved to the scene. It will not be destroyed when a new scene is loaded. It is a shortcut for HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor | HideFlags.DontUnloadUnusedAsset.</para>
        <para>It is your responsibility to cleanup the object manually using DestroyImmediate, otherwise it will leak.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideAndDontSave">
      <summary>
        <para>A combination of not shown in the hierarchy, not saved to to scenes and not unloaded by The object will not be unloaded by Resources.UnloadUnusedAssets.</para>
        <para>This is most commonly used for objects which are created by scripts and are purely under their control.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HorizontalWrapMode.Wrap">
      <summary>Text will word-wrap when reaching the horizontal boundary.</summary>
    </member>
    <member name="F:UnityEngine.HorizontalWrapMode.Overflow">
      <summary>Text can exceed the horizontal boundary.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Hips">
      <summary>This is the Hips bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftUpperLeg">
      <summary>This is the Left Upper Leg bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightUpperLeg">
      <summary>This is the Right Upper Leg bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLowerLeg">
      <summary>This is the Left Knee bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLowerLeg">
      <summary>This is the Right Knee bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftFoot">
      <summary>This is the Left Ankle bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightFoot">
      <summary>This is the Right Ankle bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Spine">
      <summary>This is the first Spine bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Chest">
      <summary>This is the Chest bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Neck">
      <summary>This is the Neck bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Head">
      <summary>This is the Head bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftShoulder">
      <summary>This is the Left Shoulder bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightShoulder">
      <summary>This is the Right Shoulder bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftUpperArm">
      <summary>This is the Left Upper Arm bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightUpperArm">
      <summary>This is the Right Upper Arm bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLowerArm">
      <summary>This is the Left Elbow bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLowerArm">
      <summary>This is the Right Elbow bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftHand">
      <summary>This is the Left Wrist bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightHand">
      <summary>This is the Right Wrist bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftToes">
      <summary>This is the Left Toes bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightToes">
      <summary>This is the Right Toes bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftEye">
      <summary>This is the Left Eye bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightEye">
      <summary>This is the Right Eye bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Jaw">
      <summary>This is the Jaw bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbProximal">
      <summary>This is the left thumb 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbIntermediate">
      <summary>This is the left thumb 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbDistal">
      <summary>This is the left thumb 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexProximal">
      <summary>This is the left index 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexIntermediate">
      <summary>This is the left index 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexDistal">
      <summary>This is the left index 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleProximal">
      <summary>This is the left middle 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleIntermediate">
      <summary>This is the left middle 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleDistal">
      <summary>This is the left middle 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingProximal">
      <summary>This is the left ring 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingIntermediate">
      <summary>This is the left ring 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingDistal">
      <summary>This is the left ring 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleProximal">
      <summary>This is the left little 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleIntermediate">
      <summary>This is the left little 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleDistal">
      <summary>This is the left little 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbProximal">
      <summary>This is the right thumb 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbIntermediate">
      <summary>This is the right thumb 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbDistal">
      <summary>This is the right thumb 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexProximal">
      <summary>This is the right index 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexIntermediate">
      <summary>This is the right index 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexDistal">
      <summary>This is the right index 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleProximal">
      <summary>This is the right middle 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleIntermediate">
      <summary>This is the right middle 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleDistal">
      <summary>This is the right middle 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingProximal">
      <summary>This is the right ring 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingIntermediate">
      <summary>This is the right ring 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingDistal">
      <summary>This is the right ring 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleProximal">
      <summary>This is the right little 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleIntermediate">
      <summary>This is the right little 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleDistal">
      <summary>This is the right little 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LastBone">
      <summary>This is the Last bone index delimiter.</summary>
    </member>
    <member name="F:UnityEngine.ImagePosition.ImageLeft">
      <summary>Image is to the left of the text.</summary>
    </member>
    <member name="F:UnityEngine.ImagePosition.ImageAbove">
      <summary>Image is above the text.</summary>
    </member>
    <member name="F:UnityEngine.ImagePosition.ImageOnly">
      <summary>Only the image is displayed.</summary>
    </member>
    <member name="F:UnityEngine.ImagePosition.TextOnly">
      <summary>Only the text is displayed.</summary>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.Auto">
      <summary>Enable IME input only when a text field is selected (default).</summary>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.On">
      <summary>Enable IME input.</summary>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.Off">
      <summary>Disable IME input.</summary>
    </member>
    <member name="F:UnityEngine.JointDriveMode.None">
      <summary>Don't apply any forces to reach the target.</summary>
    </member>
    <member name="F:UnityEngine.JointDriveMode.Position">
      <summary>Try to reach the specified target position.</summary>
    </member>
    <member name="F:UnityEngine.JointDriveMode.Velocity">
      <summary>Try to reach the specified target velocity.</summary>
    </member>
    <member name="F:UnityEngine.JointDriveMode.PositionAndVelocity">
      <summary>Try to reach the specified target position and velocity.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.Inactive">
      <summary>Represents a state where the joint limit is inactive.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.LowerLimit">
      <summary>Represents a state where the joint limit is at the specified lower limit.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.UpperLimit">
      <summary>Represents a state where the joint limit is at the specified upper limit.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.EqualLimits">
      <summary>Represents a state where the joint limit is at the specified lower and upper limits (they are identical).</summary>
    </member>
    <member name="F:UnityEngine.JointProjectionMode.None">
      <summary>Don't snap at all.</summary>
    </member>
    <member name="F:UnityEngine.JointProjectionMode.PositionAndRotation">
      <summary>Snap both position and rotation.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.None">
      <summary>Not assigned (never returned as the result of a keystroke).</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Backspace">
      <summary>The backspace key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Delete">
      <summary>The forward delete key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Tab">
      <summary>The tab key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Clear">
      <summary>The Clear key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Return">
      <summary>Return key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Pause">
      <summary>Pause on PC machines.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Escape">
      <summary>Escape key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Space">
      <summary>Space key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad0">
      <summary>Numeric keypad 0.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad1">
      <summary>Numeric keypad 1.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad2">
      <summary>Numeric keypad 2.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad3">
      <summary>Numeric keypad 3.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad4">
      <summary>Numeric keypad 4.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad5">
      <summary>Numeric keypad 5.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad6">
      <summary>Numeric keypad 6.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad7">
      <summary>Numeric keypad 7.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad8">
      <summary>Numeric keypad 8.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad9">
      <summary>Numeric keypad 9.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadPeriod">
      <summary>Numeric keypad '.'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadDivide">
      <summary>Numeric keypad '/'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadMultiply">
      <summary>Numeric keypad '*'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadMinus">
      <summary>Numeric keypad '-'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadPlus">
      <summary>Numeric keypad '+'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadEnter">
      <summary>Numeric keypad enter.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadEquals">
      <summary>Numeric keypad '='.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.UpArrow">
      <summary>Up arrow key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.DownArrow">
      <summary>Down arrow key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightArrow">
      <summary>Right arrow key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftArrow">
      <summary>Left arrow key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Insert">
      <summary>Insert key key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Home">
      <summary>Home key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.End">
      <summary>End key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.PageUp">
      <summary>Page up.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.PageDown">
      <summary>Page down.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F1">
      <summary>F1 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F2">
      <summary>F2 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F3">
      <summary>F3 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F4">
      <summary>F4 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F5">
      <summary>F5 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F6">
      <summary>F6 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F7">
      <summary>F7 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F8">
      <summary>F8 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F9">
      <summary>F9 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F10">
      <summary>F10 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F11">
      <summary>F11 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F12">
      <summary>F12 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F13">
      <summary>F13 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F14">
      <summary>F14 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F15">
      <summary>F15 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha0">
      <summary>The '0' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha1">
      <summary>The '1' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha2">
      <summary>The '2' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha3">
      <summary>The '3' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha4">
      <summary>The '4' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha5">
      <summary>The '5' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha6">
      <summary>The '6' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha7">
      <summary>The '7' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha8">
      <summary>The '8' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha9">
      <summary>The '9' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Exclaim">
      <summary>Exclamation mark key '!'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.DoubleQuote">
      <summary>Double quote key '"'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Hash">
      <summary>Hash key '#'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Dollar">
      <summary>Dollar sign key '$'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Ampersand">
      <summary>Ampersand key '&amp;'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Quote">
      <summary>Quote key '.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftParen">
      <summary>Left Parenthesis key '('.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightParen">
      <summary>Right Parenthesis key ')'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Asterisk">
      <summary>Asterisk key '*'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Plus">
      <summary>Plus key '+'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Comma">
      <summary>Comma ',' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Minus">
      <summary>Minus '-' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Period">
      <summary>Period '.' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Slash">
      <summary>Slash '/' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Colon">
      <summary>Colon ':' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Semicolon">
      <summary>Semicolon ';' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Less">
      <summary>Less than '&lt;' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Equals">
      <summary>Equals '=' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Greater">
      <summary>Greater than '&gt;' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Question">
      <summary>Question mark '?' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.At">
      <summary>At key '@'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftBracket">
      <summary>Left square bracket key '['.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Backslash">
      <summary>Backslash key '\'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightBracket">
      <summary>Right square bracket key ']'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Caret">
      <summary>Caret key '^'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Underscore">
      <summary>Underscore '_' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.BackQuote">
      <summary>Back quote key '`'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.A">
      <summary>'a' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.B">
      <summary>'b' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.C">
      <summary>'c' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.D">
      <summary>'d' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.E">
      <summary>'e' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F">
      <summary>'f' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.G">
      <summary>'g' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.H">
      <summary>'h' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.I">
      <summary>'i' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.J">
      <summary>'j' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.K">
      <summary>'k' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.L">
      <summary>'l' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.M">
      <summary>'m' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.N">
      <summary>'n' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.O">
      <summary>'o' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.P">
      <summary>'p' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Q">
      <summary>'q' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.R">
      <summary>'r' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.S">
      <summary>'s' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.T">
      <summary>'t' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.U">
      <summary>'u' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.V">
      <summary>'v' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.W">
      <summary>'w' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.X">
      <summary>'x' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Y">
      <summary>'y' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Z">
      <summary>'z' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Numlock">
      <summary>Numlock key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.CapsLock">
      <summary>Capslock key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.ScrollLock">
      <summary>Scroll lock key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightShift">
      <summary>Right shift key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftShift">
      <summary>Left shift key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightControl">
      <summary>Right Control key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftControl">
      <summary>Left Control key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightAlt">
      <summary>Right Alt key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftAlt">
      <summary>Left Alt key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftCommand">
      <summary>Left Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftApple">
      <summary>Left Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftWindows">
      <summary>Left Windows key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightCommand">
      <summary>Right Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightApple">
      <summary>Right Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightWindows">
      <summary>Right Windows key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.AltGr">
      <summary>Alt Gr key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Help">
      <summary>Help key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Print">
      <summary>Print key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.SysReq">
      <summary>Sys Req key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Break">
      <summary>Break key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Menu">
      <summary>Menu key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse0">
      <summary>First (primary) mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse1">
      <summary>Second (secondary) mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse2">
      <summary>Third mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse3">
      <summary>Fourth mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse4">
      <summary>Fifth mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse5">
      <summary>Sixth mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse6">
      <summary>Seventh mouse button.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton0">
      <summary>Button 0 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton1">
      <summary>Button 1 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton2">
      <summary>Button 2 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton3">
      <summary>Button 3 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton4">
      <summary>Button 4 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton5">
      <summary>Button 5 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton6">
      <summary>Button 6 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton7">
      <summary>Button 7 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton8">
      <summary>Button 8 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton9">
      <summary>Button 9 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton10">
      <summary>Button 10 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton11">
      <summary>Button 11 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton12">
      <summary>Button 12 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton13">
      <summary>Button 13 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton14">
      <summary>Button 14 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton15">
      <summary>Button 15 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton16">
      <summary>Button 16 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton17">
      <summary>Button 17 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton18">
      <summary>Button 18 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton19">
      <summary>Button 19 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button0">
      <summary>Button 0 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button1">
      <summary>Button 1 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button2">
      <summary>Button 2 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button3">
      <summary>Button 3 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button4">
      <summary>Button 4 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button5">
      <summary>Button 5 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button6">
      <summary>Button 6 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button7">
      <summary>Button 7 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button8">
      <summary>Button 8 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button9">
      <summary>Button 9 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button10">
      <summary>Button 10 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button11">
      <summary>Button 11 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button12">
      <summary>Button 12 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button13">
      <summary>Button 13 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button14">
      <summary>Button 14 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button15">
      <summary>Button 15 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button16">
      <summary>Button 16 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button17">
      <summary>Button 17 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button18">
      <summary>Button 18 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button19">
      <summary>Button 19 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button0">
      <summary>Button 0 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button1">
      <summary>Button 1 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button2">
      <summary>Button 2 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button3">
      <summary>Button 3 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button4">
      <summary>Button 4 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button5">
      <summary>Button 5 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button6">
      <summary>Button 6 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button7">
      <summary>Button 7 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button8">
      <summary>Button 8 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button9">
      <summary>Button 9 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button10">
      <summary>Button 10 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button11">
      <summary>Button 11 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button12">
      <summary>Button 12 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button13">
      <summary>Button 13 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button14">
      <summary>Button 14 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button15">
      <summary>Button 15 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button16">
      <summary>Button 16 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button17">
      <summary>Button 17 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button18">
      <summary>Button 18 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button19">
      <summary>Button 19 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button0">
      <summary>Button 0 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button1">
      <summary>Button 1 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button2">
      <summary>Button 2 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button3">
      <summary>Button 3 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button4">
      <summary>Button 4 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button5">
      <summary>Button 5 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button6">
      <summary>Button 6 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button7">
      <summary>Button 7 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button8">
      <summary>Button 8 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button9">
      <summary>Button 9 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button10">
      <summary>Button 10 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button11">
      <summary>Button 11 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button12">
      <summary>Button 12 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button13">
      <summary>Button 13 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button14">
      <summary>Button 14 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button15">
      <summary>Button 15 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button16">
      <summary>Button 16 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button17">
      <summary>Button 17 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button18">
      <summary>Button 18 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button19">
      <summary>Button 19 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button0">
      <summary>Button 0 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button1">
      <summary>Button 1 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button2">
      <summary>Button 2 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button3">
      <summary>Button 3 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button4">
      <summary>Button 4 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button5">
      <summary>Button 5 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button6">
      <summary>Button 6 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button7">
      <summary>Button 7 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button8">
      <summary>Button 8 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button9">
      <summary>Button 9 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button10">
      <summary>Button 10 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button11">
      <summary>Button 11 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button12">
      <summary>Button 12 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button13">
      <summary>Button 13 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button14">
      <summary>Button 14 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button15">
      <summary>Button 15 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button16">
      <summary>Button 16 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button17">
      <summary>Button 17 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button18">
      <summary>Button 18 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button19">
      <summary>Button 19 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button0">
      <summary>Button 0 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button1">
      <summary>Button 1 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button2">
      <summary>Button 2 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button3">
      <summary>Button 3 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button4">
      <summary>Button 4 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button5">
      <summary>Button 5 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button6">
      <summary>Button 6 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button7">
      <summary>Button 7 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button8">
      <summary>Button 8 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button9">
      <summary>Button 9 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button10">
      <summary>Button 10 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button11">
      <summary>Button 11 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button12">
      <summary>Button 12 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button13">
      <summary>Button 13 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button14">
      <summary>Button 14 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button15">
      <summary>Button 15 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button16">
      <summary>Button 16 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button17">
      <summary>Button 17 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button18">
      <summary>Button 18 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button19">
      <summary>Button 19 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button0">
      <summary>Button 0 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button1">
      <summary>Button 1 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button2">
      <summary>Button 2 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button3">
      <summary>Button 3 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button4">
      <summary>Button 4 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button5">
      <summary>Button 5 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button6">
      <summary>Button 6 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button7">
      <summary>Button 7 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button8">
      <summary>Button 8 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button9">
      <summary>Button 9 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button10">
      <summary>Button 10 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button11">
      <summary>Button 11 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button12">
      <summary>Button 12 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button13">
      <summary>Button 13 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button14">
      <summary>Button 14 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button15">
      <summary>Button 15 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button16">
      <summary>Button 16 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button17">
      <summary>Button 17 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button18">
      <summary>Button 18 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button19">
      <summary>Button 19 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button0">
      <summary>Button 0 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button1">
      <summary>Button 1 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button2">
      <summary>Button 2 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button3">
      <summary>Button 3 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button4">
      <summary>Button 4 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button5">
      <summary>Button 5 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button6">
      <summary>Button 6 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button7">
      <summary>Button 7 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button8">
      <summary>Button 8 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button9">
      <summary>Button 9 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button10">
      <summary>Button 10 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button11">
      <summary>Button 11 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button12">
      <summary>Button 12 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button13">
      <summary>Button 13 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button14">
      <summary>Button 14 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button15">
      <summary>Button 15 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button16">
      <summary>Button 16 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button17">
      <summary>Button 17 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button18">
      <summary>Button 18 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button19">
      <summary>Button 19 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button0">
      <summary>Button 0 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button1">
      <summary>Button 1 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button2">
      <summary>Button 2 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button3">
      <summary>Button 3 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button4">
      <summary>Button 4 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button5">
      <summary>Button 5 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button6">
      <summary>Button 6 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button7">
      <summary>Button 7 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button8">
      <summary>Button 8 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button9">
      <summary>Button 9 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button10">
      <summary>Button 10 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button11">
      <summary>Button 11 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button12">
      <summary>Button 12 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button13">
      <summary>Button 13 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button14">
      <summary>Button 14 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button15">
      <summary>Button 15 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button16">
      <summary>Button 16 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button17">
      <summary>Button 17 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button18">
      <summary>Button 18 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button19">
      <summary>Button 19 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsMode.NonDirectional">
      <summary>Light intensity (no directional information), encoded as 1 lightmap.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsMode.CombinedDirectional">
      <summary>Directional information for direct light is combined with directional information for indirect light, encoded as 2 lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsMode.SeparateDirectional">
      <summary>Directional information for direct light is stored separately from directional information for indirect light, encoded as 4 lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Single">
      <summary>Single, traditional lightmap rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Dual">
      <summary>Dual lightmap rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Directional">
      <summary>Directional rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.LightRenderMode.Auto">
      <summary>
        <para>Automatically choose the render mode.</para>
        <para>This chooses whether to render the <see cref="T:UnityEngine.Light" /> as a pixel or vertex light (recommended and default).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightRenderMode.ForcePixel">
      <summary>
        <para>Force the <see cref="T:UnityEngine.Light" /> to be a pixel light.</para>
        <para>Use this only for really important lights, like a player flashlight.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightRenderMode.ForceVertex">
      <summary>
        <para>Force the <see cref="T:UnityEngine.Light" /> to be a vertex light.</para>
        <para>This option is good for background or distant lighting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightShadows.None">
      <summary>Do not cast shadows (default).</summary>
    </member>
    <member name="F:UnityEngine.LightShadows.Hard">
      <summary>Cast "hard" shadows (with no shadow filtering).</summary>
    </member>
    <member name="F:UnityEngine.LightShadows.Soft">
      <summary>Cast "soft" shadows (with 4x PCF filtering).</summary>
    </member>
    <member name="F:UnityEngine.LightType.Spot">
      <summary>The light is a spot light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Directional">
      <summary>The light is a directional light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Point">
      <summary>The light is a point light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Area">
      <summary>The light is an area light. It affects only lightmaps and lightprobes.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Stopped">
      <summary>Location service is stopped.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Initializing">
      <summary>
        <para>Location service is initializing, some time later it will switch to.</para>
        <para>Running or Failed.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Running">
      <summary>Location service is running and locations could be queried.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Failed">
      <summary>Location service failed (user denied access to location service).</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.None">
      <summary>Indicates the LOD fading is turned off.</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.CrossFade">
      <summary>Perform cross-fade style blending between the current LOD and the next LOD if the distance to camera falls in the range specified by the <see cref="F:UnityEngine.LOD.fadeTransitionWidth" /> of each LOD.</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.SpeedTree">
      <summary>By specifying this mode, your LODGroup will perform a SpeedTree-style LOD fading scheme: * For all the mesh LODs other than the last (most crude) mesh LOD, the fade factor is calculated as the percentage of the object's current screen height, compared to the whole range of the LOD. It is 1, if the camera is right at the position where the previous LOD switches out and 0, if the next LOD is just about to switch in. * For the last mesh LOD and the billboard LOD, the cross-fade mode is used.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Error">
      <summary>LogType used for Errors.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Assert">
      <summary>LogType used for Asserts. (These could also indicate an error inside Unity itself.)</summary>
    </member>
    <member name="F:UnityEngine.LogType.Warning">
      <summary>LogType used for Warnings.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Log">
      <summary>LogType used for regular log messages.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Exception">
      <summary>LogType used for Exceptions.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedGameName">
      <summary>Registration failed because an empty game name was given.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedGameType">
      <summary>Registration failed because an empty game type was given.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedNoServer">
      <summary>Registration failed because no server is running.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationSucceeded">
      <summary>Registration to master server succeeded, received confirmation.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.HostListReceived">
      <summary>Received a host list from the master server.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.None">
      <summary>The emissive lighting should not affect Global Illumination at all.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.RealtimeEmissive">
      <summary>The emissive lighting should affect Global Illumination. It should emit lighting into realtime lightmaps and realtime lightprobes.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.BakedEmissive">
      <summary>The emissive lighting should affect Global Illumination. It should emit lighting into baked lightmaps and baked lightprobes.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.EmissiveIsBlack">
      <summary>The emissive lighting is guaranteed to be black. This lets the lightmapping system know that it doesn't have to extract emissive lighting information from the material and can simply assume it is completely black.</summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Triangles">
      <summary>
        <para>Mesh is made from triangles.</para>
        <para>Each three indices in the mesh index buffer form a triangular face.See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Quads">
      <summary>
        <para>Mesh is made from quads.</para>
        <para>Each four indices in the mesh index buffer form a quadrangular face. Note that quad topology is emulated on many platforms, so it's more efficient to use a triangular mesh. Unless you really need quads, for example if using DirectX 11 tessellation shaders that operate on quad patches.See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Lines">
      <summary>
        <para>Mesh is made from lines.</para>
        <para>Each two indices in the mesh index buffer form a line.See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.LineStrip">
      <summary>
        <para>Mesh is a line strip.</para>
        <para>First two indices form a line, and then each new index connects a new vertex to the existing line strip.See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Points">
      <summary>
        <para>Mesh is made from points.</para>
        <para>In most of use cases, mesh index buffer should be "indendity": 0, 1, 2, 3, 4, 5, ...See Also: Mesh.SetIndices function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NavMeshObstacleShape.Capsule">
      <summary>Capsule shaped obstacle.</summary>
    </member>
    <member name="F:UnityEngine.NavMeshObstacleShape.Box">
      <summary>Box shaped obstacle.</summary>
    </member>
    <member name="F:UnityEngine.NavMeshPathStatus.PathComplete">
      <summary>The path terminates at the destination.</summary>
    </member>
    <member name="F:UnityEngine.NavMeshPathStatus.PathPartial">
      <summary>The path cannot reach the destination.</summary>
    </member>
    <member name="F:UnityEngine.NavMeshPathStatus.PathInvalid">
      <summary>The path is invalid.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NoError">
      <summary>No error occurred.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.RSAPublicKeyMismatch">
      <summary>We presented an RSA public key which does not match what the system we connected to is using.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.InvalidPassword">
      <summary>The server is using a password and has refused our connection because we did not set the correct password.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.ConnectionFailed">
      <summary>Connection attempt failed, possibly because of internal connectivity problems.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.TooManyConnectedPlayers">
      <summary>The server is at full capacity, failed to connect.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.ConnectionBanned">
      <summary>We are banned from the system we attempted to connect to (likely temporarily).</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.AlreadyConnectedToServer">
      <summary>We are already connected to this particular server (can happen after fast disconnect/reconnect).</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.AlreadyConnectedToAnotherServer">
      <summary>Cannot connect to two servers at once. Close the connection before connecting again.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.CreateSocketOrThreadFailure">
      <summary>Internal error while attempting to initialize network interface. Socket possibly already in use.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.IncorrectParameters">
      <summary>Incorrect parameters given to Connect function.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.EmptyConnectTarget">
      <summary>No host target given in Connect.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.InternalDirectConnectFailed">
      <summary>Client could not connect internally to same network NAT enabled server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATTargetNotConnected">
      <summary>The NAT target we are trying to connect to is not connected to the facilitator server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATTargetConnectionLost">
      <summary>Connection lost while attempting to connect to NAT target.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATPunchthroughFailed">
      <summary>NAT punchthrough attempt has failed. The cause could be a too restrictive NAT implementation on either endpoints.</summary>
    </member>
    <member name="F:UnityEngine.NetworkDisconnection.LostConnection">
      <summary>The connection to the system has been lost, no reliable packets could be delivered.</summary>
    </member>
    <member name="F:UnityEngine.NetworkDisconnection.Disconnected">
      <summary>The connection to the system has been closed.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Off">
      <summary>Only report errors, otherwise silent.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Informational">
      <summary>Report informational messages like connectivity events.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Full">
      <summary>Full debug level logging down to each individual message being reported.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Disconnected">
      <summary>No client connection running. Server not initialized.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Server">
      <summary>Running as server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Client">
      <summary>Running as client.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Connecting">
      <summary>Attempting to connect to a server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.NotReachable">
      <summary>Network is not reachable.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.ReachableViaCarrierDataNetwork">
      <summary>Network is reachable via carrier data network.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.ReachableViaLocalAreaNetwork">
      <summary>Network is reachable via WiFi or cable.</summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.Off">
      <summary>No state data will be synchronized.</summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.ReliableDeltaCompressed">
      <summary>
        <para>All packets are sent reliable and ordered.</para>
        <para>Delta compression is used to send only the difference between the last sent state and the current state. For example if you synchronize a <see cref="T:UnityEngine.Transform" />. Scale x, y, z is most likely going to keep the same value. Unity compares the state received by the client to the new state, if it is changed 1 bit and the data will be sent. If it didn't change only a single bit will be sent. When Unity detects that nothing has changed since the last state, no data will be sent at all.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.Unreliable">
      <summary>Brute force unreliable state sending.</summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.None">
      <summary>NPOT textures are not supported. Will be upscaled/padded at loading time.</summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.Restricted">
      <summary>
        <para>Limited NPOT support: no mip-maps and clamp <see cref="T:UnityEngine.TextureWrapMode" /> will be forced.</para>
        <para>If NPOT Texture do have mip-maps it will be upscaled/padded at loading time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.Full">
      <summary>Full NPOT support.</summary>
    </member>
    <member name="F:UnityEngine.ObstacleAvoidanceType.NoObstacleAvoidance">
      <summary>Disable avoidance.</summary>
    </member>
    <member name="F:UnityEngine.ObstacleAvoidanceType.LowQualityObstacleAvoidance">
      <summary>Enable simple avoidance. Low performance impact.</summary>
    </member>
    <member name="F:UnityEngine.ObstacleAvoidanceType.MedQualityObstacleAvoidance">
      <summary>Medium avoidance. Medium performance impact.</summary>
    </member>
    <member name="F:UnityEngine.ObstacleAvoidanceType.GoodQualityObstacleAvoidance">
      <summary>Good avoidance. High performance impact.</summary>
    </member>
    <member name="F:UnityEngine.ObstacleAvoidanceType.HighQualityObstacleAvoidance">
      <summary>Enable highest precision. Highest performance impact.</summary>
    </member>
    <member name="F:UnityEngine.OffMeshLinkType.LinkTypeManual">
      <summary>Manually specified type of link.</summary>
    </member>
    <member name="F:UnityEngine.OffMeshLinkType.LinkTypeDropDown">
      <summary>Vertical drop.</summary>
    </member>
    <member name="F:UnityEngine.OffMeshLinkType.LinkTypeJumpAcross">
      <summary>Horizontal jump.</summary>
    </member>
    <member name="F:UnityEngine.ParticleRenderMode.Billboard">
      <summary>Render the particles as billboards facing the player. (Default)</summary>
    </member>
    <member name="F:UnityEngine.ParticleRenderMode.Stretch">
      <summary>Stretch particles in the direction of motion.</summary>
    </member>
    <member name="F:UnityEngine.ParticleRenderMode.SortedBillboard">
      <summary>
        <para>Sort the particles back-to-front and render as billboards.</para>
        <para>This looks better with blended particle shaders, but is slower because of the sorting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ParticleRenderMode.HorizontalBillboard">
      <summary>Render the particles as billboards always facing up along the y-Axis.</summary>
    </member>
    <member name="F:UnityEngine.ParticleRenderMode.VerticalBillboard">
      <summary>Render the particles as billboards always facing the player, but not pitching along the x-Axis.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemRenderMode.Billboard">
      <summary>Render particles as billboards facing the player. (Default)</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemRenderMode.Stretch">
      <summary>Stretch particles in the direction of motion.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemRenderMode.HorizontalBillboard">
      <summary>Render particles as billboards always facing up along the y-Axis.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemRenderMode.VerticalBillboard">
      <summary>Render particles as billboards always facing the player, but not pitching along the x-Axis.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemRenderMode.Mesh">
      <summary>Render particles as meshes.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemSimulationSpace.Local">
      <summary>Simulate particles in local space.</summary>
    </member>
    <member name="F:UnityEngine.ParticleSystemSimulationSpace.World">
      <summary>Simulate particles in world space.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Average">
      <summary>Averages the friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Minimum">
      <summary>Uses the smaller friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Multiply">
      <summary>Multiplies the friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Maximum">
      <summary>Uses the larger friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PlayMode.StopSameLayer">
      <summary>Will stop all animations that were started in the same layer. This is the default when playing animations.</summary>
    </member>
    <member name="F:UnityEngine.PlayMode.StopAll">
      <summary>Will stop all animations that were started with this component before playing.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Sphere">
      <summary>A sphere primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Capsule">
      <summary>A capsule primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Cylinder">
      <summary>A cylinder primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Cube">
      <summary>A cube primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Plane">
      <summary>A plane primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Quad">
      <summary>A Quad primitive.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralCacheSize.Tiny">
      <summary>A limit of 128MB for the cache or the working memory.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralCacheSize.Medium">
      <summary>A limit of 256MB for the cache or the working memory.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralCacheSize.Heavy">
      <summary>A limit of 512MB for the cache or the working memory.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralCacheSize.NoLimit">
      <summary>No limit for the cache or the working memory.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralCacheSize.None">
      <summary>A limit of 1B (one byte) for the cache or the working memory.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.DoNothing">
      <summary>Do not generate the textures. RebuildTextures() or RebuildTexturesImmediately() must be called to generate the textures.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.Generate">
      <summary>Generate the textures when loading to favor application's size (default on supported platform).</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.BakeAndKeep">
      <summary>Bake the textures to speed up loading and keep the ProceduralMaterial data so that it can still be tweaked and regenerated later on.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.BakeAndDiscard">
      <summary>Bake the textures to speed up loading and discard the ProceduralMaterial data (default on unsupported platform).</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.Cache">
      <summary>Generate the textures when loading and cache them to disk/flash to speed up subsequent game/application startups.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralLoadingBehavior.DoNothingAndCache">
      <summary>Do not generate the textures. RebuildTextures() or RebuildTexturesImmediately() must be called to generate the textures. After the textures have been generrated for the first time, they are cached to disk/flash to speed up subsequent game/application startups.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Unknown">
      <summary>
        <para>Undefined type.</para>
        <para>This is used to leave the alpha channel of a ProceduralOutput unchanged.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Diffuse">
      <summary>
        <para>Diffuse map.</para>
        <para>Color texture that defines the overall color of the surface in classic workflows or in 'Specular' PBR workflows ("Albedo" slot). The 'baseColor' output is used instead in 'Metallic' PBR workflows.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Normal">
      <summary>
        <para>Normal (Bump) map.</para>
        <para>Color texture that defines the relief of the surface for normal mapping.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Height">
      <summary>
        <para>Height map.</para>
        <para>Grayscale texture that defines the relief of the surface for bump, parallax or relief mapping. Outputs of this type can also be used as displacement textures.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Emissive">
      <summary>
        <para>Emissive map.</para>
        <para>Color or grayscale texture that defines the self-illuminated areas of the surface.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Specular">
      <summary>
        <para>Specular map.</para>
        <para>Color texture that defines the intensity and color of light reflections for classic or 'Specular' PBR workflows.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Opacity">
      <summary>
        <para>Opacity (Tranparency) map.</para>
        <para>Grayscale texture that defines the opacity of the surface. White areas are opaque, black areas are transparent.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Smoothness">
      <summary>
        <para>Smoothness map (formerly referred to as Glossiness).</para>
        <para>Grayscale texture which defines how rough the surface is in 'Metallic' PBR workflows, or the size of specular highlights (glossiness) in non-PBR workflows. This is the inverse of the Roughness map. White areas are smoother and will produce sharp reflections, black areas are rougher and will produce blurry reflections.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.AmbientOcclusion">
      <summary>
        <para>Ambient occlusion map.</para>
        <para>Grayscale texture that defines the amount of self-shadowing of the surface. White areas are non-occluded and will appear bright, black areas are occluded.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.DetailMask">
      <summary>
        <para>Detail mask map.</para>
        <para>Grayscale texture that defines the masked areas of the surface. This can be plugged in the “Detail Mask” slot of the Standard shaders for example.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Metallic">
      <summary>
        <para>Metalness map.</para>
        <para>Grayscale texture used in 'Metallic' PBR workflows to define metallic areas. White areas are metallic, black areas are non-metallic.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralOutputType.Roughness">
      <summary>
        <para>Roughness map.</para>
        <para>Grayscale texture which defines how rough the surface is in 'Metallic' PBR workflows. This is the inverse of the Smoothness map. White areas are rougher and will produce blurry reflections, black areas are smoother and will produce sharp reflections.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ProceduralProcessorUsage.Unsupported">
      <summary>Exact control of processor usage is not available.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralProcessorUsage.One">
      <summary>A single physical processor core is used for ProceduralMaterial generation.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralProcessorUsage.Half">
      <summary>Half of all physical processor cores are used for ProceduralMaterial generation.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralProcessorUsage.All">
      <summary>All physical processor cores are used for ProceduralMaterial generation.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Boolean">
      <summary>Procedural boolean property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralBoolean(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Float">
      <summary>Procedural float property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralFloat(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Vector2">
      <summary>Procedural Vector2 property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralVector(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Vector3">
      <summary>Procedural Vector3 property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralVector(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Vector4">
      <summary>Procedural Vector4 property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralVector(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Color3">
      <summary>Procedural Color property without alpha. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralColor(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Color4">
      <summary>Procedural Color property with alpha. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralColor(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Enum">
      <summary>Procedural Enum property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralEnum(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.ProceduralPropertyType.Texture">
      <summary>Procedural Texture property. Use with <see cref="M:UnityEngine.ProceduralMaterial.GetProceduralTexture(System.String)" />.</summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.UseGlobal">
      <summary>Queries use the global <see cref="P:UnityEngine.Physics.queriesHitTriggers" /> setting.</summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.Ignore">
      <summary>Queries never report Trigger hits.</summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.Collide">
      <summary>Queries always report Trigger hits.</summary>
    </member>
    <member name="F:UnityEngine.QueueMode.CompleteOthers">
      <summary>Will start playing after all other animations have stopped playing.</summary>
    </member>
    <member name="F:UnityEngine.QueueMode.PlayNow">
      <summary>Starts playing immediately. This can be used if you just want to quickly create a duplicate animation.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Axis.Horizontal">
      <summary>Horizontal.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Axis.Vertical">
      <summary>Vertical.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Left">
      <summary>The left edge.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Right">
      <summary>The right edge.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Top">
      <summary>The top edge.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Bottom">
      <summary>The bottom edge.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.UsePlayerSettings">
      <summary>Use Player Settings.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.VertexLit">
      <summary>Vertex Lit.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.Forward">
      <summary>Forward Rendering.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.DeferredLighting">
      <summary>
        <para>Deferred Lighting (Legacy).</para>
        <para>This is a deferred lighting path (also known as "light pre-pass"), that renders scene information into a very small G-Buffer twice, computing lighting in between.It does not require a GPU with multiple render targets (MRT) support, but is a lot less flexible than <see cref="F:UnityEngine.RenderingPath.DeferredShading" /> is.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.DeferredShading">
      <summary>
        <para>Deferred Shading.</para>
        <para>This is a standard deferred shading path, that renders scene information into G-Buffers using multiple render targets, and computes lighting afterwards.Due to use of multiple render targets, it requires GPU with MRT support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderMode.ScreenSpaceOverlay">
      <summary>Render at the end of the scene using a 2D Canvas.</summary>
    </member>
    <member name="F:UnityEngine.RenderMode.ScreenSpaceCamera">
      <summary>Render using the <see cref="T:UnityEngine.Camera" /> configured on the Canvas.</summary>
    </member>
    <member name="F:UnityEngine.RenderMode.WorldSpace">
      <summary>Render using any <see cref="T:UnityEngine.Camera" /> in the scene that can render the layer.</summary>
    </member>
    <member name="F:UnityEngine.RenderMode.">
      <summary>Render at the end of the scene using a 2D Canvas.</summary>
    </member>
    <member name="F:UnityEngine.RenderMode.">
      <summary>Render using the <see cref="T:UnityEngine.Camera" /> configured on the Canvas.</summary>
    </member>
    <member name="F:UnityEngine.RenderMode.">
      <summary>Render using any <see cref="T:UnityEngine.Camera" /> in the scene that can render the layer.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB32">
      <summary>Color render texture format, 8 bits per channel.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Depth">
      <summary>
        <para>A depth render texture format.</para>
        <para>Depth format is used to render high precision "depth" value into a render texture. Which format is actually used depends on the platform. On OpenGL it is the native "depth component" format (usually 24 or 16 bits), on Direct3D9 it is the 32 bit floating point ("R32F") format. When writing shaders that use or render into a depth texture, care must be taken to ensure that they work both on OpenGL and on Direct3D, see depth textures documentation.Note that not all graphics cards support depth textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBHalf">
      <summary>
        <para>Color render texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Shadowmap">
      <summary>
        <para>A native shadowmap render texture format.</para>
        <para>This represents a format for which the GPU can automatically do shadowmap comparisons for. Unity uses this format internally for shadows, when supported. Note that some platforms or GPUs do not support Shadowmap format, in which case shadows end up using <see cref="F:UnityEngine.RenderTextureFormat.Depth" /> format.Note that not all graphics cards support shadowmaps. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, SystemInfo.SupportsRenderTextureFormat.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGB565">
      <summary>
        <para>Color render texture format.</para>
        <para>5 bits for Red channel, 6 bits for Green channel, 5 bits for Blue channelNote that not all graphics cards support 16 bit textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB4444">
      <summary>
        <para>Color render texture format, 4 bit per channel.</para>
        <para>Note that not all graphics cards support 16 bit textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB1555">
      <summary>
        <para>Color render texture format, 1 bit for Alpha channel, 5 bits for Red, Green and Blue channels.</para>
        <para>Note that not all graphics cards support 16 bit textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Default">
      <summary>
        <para>Default color render texture format: will be chosen accordingly to Frame Buffer format and Platform.</para>
        <para>Typically this is <see cref="F:UnityEngine.RenderTextureFormat.ARGB32" /> format.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB2101010">
      <summary>
        <para>Color render texture format. 10 bits for colors, 2 bits for alpha.</para>
        <para>Note that not all graphics cards support this format. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.DefaultHDR">
      <summary>
        <para>Default HDR color render texture format: will be chosen accordingly to Frame Buffer format and Platform.</para>
        <para>Typically this is <see cref="F:UnityEngine.RenderTextureFormat.ARGBHalf" /> format.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBFloat">
      <summary>
        <para>Color render texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGFloat">
      <summary>
        <para>Two color (RG) render texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGHalf">
      <summary>
        <para>Two color (RG) render texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RFloat">
      <summary>
        <para>Scalar (R) render texture format, 32 bit floating point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RHalf">
      <summary>
        <para>Scalar (R) render texture format, 16 bit floating point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.R8">
      <summary>
        <para>Scalar (R) render texture format, 8 bit fixed point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBInt">
      <summary>
        <para>Four channel (ARGB) render texture format, 32 bit signed integer per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGInt">
      <summary>
        <para>Two channel (RG) render texture format, 32 bit signed integer per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RInt">
      <summary>
        <para>Scalar (R) render texture format, 32 bit signed integer.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" /> to check for support.See Also: <see cref="P:UnityEngine.RenderTexture.format" />, <see cref="T:UnityEngine.RenderTexture" /> class, <see cref="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.Default">
      <summary>The correct color space for the current position in the rendering pipeline.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.Linear">
      <summary>No sRGB reads or writes to this render texture.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.sRGB">
      <summary>sRGB reads and writes to this render texture.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.None">
      <summary>No constraints.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionX">
      <summary>Freeze motion along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionY">
      <summary>Freeze motion along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionZ">
      <summary>Freeze motion along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationX">
      <summary>Freeze rotation along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationY">
      <summary>Freeze rotation along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationZ">
      <summary>Freeze rotation along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePosition">
      <summary>Freeze motion along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotation">
      <summary>Freeze rotation along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeAll">
      <summary>Freeze rotation and motion along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.None">
      <summary>No constraints.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePositionX">
      <summary>Freeze motion along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePositionY">
      <summary>Freeze motion along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezeRotation">
      <summary>Freeze rotation along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePosition">
      <summary>Freeze motion along the X-axis and Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezeAll">
      <summary>Freeze rotation and motion along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.None">
      <summary>No Interpolation.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.Interpolate">
      <summary>Interpolation will always lag a little bit behind but can be smoother than extrapolation.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.Extrapolate">
      <summary>
        <para>Extrapolation will predict the position of the rigidbody based on the current velocity.</para>
        <para>If you have fast moving objects this can lead to rigidbodies passing through colliders for one frame and then snapping back.See Also: <see cref="P:UnityEngine.Rigidbody.interpolation" /> variable.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.None">
      <summary>Do not apply any smoothing to the object's movement.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.Interpolate">
      <summary>Smooth movement based on the object's positions in previous frames.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.Extrapolate">
      <summary>Smooth an object's movement based on an estimate of its position in the next frame.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.NeverSleep">
      <summary>Rigidbody2D never automatically sleeps.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.StartAwake">
      <summary>Rigidbody2D is initially awake.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.StartAsleep">
      <summary>Rigidbody2D is initially asleep.</summary>
    </member>
    <member name="F:UnityEngine.RotationDriveMode.XYAndZ">
      <summary>Use XY &amp; Z Drive.</summary>
    </member>
    <member name="F:UnityEngine.RotationDriveMode.Slerp">
      <summary>Use Slerp drive.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.Server">
      <summary>Sends to the server only.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.Others">
      <summary>Sends to everyone except the sender.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.OthersBuffered">
      <summary>Sends to everyone except the sender and adds to the buffer.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.All">
      <summary>Sends to everyone.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.AllBuffered">
      <summary>Sends to everyone and adds to the buffer.</summary>
    </member>
    <member name="F:UnityEngine.RuntimeInitializeLoadType.AfterSceneLoad">
      <summary>After scene is loaded.</summary>
    </member>
    <member name="F:UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad">
      <summary>Before scene is loaded.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXEditor">
      <summary>In the Unity editor on Mac OS X.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXPlayer">
      <summary>In the player on Mac OS X.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WindowsPlayer">
      <summary>In the player on Windows.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXWebPlayer">
      <summary>In the web player on Mac OS X.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXDashboardPlayer">
      <summary>In the Dashboard widget on Mac OS X.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WindowsWebPlayer">
      <summary>In the web player on Windows.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WindowsEditor">
      <summary>In the Unity editor on Windows.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.IPhonePlayer">
      <summary>In the player on the iPhone.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.XBOX360">
      <summary>In the player on the XBOX360.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.PS3">
      <summary>In the player on the Play Station 3.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.Android">
      <summary>In the player on Android devices.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.LinuxPlayer">
      <summary>In the player on Linux.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WebGLPlayer">
      <summary>In the player on WebGL?</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerX86">
      <summary>In the player on Windows Store Apps when CPU architecture is X86.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerX64">
      <summary>In the player on Windows Store Apps when CPU architecture is X64.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerARM">
      <summary>In the player on Windows Store Apps when CPU architecture is ARM.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WP8Player">
      <summary>In the player on Windows Phone 8 device.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.TizenPlayer">
      <summary>In the player on Tizen.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.PSP2">
      <summary>In the player on the PS Vita.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.PS4">
      <summary>In the player on the Playstation 4.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.XboxOne">
      <summary>In the player on Xbox One.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.SamsungTVPlayer">
      <summary>In the player on Samsung Smart TV.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WiiU">
      <summary>In the player on Wii U.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.GamePadMode.Default">
      <summary>
        <para>Joystick style input.</para>
        <para>Touchpad works like an analog joystick producing values from -1 to 1 on two axes. Not supported on 2015 model TVs.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.GamePadMode.Mouse">
      <summary>
        <para>Mouse style input.</para>
        <para>Gamepad's horizontal and vertical axes control a mouse cursor.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.GestureMode.Off">
      <summary>No gesture input from the camera.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.GestureMode.Mouse">
      <summary>Hands control the mouse pointer.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.GestureMode.Joystick">
      <summary>Two hands control two joystick axes.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.TouchPadMode.Dpad">
      <summary>Remote dependent. On 2013 TVs dpad directions are determined by swiping in the correlating direction. On 2014 and 2015 TVs the remote has dpad buttons.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.TouchPadMode.Joystick">
      <summary>Touchpad works like an analog joystick. Not supported on the 2015 TV as there is no touchpad.</summary>
    </member>
    <member name="F:UnityEngine.SamsungTV.TouchPadMode.Mouse">
      <summary>Touchpad controls a remote curosr like a laptop's touchpad. This can be replaced by airmouse functionality which is available on 2014 and 2015 TVs.</summary>
    </member>
    <member name="F:UnityEngine.ScaleMode.StretchToFill">
      <summary>Stretches the texture to fill the complete rectangle passed in to GUI.DrawTexture.</summary>
    </member>
    <member name="F:UnityEngine.ScaleMode.ScaleAndCrop">
      <summary>Scales the texture, maintaining aspect ratio, so it completely covers the <c>position</c> rectangle passed to GUI.DrawTexture. If the texture is being draw to a rectangle with a different aspect ratio than the original, the image is cropped.</summary>
    </member>
    <member name="F:UnityEngine.ScaleMode.ScaleToFit">
      <summary>Scales the texture, maintaining aspect ratio, so it completely fits withing the <c>position</c> rectangle passed to GUI.DrawTexture.</summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.Portrait">
      <summary>Portrait orientation.</summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.PortraitUpsideDown">
      <summary>
        <para>Portrait orientation, upside down.</para>
        <para>Available on iOS and on Android 2.3+. On older Androids falls back to Portrait.See Also: Screen.orientation.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.LandscapeLeft">
      <summary>Landscape orientation, counter-clockwise from the portrait orientation.</summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.LandscapeRight">
      <summary>
        <para>Landscape orientation, clockwise from the portrait orientation.</para>
        <para>Available on iOS and on Android 2.3+. On older Androids falls back to LandscapeLeft.See Also: Screen.orientation.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.AutoRotation">
      <summary>
        <para>Auto-rotates the screen as necessary toward any of the enabled orientations.</para>
        <para>When this option is assigned to the <see cref="P:UnityEngine.Screen.orientation" /> property, the screen will auto-rotate so that the bottom of the screen image points downwards. The orientations that can be used are set by the <see cref="P:UnityEngine.Screen.autorotateToLandscapeLeft" />, <see cref="P:UnityEngine.Screen.autorotateToLandscapeRight" />, <see cref="P:UnityEngine.Screen.autorotateToPortrait" /> and Screen::autorotateToPortraitUpsideDown properties. For example, if <see cref="P:UnityEngine.Screen.autorotateToPortrait" /> and Screen::autorotateToPortraitUpsideDown are both true but the others are false then the auto-rotation will never choose either of the landscape options even when the device is held with the long side of the screen pointing downwards.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SendMessageOptions.RequireReceiver">
      <summary>
        <para>A receiver is required for SendMessage.</para>
        <para>If no receiver is found, an error is printed to the console. (This is the default value.) See Also: <see cref="M:UnityEngine.GameObject.SendMessage(System.String,System.Object,UnityEngine.SendMessageOptions)" /></para>
      </summary>
    </member>
    <member name="F:UnityEngine.SendMessageOptions.DontRequireReceiver">
      <summary>
        <para>No receiver is required for SendMessage.</para>
        <para>If no Component (script) on the GameObject implements the method no error will be generated.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ShadowProjection.CloseFit">
      <summary>Close fit shadow maps with linear fadeout.</summary>
    </member>
    <member name="F:UnityEngine.ShadowProjection.StableFit">
      <summary>Stable shadow maps with spherical fadeout.</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Auto">
      <summary>Chooses the number of bones from the number current <see cref="T:UnityEngine.QualitySettings" />. (Default)</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone1">
      <summary>Use only 1 bone to deform a single vertex. (The most important bone will be used).</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone2">
      <summary>Use 2 bones to deform a single vertex. (The most important bones will be used).</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone4">
      <summary>Use 4 bones to deform a single vertex.</summary>
    </member>
    <member name="F:UnityEngine.Space.World">
      <summary>Applies transformation relative to the world coordinate system.</summary>
    </member>
    <member name="F:UnityEngine.Space.Self">
      <summary>Applies transformation relative to the local coordinate system.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.Center">
      <summary>Pivot is at the center of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopLeft">
      <summary>Pivot is at the top left corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopCenter">
      <summary>Pivot is at the center of the top edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopRight">
      <summary>Pivot is at the top right corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.LeftCenter">
      <summary>Pivot is at the center of the left edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.RightCenter">
      <summary>Pivot is at the center of the right edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomLeft">
      <summary>Pivot is at the bottom left corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomCenter">
      <summary>Pivot is at the center of the bottom edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomRight">
      <summary>Pivot is at the bottom right corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.Custom">
      <summary>Pivot is at a custom position within the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteMeshType.FullRect">
      <summary>Rectangle mesh equal to the user specified sprite size.</summary>
    </member>
    <member name="F:UnityEngine.SpriteMeshType.Tight">
      <summary>Tight mesh based on pixel alpha values. As many excess pixels are cropped as possible.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingMode.Tight">
      <summary>Tight mesh based packing.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingMode.Rectangle">
      <summary>Alpha-cropped ractangle packing.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingRotation.None">
      <summary>No rotation.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingRotation.Any">
      <summary>Any rotation.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.None">
      <summary>No stack trace will be outputed to log.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.ScriptOnly">
      <summary>Only managed stack trace will be outputed.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.Full">
      <summary>
        <para>Native and managed stack trace will be logged.</para>
        <para>Note: Printing a full stack trace can be a costly operation and might impact performance.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Afrikaans">
      <summary>Afrikaans.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Arabic">
      <summary>Arabic.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Basque">
      <summary>Basque.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Belarusian">
      <summary>Belarusian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Bulgarian">
      <summary>Bulgarian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Catalan">
      <summary>Catalan.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Chinese">
      <summary>Chinese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Czech">
      <summary>Czech.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Danish">
      <summary>Danish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Dutch">
      <summary>Dutch.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.English">
      <summary>English.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Estonian">
      <summary>Estonian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Faroese">
      <summary>Faroese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Finnish">
      <summary>Finnish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.French">
      <summary>French.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.German">
      <summary>German.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Greek">
      <summary>Greek.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Hebrew">
      <summary>Hebrew.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Icelandic">
      <summary>Icelandic.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Indonesian">
      <summary>Indonesian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Italian">
      <summary>Italian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Japanese">
      <summary>Japanese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Korean">
      <summary>Korean.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Latvian">
      <summary>Latvian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Lithuanian">
      <summary>Lithuanian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Norwegian">
      <summary>Norwegian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Polish">
      <summary>Polish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Portuguese">
      <summary>Portuguese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Romanian">
      <summary>Romanian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Russian">
      <summary>Russian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.SerboCroatian">
      <summary>Serbo-Croatian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Slovak">
      <summary>Slovak.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Slovenian">
      <summary>Slovenian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Spanish">
      <summary>Spanish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Swedish">
      <summary>Swedish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Thai">
      <summary>Thai.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Turkish">
      <summary>Turkish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Ukrainian">
      <summary>Ukrainian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Vietnamese">
      <summary>Vietnamese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.ChineseSimplified">
      <summary>ChineseSimplified.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.ChineseTraditional">
      <summary>ChineseTraditional.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Unknown">
      <summary>Unknown.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Hungarian">
      <summary>Hungarian.</summary>
    </member>
    <member name="F:UnityEngine.Terrain.MaterialType.BuiltInStandard">
      <summary>
        <para>A built-in material that uses the standard physically-based lighting model. Inputs supported: smoothness, metallic / specular, normal.</para>
        <para>The actual built-in shader used is Nature/Terrain/Standard.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Terrain.MaterialType.BuiltInLegacyDiffuse">
      <summary>
        <para>A built-in material that uses the legacy Lambert (diffuse) lighting model and has optional normal map support.</para>
        <para>The actual built-in shader used is Nature/Terrain/Diffuse.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Terrain.MaterialType.BuiltInLegacySpecular">
      <summary>
        <para>A built-in material that uses the legacy BlinnPhong (specular) lighting model and has optional normal map support.</para>
        <para>The actual built-in shader used is Nature/Terrain/Specular.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Terrain.MaterialType.Custom">
      <summary>Use a custom material given by <see cref="P:UnityEngine.Terrain.materialTemplate" />.</summary>
    </member>
    <member name="F:UnityEngine.TerrainRenderFlags.heightmap">
      <summary>Render heightmap.</summary>
    </member>
    <member name="F:UnityEngine.TerrainRenderFlags.trees">
      <summary>Render trees.</summary>
    </member>
    <member name="F:UnityEngine.TerrainRenderFlags.details">
      <summary>Render terrain details.</summary>
    </member>
    <member name="F:UnityEngine.TerrainRenderFlags.all">
      <summary>Render all options.</summary>
    </member>
    <member name="F:UnityEngine.TextAlignment.Left">
      <summary>Text lines are aligned on the left side.</summary>
    </member>
    <member name="F:UnityEngine.TextAlignment.Center">
      <summary>Text lines are centered.</summary>
    </member>
    <member name="F:UnityEngine.TextAlignment.Right">
      <summary>Text lines are aligned on the right side.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.UpperLeft">
      <summary>Text is anchored in upper left corner.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.UpperCenter">
      <summary>Text is anchored in upper side, centered horizontally.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.UpperRight">
      <summary>Text is anchored in upper right corner.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.MiddleLeft">
      <summary>Text is anchored in left side, centered vertically.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.MiddleCenter">
      <summary>Text is centered both horizontally and vertically.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.MiddleRight">
      <summary>Text is anchored in right side, centered vertically.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.LowerLeft">
      <summary>Text is anchored in lower left corner.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.LowerCenter">
      <summary>Text is anchored in lower side, centered horizontally.</summary>
    </member>
    <member name="F:UnityEngine.TextAnchor.LowerRight">
      <summary>Text is anchored in lower right corner.</summary>
    </member>
    <member name="F:UnityEngine.TextClipping.Overflow">
      <summary>Text flows freely outside the element.</summary>
    </member>
    <member name="F:UnityEngine.TextClipping.Clip">
      <summary>Text gets clipped to be inside the element.</summary>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Fast">
      <summary>Fast compression.</summary>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Normal">
      <summary>Normal compression (default).</summary>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Best">
      <summary>Best compression.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.Alpha8">
      <summary>Alpha-only texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ARGB4444">
      <summary>A 16 bits/pixel texture format. Texture stores color with an alpha channel.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGB24">
      <summary>A color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBA32">
      <summary>Color with alpha texture format, 8-bits per channel.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ARGB32">
      <summary>Color with an alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGB565">
      <summary>A 16 bit color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.R16">
      <summary>
        <para>A 16 bit color texture format that only has a red channel.</para>
        <para>The value of the red channel will be in the 0..1 range. Currently, this texture format is only useful for native code plugins as there is no support for texture importing or pixel access for this format. R16 is implemented for Direct3D 9, Direct3D 11, and Xbox One.Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.See Also: <see cref="P:UnityEngine.Texture2D.format" />, texture assets.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT1">
      <summary>Compressed color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT5">
      <summary>Compressed color with alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBA4444">
      <summary>Color and alpha texture format, 4 bit per channel.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.BGRA32">
      <summary>Format returned by iPhone camera.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RHalf">
      <summary>
        <para>Scalar (R) texture format, 16 bit floating point.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGHalf">
      <summary>
        <para>Two color (RG) texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBAHalf">
      <summary>
        <para>RGB color and alpha texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RFloat">
      <summary>
        <para>Scalar (R) texture format, 32 bit floating point.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGFloat">
      <summary>
        <para>Two color (RG) texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBAFloat">
      <summary>
        <para>RGB color and alpha etxture format, 32-bit floats per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)" /> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.YUY2">
      <summary>A format that uses the YUV color space and is often used for video encoding. Currently, this texture format is only useful for native code plugins as there is no support for texture importing or pixel access for this format. YUY2 is implemented for Direct3D 9, Direct3D 11, and Xbox One.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT1Crunched">
      <summary>Compressed color texture format with crunch compression for small storage sizes.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT5Crunched">
      <summary>Compressed color with alpha channel texture format with crunch compression for small storage sizes.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGB2">
      <summary>PowerVR (iOS) 2 bits/pixel compressed color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGBA2">
      <summary>PowerVR (iOS) 2 bits/pixel compressed with alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGB4">
      <summary>PowerVR (iOS) 4 bits/pixel compressed color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGBA4">
      <summary>PowerVR (iOS) 4 bits/pixel compressed with alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGB4">
      <summary>ETC (GLES2.0) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ATC_RGB4">
      <summary>ATC (ATITC) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ATC_RGBA8">
      <summary>ATC (ATITC) 8 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_R">
      <summary>ETC2 / EAC (GL ES 3.0) 4 bits/pixel compressed unsigned single-channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_R_SIGNED">
      <summary>ETC2 / EAC (GL ES 3.0) 4 bits/pixel compressed signed single-channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_RG">
      <summary>ETC2 / EAC (GL ES 3.0) 8 bits/pixel compressed unsigned dual-channel (RG) texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_RG_SIGNED">
      <summary>ETC2 / EAC (GL ES 3.0) 8 bits/pixel compressed signed dual-channel (RG) texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGB">
      <summary>ETC2 (GL ES 3.0) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGBA1">
      <summary>ETC2 (GL ES 3.0) 4 bits/pixel RGB+1-bit alpha texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGBA8">
      <summary>ETC2 (GL ES 3.0) 8 bits/pixel compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_4x4">
      <summary>ASTC (4x4 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_5x5">
      <summary>ASTC (5x5 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_6x6">
      <summary>ASTC (6x6 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_8x8">
      <summary>ASTC (8x8 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_10x10">
      <summary>ASTC (10x10 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_12x12">
      <summary>ASTC (12x12 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_4x4">
      <summary>ASTC (4x4 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_5x5">
      <summary>ASTC (5x5 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_6x6">
      <summary>ASTC (6x6 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_8x8">
      <summary>ASTC (8x8 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_10x10">
      <summary>ASTC (10x10 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_12x12">
      <summary>ASTC (12x12 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGB4_3DS">
      <summary>ETC (Nintendo 3DS) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGBA8_3DS">
      <summary>ETC (Nintendo 3DS) 4 bits/pixel RGB + 4 bits/pixel Alpha compressed texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.Repeat">
      <summary>
        <para>Tiles the texture, creating a repeating pattern.</para>
        <para>When UVs are outside of the 0...1 range, the integer part will be ignored, thus creating a repeating pattern.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.Clamp">
      <summary>
        <para>Clamps the texture to the last pixel at the border.</para>
        <para>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don't want the texture to tile. UV coordinates will be clamped to the range 0...1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.Low">
      <summary>Lowest thread priority.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.BelowNormal">
      <summary>Below normal thread priority.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.Normal">
      <summary>Normal thread priority.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.High">
      <summary>Highest thread priority.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Began">
      <summary>A finger touched the screen.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Moved">
      <summary>A finger moved on the screen.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Stationary">
      <summary>A finger is touching the screen but hasn't moved.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Ended">
      <summary>A finger was lifted from the screen. This is the final phase of a touch.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Canceled">
      <summary>
        <para>The system cancelled tracking for the touch.</para>
        <para>This might happen if, for example, the user puts the device to her face or simultaneously applies more touches than the system can track (the exact number varies with different platforms). This is the final phase of a touch.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.Default">
      <summary>Default keyboard for the current input method.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.ASCIICapable">
      <summary>Keyboard displays standard ASCII characters.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NumbersAndPunctuation">
      <summary>Keyboard with numbers and punctuation.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.URL">
      <summary>
        <para>Keyboard optimized for URL entry.</para>
        <para>It features ".", "/", and ".com" prominently.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NumberPad">
      <summary>
        <para>Numeric keypad designed for PIN entry.</para>
        <para>It features the numbers 0 through 9 prominently.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.PhonePad">
      <summary>
        <para>Keypad designed for entering telephone numbers.</para>
        <para>It features the numbers 0 through 9 and the "*" and "#" characters prominently.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NamePhonePad">
      <summary>Keypad designed for entering a person's name or phone number.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.EmailAddress">
      <summary>
        <para>Keyboard optimized for specifying email addresses.</para>
        <para>It features the "@", "." and space characters prominently.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NintendoNetworkAccount">
      <summary>Keyboard designed for Nintendo Network Accounts (available on Wii U only).</summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Default">
      <summary>Default transparency sorting mode.</summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Perspective">
      <summary>
        <para>Perspective transparency sorting mode.</para>
        <para>Transparent objects will be sorted based on distance from camera position to the object center.See Also: <see cref="P:UnityEngine.Camera.transparencySortMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Orthographic">
      <summary>
        <para>Orthographic transparency sorting mode.</para>
        <para>Transparent objects will be sorted based on distance along the camera's view.See Also: <see cref="P:UnityEngine.Camera.transparencySortMode" />.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.UserAuthorization.WebCam">
      <summary>Request permission to use any video input sources attached to the computer.</summary>
    </member>
    <member name="F:UnityEngine.UserAuthorization.Microphone">
      <summary>Request permission to use any audio input sources attached to the computer.</summary>
    </member>
    <member name="F:UnityEngine.VerticalWrapMode.Truncate">
      <summary>Text will be clipped when reaching the vertical boundary.</summary>
    </member>
    <member name="F:UnityEngine.VerticalWrapMode.Overflow">
      <summary>Text well continue to generate when reaching vertical boundary.</summary>
    </member>
    <member name="F:UnityEngine.WindZoneMode.Directional">
      <summary>Wind zone only has an effect inside the radius, and has a falloff from the center towards the edge.</summary>
    </member>
    <member name="F:UnityEngine.WindZoneMode.Spherical">
      <summary>Wind zone affects the entire scene in one direction.</summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Once">
      <summary>
        <para>When time reaches the end of the animation clip, the clip will automatically stop playing and time will be reset to beginning of the clip.</para>
        <para>Note that when playing backwards and when the time reaches the beginning the clip will automatically stop playing, but the time won't be reset to the end - it will be kept at the beginning.See Also: <see cref="P:UnityEngine.AnimationState.wrapMode" />, <see cref="P:UnityEngine.AnimationState.time" />, <see cref="P:UnityEngine.AnimationState.speed" /> properties.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Loop">
      <summary>
        <para>When time reaches the end of the animation clip, time will continue at the beginning.</para>
        <para>When playing backwards it will do the opposite - it will jump to the end of the clip and continue from there. The animation will never automatically stop playing.See Also: <see cref="P:UnityEngine.AnimationState.wrapMode" />, <see cref="P:UnityEngine.AnimationState.time" />, <see cref="P:UnityEngine.AnimationState.speed" /> properties.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.PingPong">
      <summary>
        <para>When time reaches the end of the animation clip, time will ping pong back between beginning and end.</para>
        <para>It has same behaviour when playing backwards - when time reaches the beginning of the animation clip, time will ping pong back between beginning and end. The animation will never automatically stop playing.See Also: <see cref="P:UnityEngine.AnimationState.wrapMode" />, <see cref="P:UnityEngine.AnimationState.time" />, <see cref="P:UnityEngine.AnimationState.speed" /> properties.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Default">
      <summary>
        <para>Reads the default repeat mode set higher up.</para>
        <para>If you haven't changed wrapMode on <see cref="T:UnityEngine.AnimationClip" /> or on <see cref="T:UnityEngine.Animation" />, then <see cref="F:UnityEngine.WrapMode.Default" /> resolves to <see cref="F:UnityEngine.WrapMode.Once" />.See Also: <see cref="T:UnityEngine.WrapMode" /> for me details.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.ClampForever">
      <summary>
        <para>Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.</para>
        <para>When playing backwards it will reach the first frame and will keep playing that. This is useful for additive animations, which should never be stopped when they reach the maximum.See Also: <see cref="P:UnityEngine.AnimationState.wrapMode" />, <see cref="P:UnityEngine.AnimationState.time" />, <see cref="P:UnityEngine.AnimationState.speed" /> properties.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AddComponentMenu.componentOrder">
      <summary>The order of the component in the component menu (lower is higher to the top).</summary>
    </member>
    <member name="M:UnityEngine.AddComponentMenu.#ctor(System.String)">
      <summary>
        <para>Add an item in the Component menu.</para>
        <para>The script will be placed in the component menu according to <c>menuName</c>. For example, if the <c>menuName</c> is "Rendering/DoSomething" the new menu will be called DoSomething and appear as a child of the <c>Rendering</c> group in the <c>Components</c> menu. If <c>menuName</c> is "" the component will be hidden from the menu. Lower order values place the new item higher to the top of the Component menu.</para>
      </summary>
      <param name="menuName">The path to the component.</param>
    </member>
    <member name="M:UnityEngine.AddComponentMenu.#ctor(System.String,System.Int32)">
      <summary>
        <para>Add an item in the Component menu.</para>
        <para>The script will be placed in the component menu according to <c>menuName</c>. For example, if the <c>menuName</c> is "Rendering/DoSomething" the new menu will be called DoSomething and appear as a child of the <c>Rendering</c> group in the <c>Components</c> menu. If <c>menuName</c> is "" the component will be hidden from the menu. Lower order values place the new item higher to the top of the Component menu.</para>
      </summary>
      <param name="menuName">The path to the component.</param>
      <param name="order">Where in the component menu to add the new item.</param>
    </member>
    <member name="M:UnityEngine.AssemblyIsEditorAssembly.#ctor">
      <summary>Constructor.</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.hdr">
      <summary>If set to true the Color is treated as a HDR color.</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.maxBrightness">
      <summary>
        <para>Maximum allowed HDR color component value when using the HDR Color Picker.</para>
        <para>In the HSV color model the brightness (V) is defined as the largest component of a color.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.maxExposureValue">
      <summary>
        <para>Maximum exposure value allowed in the HDR Color Picker.</para>
        <para>Used for tonemapping in the HDR Color Picker.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.minBrightness">
      <summary>Minimum allowed HDR color component value when using the Color Picker.</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.minExposureValue">
      <summary>
        <para>Minimum exposure value allowed in the HDR Color Picker.</para>
        <para>Used for tonemapping in the HDR Color Picker.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.showAlpha">
      <summary>If false then the alpha bar is hidden in the ColorField and the alpha value is not shown in the Color Picker.</summary>
    </member>
    <member name="M:UnityEngine.ColorUsageAttribute.#ctor(System.Boolean)">
      <summary>Attribute for Color fields. Used for configuring the GUI for the color.</summary>
      <param name="showAlpha">If false then the alpha channel info is hidden both in the ColorField and in the Color Picker.</param>
    </member>
    <member name="M:UnityEngine.ColorUsageAttribute.#ctor(System.Boolean,System.Boolean,System.Single,System.Single,System.Single,System.Single)">
      <summary>Attribute for Color fields. Used for configuring the GUI for the color.</summary>
      <param name="showAlpha">If false then the alpha channel info is hidden both in the ColorField and in the Color Picker.</param>
      <param name="hdr">Set to true if the color should be treated as a HDR color (default value: false).</param>
      <param name="minBrightness">Minimum allowed HDR color component value when using the HDR Color Picker (default value: 0).</param>
      <param name="maxBrightness">Maximum allowed HDR color component value when using the HDR Color Picker (default value: 8).</param>
      <param name="minExposureValue">Minimum exposure value allowed in the HDR Color Picker (default value: 1/8 = 0.125).</param>
      <param name="maxExposureValue">Maximum exposure value allowed in the HDR Color Picker (default value: 3).</param>
    </member>
    <member name="M:UnityEngine.ContextMenu.#ctor(System.String)">
      <summary>
        <para>Adds the function to the context menu of the component.</para>
        <para>In the inspector of the attached script. When the user selects the context menu, the function will be executed.This is most useful for automatically setting up scene data from the script. The function has to be non-static.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContextMenuItemAttribute.function">
      <summary>The name of the function that should be called.</summary>
    </member>
    <member name="F:UnityEngine.ContextMenuItemAttribute.name">
      <summary>The name of the context menu item.</summary>
    </member>
    <member name="M:UnityEngine.ContextMenuItemAttribute.#ctor(System.String,System.String)">
      <summary>Use this attribute to add a context menu to a field that calls a named method.</summary>
      <param name="name">The name of the context menu item.</param>
      <param name="function">The name of the function that should be called.</param>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.fileName">
      <summary>
        <para>The default file name used by newly created instances of this type.</para>
        <para>Note that any custom file names must end in '.asset' to be correctly processed by Unity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.menuName">
      <summary>
        <para>The display name for this type shown in the Assets/Create menu.</para>
        <para>As with other menu item code, use a forward-slash ("/") path separator to group items into submenus. For example, specifying a MenuName of "Gameplay/Objective" will cause the menu item for a type to be 'Objective' inside a 'Gameplay' submenu of the Create submenu.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.order">
      <summary>The position of the menu item within the Assets/Create menu.</summary>
    </member>
    <member name="F:UnityEngine.HeaderAttribute.header">
      <summary>The header text.</summary>
    </member>
    <member name="M:UnityEngine.HeaderAttribute.#ctor(System.String)">
      <summary>Add a header above some fields in the Inspector.</summary>
      <param name="header">The header text.</param>
    </member>
    <member name="P:UnityEngine.HelpURLAttribute.URL">
      <summary>The documentation URL specified for this class.</summary>
    </member>
    <member name="M:UnityEngine.HelpURLAttribute.#ctor(System.String)">
      <summary>Initialize the HelpURL attribute with a documentation url.</summary>
      <param name="url">The custom documentation URL for this class.</param>
    </member>
    <member name="M:UnityEngine.MultilineAttribute.#ctor">
      <summary>Attribute used to make a string value be shown in a multiline textarea.</summary>
    </member>
    <member name="M:UnityEngine.MultilineAttribute.#ctor(System.Int32)">
      <summary>Attribute used to make a string value be shown in a multiline textarea.</summary>
      <param name="lines">How many lines of text to make room for. Default is 3.</param>
    </member>
    <member name="P:UnityEngine.PropertyAttribute.order">
      <summary>Optional field to specify the order that multiple DecorationDrawers should be drawn in.</summary>
    </member>
    <member name="M:UnityEngine.RangeAttribute.#ctor(System.Single,System.Single)">
      <summary>
        <para>Attribute used to make a float or int variable in a script be restricted to a specific range.</para>
        <para>When this attribute is used, the float or int will be shown as a slider in the Inspector instead of the default number field.</para>
      </summary>
      <param name="min">The minimum allowed value.</param>
      <param name="max">The maximum allowed value.</param>
    </member>
    <member name="M:UnityEngine.RequireComponent.#ctor(System.Type)">
      <summary>Require a single component.</summary>
    </member>
    <member name="M:UnityEngine.RequireComponent.#ctor(System.Type,System.Type)">
      <summary>Require a two components.</summary>
    </member>
    <member name="M:UnityEngine.RequireComponent.#ctor(System.Type,System.Type,System.Type)">
      <summary>Require three components.</summary>
    </member>
    <member name="P:UnityEngine.RuntimeInitializeOnLoadMethodAttribute.loadType">
      <summary>Set RuntimeInitializeOnLoadMethod type.</summary>
    </member>
    <member name="M:UnityEngine.RuntimeInitializeOnLoadMethodAttribute.#ctor">
      <summary>Allow an runtime class method to be initialized when Unity game loads runtime without action from the user.</summary>
      <seealso cref="T:UnityEngine.RuntimeInitializeOnLoadMethodAttribute" />
      <seealso cref="T:UnityEngine.RuntimeInitializeLoadType" />
    </member>
    <member name="M:UnityEngine.RuntimeInitializeOnLoadMethodAttribute.#ctor(UnityEngine.RuntimeInitializeLoadType)">
      <summary>Allow an runtime class method to be initialized when Unity game loads runtime without action from the user.</summary>
      <param name="loadType">RuntimeInitializeLoadType: Before or After scene is loaded.</param>
      <seealso cref="T:UnityEngine.RuntimeInitializeOnLoadMethodAttribute" />
      <seealso cref="T:UnityEngine.RuntimeInitializeLoadType" />
    </member>
    <member name="F:UnityEngine.SpaceAttribute.height">
      <summary>The spacing in pixels.</summary>
    </member>
    <member name="M:UnityEngine.SpaceAttribute.#ctor(System.Single)">
      <summary>Use this <see cref="T:UnityEditor.DecoratorDrawer" /> to add some spacing in the Inspector.</summary>
      <param name="height">The spacing in pixels.</param>
    </member>
    <member name="F:UnityEngine.TextAreaAttribute.maxLines">
      <summary>The maximum amount of lines the text area can show before it starts using a scrollbar.</summary>
    </member>
    <member name="F:UnityEngine.TextAreaAttribute.minLines">
      <summary>The minimum amount of lines the text area will use.</summary>
    </member>
    <member name="M:UnityEngine.TextAreaAttribute.#ctor">
      <summary>Attribute to make a string be edited with a height-flexible and scrollable text area.</summary>
    </member>
    <member name="M:UnityEngine.TextAreaAttribute.#ctor(System.Int32,System.Int32)">
      <summary>Attribute to make a string be edited with a height-flexible and scrollable text area.</summary>
      <param name="minLines">The minimum amount of lines the text area will use.</param>
      <param name="maxLines">The maximum amount of lines the text area can show before it starts using a scrollbar.</param>
    </member>
    <member name="F:UnityEngine.TooltipAttribute.tooltip">
      <summary>The tooltip text.</summary>
    </member>
    <member name="M:UnityEngine.TooltipAttribute.#ctor(System.String)">
      <summary>Specify a tooltip for a field.</summary>
      <param name="tooltip">The tooltip text.</param>
    </member>
    <member name="P:UnityEngine.UnityAPICompatibilityVersionAttribute.version">
      <summary>Version of Unity API.</summary>
    </member>
    <member name="M:UnityEngine.UnityAPICompatibilityVersionAttribute.#ctor(System.String)">
      <summary>Initializes a new instance of UnityAPICompatibilityVersionAttribute.</summary>
      <param name="version">Unity version that this assembly with compatible with.</param>
    </member>
    <member name="F:UnityEngine.Sprites.Packer.Execution.Normal">
      <summary>Normal execution. Will not trigger IPackerPolicy.OnGroupAtlases unless IPackerPolicy, IPackerPolicy version or TextureImporter settings have changed.</summary>
    </member>
    <member name="F:UnityEngine.Sprites.Packer.Execution.ForceRegroup">
      <summary>Will always trigger IPackerPolicy.OnGroupAtlases.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.None">
      <summary>The version control state is unknown.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.Local">
      <summary>The asset is not under version control.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.Synced">
      <summary>The asset is up to date.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.OutOfSync">
      <summary>A newer version of the asset is available on the version control server.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.Missing">
      <summary>
        <para>The asset exists in version control but is missing on the local machine.</para>
        <para>This can happen if you delete an assets from Finder/Explorer with out using the version control system.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.CheckedOutLocal">
      <summary>The asset has been checked out on the local machine.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.CheckedOutRemote">
      <summary>The asset has been checked out on a remote machine.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.DeletedLocal">
      <summary>The asset has been deleted locally.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.DeletedRemote">
      <summary>The asset has been deleted on a remote machine.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.AddedLocal">
      <summary>The was locally added to version control.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.AddedRemote">
      <summary>
        <para>Remotely this asset was added to version control.</para>
        <para>If the same assets exists on two machine but has only been added to version control on one of them, then it will appear as remotely added on the machine where it has not been added.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.Conflicted">
      <summary>There is a conflict with the asset that needs to be resolved.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.LockedLocal">
      <summary>The asset is locked by the local machine.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.LockedRemote">
      <summary>The asset is locked by a remote machine.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.Updating">
      <summary>The state of the asset is currently being queried from the version control server.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.ReadOnly">
      <summary>The asset is read only.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Asset.States.MetaFile">
      <summary>This instance of the class actaully refers to a .meta file.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Message.Severity.Verbose">
      <summary>
        <para>Verbose message.</para>
        <para>This includes intermediate query results and other info from the version control plugins.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Message.Severity.Info">
      <summary>
        <para>Informational message.</para>
        <para>This can include information such as who else is accessing an asset.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Message.Severity.Warning">
      <summary>Warning message.</summary>
    </member>
    <member name="F:UnityEngine.VersionControl.Message.Severity.Error">
      <summary>Error message.</summary>
    </member>
    <member name="F:UnityEngine.Lightmapping.GIWorkflowMode.Iterative">
      <summary>Always run lightmapping, changes to the scene are detected automatically.</summary>
    </member>
    <member name="F:UnityEngine.Lightmapping.GIWorkflowMode.OnDemand">
      <summary>Run lightmapping only when the user presses the bake button.</summary>
    </member>
    <member name="F:UnityEngine.Lightmapping.GIWorkflowMode.Legacy">
      <summary>Deprecated 4.x lightmapping support.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.HideInInspector">
      <summary>
        <para>Do not show the property in the inspector.</para>
        <para>
          <see cref="T:UnityEditor.MaterialEditor" /> will not show this property. This corresponds to the "[HideInInspector]" attribute in front of a property in the shader code.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.PerRendererData">
      <summary>Texture value for this property will be queried from renderer's <see cref="T:UnityEngine.MaterialPropertyBlock" />, instead of from the material. This corresponds to the "[PerRendererData]" attribute in front of a property in the shader code.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.NoScaleOffset">
      <summary>
        <para>Do not show UV scale/offset fields next to a texture.</para>
        <para>This is only relevant to texture shader properties. When this flag is set, the default material inspector will not display UV scale/offset controls for a texture. This corresponds to the "[NoScaleOffset]" attribute in front of a property in the shader code.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.Normal">
      <summary>
        <para>Signifies that values of this property contain Normal (normalized vector) data.</para>
        <para>When this flag is set, the default material inspector will display warning if incompatible data was assigned in the Material. For instance default material inspector will warn and suggest to fix the texture that is not marked as Normalmap. This corresponds to "[Normal]" attribute in front of property in the shader code.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropFlags.HDR">
      <summary>
        <para>Signifies that values of this property contain High Dynamic Range (HDR) data.</para>
        <para>When this flag is set, the default material inspector will display warning if incompatible data was assigned in the Material. For instance default material inspector will warn and suggest to fix the texture that contain alpha channel (unsupported in HDR textures). This corresponds to "[HDR]" attribute in front of property in the shader code.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropType.Color">
      <summary>Color property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropType.Vector">
      <summary>Vector property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropType.Float">
      <summary>Float property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropType.Range">
      <summary>Ranged float (with min/max values) property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.PropType.Texture">
      <summary>Texture property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.TexDim.None">
      <summary>No texture type is set.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.TexDim.Tex2D">
      <summary>
        <see cref="T:UnityEngine.Texture2D" /> property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.TexDim.Tex3D">
      <summary>
        <see cref="T:UnityEngine.Texture3D" /> property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.TexDim.Cube">
      <summary>
        <see cref="T:UnityEngine.Cubemap" /> property.</summary>
    </member>
    <member name="F:UnityEngine.MaterialProperty.TexDim.Any">
      <summary>Texture property accepts any texture type.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.LogoStyle.Nintendo">
      <summary>For Nintendo first-party titles.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.LogoStyle.Distributed">
      <summary>For titles for which Nintendo purchased the publishing license from the software manufacturer, etc.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.LogoStyle.iQue">
      <summary>For Chinese region titles.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.LogoStyle.Licensed">
      <summary>For all other titles.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize._128MB">
      <summary>128MB</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize._256MB">
      <summary>256MB</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize._512MB">
      <summary>512MB</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize._1GB">
      <summary>1GB</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.MediaSize._2GB">
      <summary>2GB</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.Japan">
      <summary>For the Japanese region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.America">
      <summary>For the American region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.Europe">
      <summary>For the European region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.China">
      <summary>For the Chinese region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.Korea">
      <summary>For the Korean region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.Taiwan">
      <summary>For the Taiwanese region.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.Region.All">
      <summary>For all regions.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.TargetPlatform.Nintendo3DS">
      <summary>Target the Nintendo 3DS platform.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.Nintendo3DS.TargetPlatform.NewNintendo3DS">
      <summary>Target the New Nintendo 3DS platform.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4AppCategory.Application">
      <summary>Application.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4EnterButtonAssignment.CircleButton">
      <summary>Circle button.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4EnterButtonAssignment.CrossButton">
      <summary>Cross button.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.None">
      <summary>No Remote play key assignment.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternA">
      <summary>Remote Play key layout configuration A.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternB">
      <summary>Remote Play key layout configuration B.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternC">
      <summary>Remote Play key layout configuration C.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternD">
      <summary>Remote Play key layout configuration D.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternE">
      <summary>Remote Play key layout configuration E.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternF">
      <summary>Remote Play key layout configuration F.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternG">
      <summary>Remote Play key layout configuration G.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PS4.PS4RemotePlayKeyAssignment.PatternH">
      <summary>Remote Play key layout configuration H.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaAppCategory.Application">
      <summary>An application package.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaAppCategory.ApplicationPatch">
      <summary>Application patch package.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaDRMType.PaidFor">
      <summary>Paid for content.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaDRMType.Free">
      <summary>Free content.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaEnterButtonAssignment.Default">
      <summary>Default.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaEnterButtonAssignment.CircleButton">
      <summary>Circle button.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaEnterButtonAssignment.CrossButton">
      <summary>Cross button.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaMemoryExpansionMode.None">
      <summary>Memory expansion disabled.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaMemoryExpansionMode.ExpandBy29MB">
      <summary>Enable 29MB memory expansion mode.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaMemoryExpansionMode.ExpandBy77MB">
      <summary>Enable 77MB memory expansion mode.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaPowerMode.ModeA">
      <summary>Mode A - default.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaPowerMode.ModeB">
      <summary>Mode B - GPU High - No WLAN or COM.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaPowerMode.ModeC">
      <summary>Mode C - GPU High - No Camera, OLED Low brightness.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaTvBootMode.Default">
      <summary>Default (Managed by System Software) (SCEE or SCEA).</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaTvBootMode.PSVitaBootablePSVitaTvBootable">
      <summary>PS Vita Bootable, PS Vita TV Bootable (SCEJ or SCE Asia).</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.PSVita.PSVitaTvBootMode.PSVitaBootablePSVitaTvNotBootable">
      <summary>PS Vita Bootable, PS Vita TV Not Bootable (SCEJ or SCE Asia).</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Games">
      <summary>The games category (default).</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Videos">
      <summary>The videos category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Sports">
      <summary>The sports category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Lifestyle">
      <summary>The lifestyle category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Information">
      <summary>The information category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Education">
      <summary>The education category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.SamsungTV.SamsungTVProductCategories.Kids">
      <summary>The kids category.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Location">
      <summary>The application can read the user's location information.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.DataSharing">
      <summary>The application can share data with other applications.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.NetworkGet">
      <summary>The application can retrieve network information such as the status of each network, its type, and detailed network profile information.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.WifiDirect">
      <summary>The application can enable and disable Wi-Fi Direct, manage Wi-Fi Direct connections, and change Wi-Fi Direct settings.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.CallHistoryRead">
      <summary>The application can read call log items.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Power">
      <summary>The application can control power-related settings, such as dimming the screen.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.ContactWrite">
      <summary>The application can create, update, and delete your profile, contacts, and any contact history that is related to this application. Contact history can include social network activity.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.MessageWrite">
      <summary>The application can write, send, sync, and remove text messages, multimedia messages, and emails.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.ContentWrite">
      <summary>The application can create, update, and delete media content information.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Push">
      <summary>The application can receive notifications from the Internet.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.AccountRead">
      <summary>The application can read accounts.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.ExternalStorage">
      <summary>The application can read and write files that are saved to external storage, such as SD cards.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Recorder">
      <summary>The application can record video and audio.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.PackageManagerInfo">
      <summary>The application can retrieve information about installed packages.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.NFCCardEmulation">
      <summary>The application can access smart card details, such as credit card details, and allow users to make payments via NFC.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.CalendarWrite">
      <summary>The application can create, update, and delete events and tasks.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.WindowPrioritySet">
      <summary>The application can appear on top of other windows and screens, including the lock screen, according to the order of priority of the windows. This may prevent you from interacting with other applications or screens until the window for the application is closed.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.VolumeSet">
      <summary>The application can adjust the volume for different features, such as notification alerts, ringtones, and media.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.CallHistoryWrite">
      <summary>The application can create, update, and delete call log items.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.AlarmSet">
      <summary>The application can set alarms and wake the device up at scheduled times.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Call">
      <summary>The application can make phone calls to numbers when they are tapped without further confirmation.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Email">
      <summary>The application can manage your email accounts, including your folders and emails.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.ContactRead">
      <summary>The application can read your profile, contacts, and contact history. Contact history can include social network activity.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Shortcut">
      <summary>The application can create and delete shortcuts.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.KeyManager">
      <summary>The application can save keys, certificates, and data to, and retrieve and delete them from password-protected storage.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.LED">
      <summary>The application can turn LEDs on or off, such as the LED on the front of the device and the camera flash.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.NetworkProfile">
      <summary>The application can add, remove, and edit network profiles.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.AlarmGet">
      <summary>The application can read information about the saved alarms.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Display">
      <summary>The application can manage display settings, such as the brightness. This can increase battery consumption.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.CalendarRead">
      <summary>The application can create, update, and delete events and tasks.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.NFC">
      <summary>The application can read and write NFC tag information, and send NFC messages to other devices.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.AccountWrite">
      <summary>The application can create, edit, and delete accounts.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Bluetooth">
      <summary>The application can perform unrestricted actions using Bluetooth, such as scanning for and connecting to other devices.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Notification">
      <summary>The application can show and hide its own notifications and badges.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.NetworkSet">
      <summary>The application can turn Wi-Fi on and off, and connect to and disconnect from Wi-Fi and mobile networks.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.ExternalStorageAppData">
      <summary>The application can read and write its own files in external storage, such as SD cards.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Download">
      <summary>The application can manage HTTP downloads.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.Telephony">
      <summary>The application can retrieve telephony information, such as the network and SIM card used, the IMEI, and the statuses of calls.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.TizenCapability.MessageRead">
      <summary>The application can retrieve messages from message boxes or receive messages.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.WSACompilationOverrides.None">
      <summary>C# files are compiled using Mono compiler.</summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.WSACompilationOverrides.UseNetCore">
      <summary>
        <para>C# files are compiled using Microsoft compiler and .NET Core, you can use Windows Runtime API, but classes implemented in C# files aren't accessible from JS or Boo languages.</para>
        <para>Note: when using API from Windows Runtime, it's advisable to wrap the code with NETFX_CORE define, because the API is only avaible when building to Windows Store Apps, and it's not available in Unity Editor.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.PlayerSettings.WSACompilationOverrides.UseNetCorePartially">
      <summary>C# files not located in Plugins, Standard Assets, Pro Standard Assets folders are compiled using Microsoft compiler and .NET Core, all other C# files are compiled using Mono compiler. The advantage is that classes implemented in C# are accessible from JS and Boo languages.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDimUnknown">
      <summary>Unknown Texture dimension.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDim2D">
      <summary>2D Texture.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDim3D">
      <summary>3D Texture.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDimCUBE">
      <summary>Texure Cube (Cubemap).</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDimAny">
      <summary>Any texture dimension (catch all).</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyTexDim.TexDimRECT">
      <summary>Texture Rect.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyType.Color">
      <summary>Color Property.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyType.Vector">
      <summary>Vector Property.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyType.Float">
      <summary>Float Property.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyType.Range">
      <summary>Range Property.</summary>
    </member>
    <member name="F:UnityEngine.ShaderUtil.ShaderPropertyType.TexEnv">
      <summary>Texture Property.</summary>
    </member>
  </members>
</doc>